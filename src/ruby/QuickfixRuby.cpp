/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


#define SWIG_VERSION 0x040101
#define SWIGRUBY
#define SWIG_DIRECTORS

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4
#define SWIG_POINTER_CLEAR         0x8
#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows returning the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
/* Runtime errors are < 0 */
#define SWIG_ERROR                 (-1)
/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
/* Errors < -200 are generic runtime specific errors */
#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)

#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del object mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13


#if __GNUC__ >= 7
#pragma GCC diagnostic push
#if defined(__cplusplus)
#pragma GCC diagnostic ignored "-Wregister"
#if __GNUC__ >= 10
#pragma GCC diagnostic ignored "-Wvolatile"
#if __GNUC__ >= 11
#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion"
#endif
#endif
#endif
#endif

#include <ruby.h>

#if __GNUC__ >= 7
#pragma GCC diagnostic pop
#endif

/* Ruby 1.9.1 has a "memoisation optimisation" when compiling with GCC which
 * breaks using rb_intern as an lvalue, as SWIG does.  We work around this
 * issue for now by disabling this.
 * https://sourceforge.net/tracker/?func=detail&aid=2859614&group_id=1645&atid=101645
 */
#ifdef rb_intern
# undef rb_intern
#endif

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef bind
# undef bind
#endif
#ifdef close
# undef close
#endif
#ifdef connect
# undef connect
#endif


/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif
#ifndef RTYPEDDATA_P
# define RTYPEDDATA_P(x) (TYPE(x) != T_DATA)
#endif



/*
 * The following macros are used for providing the correct type of a
 * function pointer to the Ruby C API.
 * Starting with Ruby 2.7 (corresponding to RB_METHOD_DEFINITION_DECL being
 * defined) these macros act transparently due to Ruby's moving away from
 * ANYARGS and instead employing strict function signatures.
 *
 * Note: In case of C (not C++) the macros are transparent even before
 * Ruby 2.7 due to the fact that the Ruby C API used function declarators
 * with empty parentheses, which allows for an unspecified number of
 * arguments.
 *
 * PROTECTFUNC(f) is used for the function pointer argument of the Ruby
 * C API function rb_protect().
 *
 * VALUEFUNC(f) is used for the function pointer argument(s) of Ruby C API
 * functions like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is used to typecast a C function that implements either
 * the "mark" or "free" stuff for a Ruby Data object, so that it can be
 * passed as an argument to Ruby C API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 *
 * SWIG_RUBY_VOID_ANYARGS_FUNC(f) is used for the function pointer
 * argument(s) of Ruby C API functions like rb_define_virtual_variable().
 *
 * SWIG_RUBY_INT_ANYARGS_FUNC(f) is used for the function pointer
 * argument(s) of Ruby C API functions like st_foreach().
 */
#if defined(__cplusplus) && !defined(RB_METHOD_DEFINITION_DECL)
#  define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#  define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#  define VOIDFUNC(f) ((RUBY_DATA_FUNC) f)
#  define SWIG_RUBY_VOID_ANYARGS_FUNC(f) ((void (*)(ANYARGS))(f))
#  define SWIG_RUBY_INT_ANYARGS_FUNC(f) ((int (*)(ANYARGS))(f))
#else
#  define PROTECTFUNC(f) (f)
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#  define SWIG_RUBY_VOID_ANYARGS_FUNC(f) (f)
#  define SWIG_RUBY_INT_ANYARGS_FUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a function in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(ST_DATA_T_DEFINED)
/* Needs to be explicitly included for Ruby 1.8 and earlier */
#include <st.h>
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif

/* Global hash table to store Trackings from C/C++
   structs to Ruby Objects.
*/
static st_table* swig_ruby_trackings = NULL;

static VALUE swig_ruby_trackings_count(ID id, VALUE *var) {
  return SWIG2NUM(swig_ruby_trackings->num_entries);
}


/* Setup a hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a hash table to store Trackings from C++
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  VALUE trackings_value = Qnil;
  /* change the variable name so that we can mix modules
     compiled with older SWIG's - this used to be called "@__trackings__" */
  ID trackings_id = rb_intern( "@__safetrackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  trackings_value = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* The trick here is that we have to store the hash table
  pointer in a Ruby variable. We do not want Ruby's GC to
  treat this pointer as a Ruby object, so we convert it to
  a Ruby numeric value. */
  if (trackings_value == Qnil) {
    /* No, it hasn't.  Create one ourselves */
    swig_ruby_trackings = st_init_numtable();
    rb_ivar_set( _mSWIG, trackings_id, SWIG2NUM(swig_ruby_trackings) );
  } else {
    swig_ruby_trackings = (st_table*)NUM2SWIG(trackings_value);
  }

  rb_define_virtual_variable("SWIG_TRACKINGS_COUNT",
                             VALUEFUNC(swig_ruby_trackings_count),
                             SWIG_RUBY_VOID_ANYARGS_FUNC((rb_gvar_setter_t*)NULL));
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* Store the mapping to the global hash table. */
  st_insert(swig_ruby_trackings, (st_data_t)ptr, object);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Now lookup the value stored in the global hash table */
  VALUE value;

  if (st_lookup(swig_ruby_trackings, (st_data_t)ptr, &value)) {
    return value;
  } else {
    return Qnil;
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Delete the object from the hash table */
  st_delete(swig_ruby_trackings, (st_data_t *)&ptr, NULL);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object. */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    // object might have the T_ZOMBIE type, but that's just
    // because the GC has flagged it as such for a deferred
    // destruction. Until then, it's still a T_DATA object.
    DATA_PTR(object) = 0;
  }
}

/* This is a helper method that iterates over all the trackings
   passing the C++ object pointer and its related Ruby object
   to the passed callback function. */

/* Proxy method to abstract the internal trackings datatype */
static int swig_ruby_internal_iterate_callback(st_data_t ptr, st_data_t obj, st_data_t meth) {
  ((void (*) (void *, VALUE))meth)((void *)ptr, (VALUE)obj);
  return ST_CONTINUE;
}

SWIGRUNTIME void SWIG_RubyIterateTrackings( void(*meth)(void* ptr, VALUE obj) ) {
  st_foreach(swig_ruby_trackings,
             SWIG_RUBY_INT_ANYARGS_FUNC(swig_ruby_internal_iterate_callback),
             (st_data_t)meth);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    swig_ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), "%s", msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, "%s", x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;

  if (!ptr)
    return Qnil;

  assert(type);
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);

      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        const char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));

  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  if (NIL_P(stype))
    return NULL;
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef struct {
  void (*datafree)(void *);
  int own;
} swig_ruby_owntype;

SWIGRUNTIME swig_ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, swig_ruby_owntype own) {
  swig_ruby_owntype oldown = {0, 0};
  if (TYPE(obj) == T_DATA && !RTYPEDDATA_P(obj)) {
    oldown.datafree = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own.datafree;
  }
  return oldown;
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, swig_ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA || (TYPE(obj) == T_DATA && RTYPEDDATA_P(obj))) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) {
    own->datafree = RDATA(obj)->dfree;
    own->own = 0;
  }
    
  if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE)) {
    if (!RDATA(obj)->dfree)
      return SWIG_ERROR_RELEASE_NOT_OWNED;
  }

  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }

    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  if (flags & SWIG_POINTER_CLEAR) {
    DATA_PTR(obj) = 0;
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      if (ptr) {
        if (tc->type == ty) {
          *ptr = vptr;
        } else {
          int newmemory = 0;
          *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
          if (newmemory == SWIG_CAST_NEW_MEMORY) {
            assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
            if (own)
              own->own = own->own | SWIG_CAST_NEW_MEMORY;
          }
        }
      }
    }
  } else {
    if (ptr)
      *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void *SWIGUNUSEDPARM(clientdata))
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  rb_undef_alloc_func(cl);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) )
    {
      VALUE num = rb_funcall2( proc, swig_arity_id, 0, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Ruby proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_NOUEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NOUEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif

#include <string>
#include <iostream>
#include <exception>
#include <map>

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {
    }

    virtual swig_ruby_owntype get_own() const {
      swig_ruby_owntype own = {0, 0};
      return own;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem *operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };


  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(swig_ruby_owntype own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    swig_ruby_owntype get_own() const {
      return _own;
    }

  private:
    swig_ruby_owntype _own;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };


  /* body args */
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };

  /* Base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    VALUE swig_error;
    std::string swig_msg;
  protected:
    DirectorException(VALUE error) : swig_error(error) {
    }

    DirectorException(VALUE error, const char *hdr, const char *msg ="") : swig_error(error), swig_msg(hdr) {
      if (msg[0]) {
	swig_msg += " ";
	swig_msg += msg;
      }
      if (swig_msg.size()) {
	VALUE str = rb_str_new(swig_msg.data(), swig_msg.size());
	swig_error = rb_exc_new3(error, str);
      } else {
	swig_error = error;
      }
    }

  public:
    virtual ~DirectorException() throw() {
    }

    VALUE getType() const {
      return CLASS_OF(swig_error);
    }

    VALUE getError() const {
      return swig_error;
    }

    /* Deprecated, use what() instead */
    const std::string& getMessage() const {
      return swig_msg;
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(VALUE error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(rb_eTypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(VALUE error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(VALUE error)
      : DirectorException(error) {
    }

    DirectorMethodException(const char *msg = "")
      : DirectorException(rb_eRuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(VALUE error) {
      throw DirectorMethodException(error);
    }
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException
  {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(rb_eRuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };

  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
# define __PTHREAD__
# if defined(_WIN32) || defined(__WIN32__)
#  define pthread_mutex_lock EnterCriticalSection
#  define pthread_mutex_unlock LeaveCriticalSection
#  define pthread_mutex_t CRITICAL_SECTION
#  define SWIG_MUTEX_INIT(var) var
# else
#  include <pthread.h>
#  define SWIG_MUTEX_INIT(var) var = PTHREAD_MUTEX_INITIALIZER
# endif
#endif

#ifdef  __PTHREAD__
  struct Guard {
    pthread_mutex_t *_mutex;

    Guard(pthread_mutex_t &mutex) : _mutex(&mutex) {
      pthread_mutex_lock(_mutex);
    }

    ~Guard() {
      pthread_mutex_unlock(_mutex);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped Ruby object */
    VALUE swig_self;
    /* flag indicating whether the object is owned by Ruby or c++ */
    mutable bool swig_disown_flag;

  public:
    /* wrap a Ruby object. */
    Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
    }

    /* return a pointer to the wrapped Ruby object */
    VALUE swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped Ruby object (the sense of "disown" is from Ruby) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag = true;
      }
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __PTHREAD__
    static pthread_mutex_t swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr)  const {
      if (vptr) {	
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, swig_ruby_owntype own) const {
      if (vptr && own.datafree) {
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    swig_ruby_owntype swig_release_ownership(void *vptr) const {
      swig_ruby_owntype own = {0, 0};
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	swig_ownership_map::iterator iter = swig_owner.find(vptr);
	if (iter != swig_owner.end()) {
	  own.datafree = iter->second->get_own().datafree;
	  swig_owner.erase(iter);
	}
      }
      return own;
    }
  };
}


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ApplVerID swig_types[0]
#define SWIGTYPE_p_Application swig_types[1]
#define SWIGTYPE_p_BeginString swig_types[2]
#define SWIGTYPE_p_DOMDocumentPtr swig_types[3]
#define SWIGTYPE_p_Data swig_types[4]
#define SWIGTYPE_p_DataDictionary swig_types[5]
#define SWIGTYPE_p_DataDictionaryProvider swig_types[6]
#define SWIGTYPE_p_Dictionaries swig_types[7]
#define SWIGTYPE_p_DoubleField swig_types[8]
#define SWIGTYPE_p_FIX__Acceptor swig_types[9]
#define SWIGTYPE_p_FIX__Application swig_types[10]
#define SWIGTYPE_p_FIX__BeginString swig_types[11]
#define SWIGTYPE_p_FIX__BoolField swig_types[12]
#define SWIGTYPE_p_FIX__CharField swig_types[13]
#define SWIGTYPE_p_FIX__CheckSumField swig_types[14]
#define SWIGTYPE_p_FIX__ConfigError swig_types[15]
#define SWIGTYPE_p_FIX__DataDictionary swig_types[16]
#define SWIGTYPE_p_FIX__DataDictionaryNotFound swig_types[17]
#define SWIGTYPE_p_FIX__DatabaseConnectionID swig_types[18]
#define SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t swig_types[19]
#define SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t swig_types[20]
#define SWIGTYPE_p_FIX__DateTime swig_types[21]
#define SWIGTYPE_p_FIX__Dictionary swig_types[22]
#define SWIGTYPE_p_FIX__DoNotSend swig_types[23]
#define SWIGTYPE_p_FIX__DoubleField swig_types[24]
#define SWIGTYPE_p_FIX__DuplicateFieldNumber swig_types[25]
#define SWIGTYPE_p_FIX__Exception swig_types[26]
#define SWIGTYPE_p_FIX__FieldBase swig_types[27]
#define SWIGTYPE_p_FIX__FieldConvertError swig_types[28]
#define SWIGTYPE_p_FIX__FieldMap swig_types[29]
#define SWIGTYPE_p_FIX__FieldNotFound swig_types[30]
#define SWIGTYPE_p_FIX__FileLog swig_types[31]
#define SWIGTYPE_p_FIX__FileLogFactory swig_types[32]
#define SWIGTYPE_p_FIX__FileStore swig_types[33]
#define SWIGTYPE_p_FIX__FileStoreFactory swig_types[34]
#define SWIGTYPE_p_FIX__Group swig_types[35]
#define SWIGTYPE_p_FIX__Header swig_types[36]
#define SWIGTYPE_p_FIX__IOException swig_types[37]
#define SWIGTYPE_p_FIX__IncorrectDataFormat swig_types[38]
#define SWIGTYPE_p_FIX__IncorrectMessageStructure swig_types[39]
#define SWIGTYPE_p_FIX__IncorrectTagValue swig_types[40]
#define SWIGTYPE_p_FIX__Initiator swig_types[41]
#define SWIGTYPE_p_FIX__IntField swig_types[42]
#define SWIGTYPE_p_FIX__InvalidMessage swig_types[43]
#define SWIGTYPE_p_FIX__InvalidMessageType swig_types[44]
#define SWIGTYPE_p_FIX__InvalidTagNumber swig_types[45]
#define SWIGTYPE_p_FIX__LocalDate swig_types[46]
#define SWIGTYPE_p_FIX__LocalTimeOnly swig_types[47]
#define SWIGTYPE_p_FIX__LocalTimeStamp swig_types[48]
#define SWIGTYPE_p_FIX__Log swig_types[49]
#define SWIGTYPE_p_FIX__LogFactory swig_types[50]
#define SWIGTYPE_p_FIX__MemoryStore swig_types[51]
#define SWIGTYPE_p_FIX__MemoryStoreFactory swig_types[52]
#define SWIGTYPE_p_FIX__Message swig_types[53]
#define SWIGTYPE_p_FIX__MessageParseError swig_types[54]
#define SWIGTYPE_p_FIX__MessageStore swig_types[55]
#define SWIGTYPE_p_FIX__MessageStoreExceptionWrapper swig_types[56]
#define SWIGTYPE_p_FIX__MessageStoreFactory swig_types[57]
#define SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper swig_types[58]
#define SWIGTYPE_p_FIX__MySQLConnection swig_types[59]
#define SWIGTYPE_p_FIX__MySQLLog swig_types[60]
#define SWIGTYPE_p_FIX__MySQLLogFactory swig_types[61]
#define SWIGTYPE_p_FIX__MySQLQuery swig_types[62]
#define SWIGTYPE_p_FIX__MySQLStore swig_types[63]
#define SWIGTYPE_p_FIX__MySQLStoreFactory swig_types[64]
#define SWIGTYPE_p_FIX__NoTagValue swig_types[65]
#define SWIGTYPE_p_FIX__NullApplication swig_types[66]
#define SWIGTYPE_p_FIX__NullLog swig_types[67]
#define SWIGTYPE_p_FIX__PostgreSQLConnection swig_types[68]
#define SWIGTYPE_p_FIX__PostgreSQLLog swig_types[69]
#define SWIGTYPE_p_FIX__PostgreSQLLogFactory swig_types[70]
#define SWIGTYPE_p_FIX__PostgreSQLQuery swig_types[71]
#define SWIGTYPE_p_FIX__PostgreSQLStore swig_types[72]
#define SWIGTYPE_p_FIX__PostgreSQLStoreFactory swig_types[73]
#define SWIGTYPE_p_FIX__RejectLogon swig_types[74]
#define SWIGTYPE_p_FIX__RepeatedTag swig_types[75]
#define SWIGTYPE_p_FIX__RepeatingGroupCountMismatch swig_types[76]
#define SWIGTYPE_p_FIX__RequiredTagMissing swig_types[77]
#define SWIGTYPE_p_FIX__RuntimeError swig_types[78]
#define SWIGTYPE_p_FIX__SSLSocketAcceptor swig_types[79]
#define SWIGTYPE_p_FIX__SSLSocketInitiator swig_types[80]
#define SWIGTYPE_p_FIX__ScreenLog swig_types[81]
#define SWIGTYPE_p_FIX__ScreenLogFactory swig_types[82]
#define SWIGTYPE_p_FIX__SenderCompID swig_types[83]
#define SWIGTYPE_p_FIX__Session swig_types[84]
#define SWIGTYPE_p_FIX__SessionID swig_types[85]
#define SWIGTYPE_p_FIX__SessionNotFound swig_types[86]
#define SWIGTYPE_p_FIX__SessionSettings swig_types[87]
#define SWIGTYPE_p_FIX__SocketAcceptor swig_types[88]
#define SWIGTYPE_p_FIX__SocketCloseFailed swig_types[89]
#define SWIGTYPE_p_FIX__SocketException swig_types[90]
#define SWIGTYPE_p_FIX__SocketInitiator swig_types[91]
#define SWIGTYPE_p_FIX__SocketRecvFailed swig_types[92]
#define SWIGTYPE_p_FIX__SocketSendFailed swig_types[93]
#define SWIGTYPE_p_FIX__StringField swig_types[94]
#define SWIGTYPE_p_FIX__SynchronizedApplication swig_types[95]
#define SWIGTYPE_p_FIX__TYPE__Type swig_types[96]
#define SWIGTYPE_p_FIX__TagNotDefinedForMessage swig_types[97]
#define SWIGTYPE_p_FIX__TagOutOfOrder swig_types[98]
#define SWIGTYPE_p_FIX__TargetCompID swig_types[99]
#define SWIGTYPE_p_FIX__Trailer swig_types[100]
#define SWIGTYPE_p_FIX__UnsupportedMessageType swig_types[101]
#define SWIGTYPE_p_FIX__UnsupportedVersion swig_types[102]
#define SWIGTYPE_p_FIX__UtcDate swig_types[103]
#define SWIGTYPE_p_FIX__UtcDateField swig_types[104]
#define SWIGTYPE_p_FIX__UtcTimeOnly swig_types[105]
#define SWIGTYPE_p_FIX__UtcTimeOnlyField swig_types[106]
#define SWIGTYPE_p_FIX__UtcTimeStamp swig_types[107]
#define SWIGTYPE_p_FIX__UtcTimeStampField swig_types[108]
#define SWIGTYPE_p_Fields swig_types[109]
#define SWIGTYPE_p_Group swig_types[110]
#define SWIGTYPE_p_Groups swig_types[111]
#define SWIGTYPE_p_IntArray swig_types[112]
#define SWIGTYPE_p_IntField swig_types[113]
#define SWIGTYPE_p_Log swig_types[114]
#define SWIGTYPE_p_LogFactory swig_types[115]
#define SWIGTYPE_p_MYSQL swig_types[116]
#define SWIGTYPE_p_MessageStore swig_types[117]
#define SWIGTYPE_p_MessageStoreFactory swig_types[118]
#define SWIGTYPE_p_MsgType swig_types[119]
#define SWIGTYPE_p_Mutex swig_types[120]
#define SWIGTYPE_p_PGconn swig_types[121]
#define SWIGTYPE_p_RSA swig_types[122]
#define SWIGTYPE_p_Responder swig_types[123]
#define SWIGTYPE_p_SessionID swig_types[124]
#define SWIGTYPE_p_SessionToPort swig_types[125]
#define SWIGTYPE_p_StringField swig_types[126]
#define SWIGTYPE_p_TimeRange swig_types[127]
#define SWIGTYPE_p_UtcDateField swig_types[128]
#define SWIGTYPE_p_X509 swig_types[129]
#define SWIGTYPE_p_allocator_type swig_types[130]
#define SWIGTYPE_p_bool swig_types[131]
#define SWIGTYPE_p_char swig_types[132]
#define SWIGTYPE_p_const_iterator swig_types[133]
#define SWIGTYPE_p_difference_type swig_types[134]
#define SWIGTYPE_p_double swig_types[135]
#define SWIGTYPE_p_g_const_iterator swig_types[136]
#define SWIGTYPE_p_g_iterator swig_types[137]
#define SWIGTYPE_p_g_value_type swig_types[138]
#define SWIGTYPE_p_int swig_types[139]
#define SWIGTYPE_p_int64_t swig_types[140]
#define SWIGTYPE_p_iterator swig_types[141]
#define SWIGTYPE_p_key_type swig_types[142]
#define SWIGTYPE_p_message_order swig_types[143]
#define SWIGTYPE_p_p_FIX__DataDictionary swig_types[144]
#define SWIGTYPE_p_size_type swig_types[145]
#define SWIGTYPE_p_ssize_t swig_types[146]
#define SWIGTYPE_p_std__functionT_FIX__UtcTimeStamp_fF_t swig_types[147]
#define SWIGTYPE_p_std__istream swig_types[148]
#define SWIGTYPE_p_std__lessT_FIX__SessionID_t swig_types[149]
#define SWIGTYPE_p_std__logic_error swig_types[150]
#define SWIGTYPE_p_std__mapT_FIX__SessionID_uint16_t_t swig_types[151]
#define SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t swig_types[152]
#define SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator swig_types[153]
#define SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator swig_types[154]
#define SWIGTYPE_p_std__mapT_std__string_std__string_t__const_iterator swig_types[155]
#define SWIGTYPE_p_std__ostream swig_types[156]
#define SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t swig_types[157]
#define SWIGTYPE_p_std__string swig_types[158]
#define SWIGTYPE_p_std__string__size_type swig_types[159]
#define SWIGTYPE_p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t swig_types[160]
#define SWIGTYPE_p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t swig_types[161]
#define SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator swig_types[162]
#define SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator swig_types[163]
#define SWIGTYPE_p_std__vectorT_std__string_t swig_types[164]
#define SWIGTYPE_p_swig__ConstIterator swig_types[165]
#define SWIGTYPE_p_swig__GC_VALUE swig_types[166]
#define SWIGTYPE_p_swig__Iterator swig_types[167]
#define SWIGTYPE_p_tm swig_types[168]
#define SWIGTYPE_p_value_type swig_types[169]
#define SWIGTYPE_p_void swig_types[170]
static swig_type_info *swig_types[172];
static swig_module_info swig_module = {swig_types, 171, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_quickfix
#define SWIG_name    "Quickfix"

static VALUE mQuickfix;

#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.9 changed the file name of this header */
#ifdef HAVE_RUBY_IO_H
#include "ruby/io.h"
#else
#include "rubyio.h"
#endif

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#include <string>


#include <iostream>


#include <typeinfo>
#include <stdexcept>


namespace swig {
  class SwigGCReferences {
    VALUE _hash;

    SwigGCReferences() : _hash(Qnil) {
    }
    ~SwigGCReferences() {
      if (_hash != Qnil)
        rb_gc_unregister_address(&_hash);
    }
    static void EndProcHandler(VALUE) {
      // Ruby interpreter ending - _hash can no longer be accessed.
      SwigGCReferences &s_references = instance();
      s_references._hash = Qnil;
    }
  public:
    static SwigGCReferences& instance() {
      // Hash of all GC_VALUE's currently in use
      static SwigGCReferences s_references;

      return s_references;
    }
    static void initialize() {
      SwigGCReferences &s_references = instance();
      if (s_references._hash == Qnil) {
        rb_set_end_proc(&EndProcHandler, Qnil);
        s_references._hash = rb_hash_new();
        rb_gc_register_address(&s_references._hash);
      }
    }
    void GC_register(VALUE& obj) {
      if (FIXNUM_P(obj) || SPECIAL_CONST_P(obj) || SYMBOL_P(obj))
        return;
      if (_hash != Qnil) {
        VALUE val = rb_hash_aref(_hash, obj);
        unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
        ++n;
        rb_hash_aset(_hash, obj, INT2NUM(n));
      }
    }
    void GC_unregister(const VALUE& obj) {
      if (FIXNUM_P(obj) || SPECIAL_CONST_P(obj) || SYMBOL_P(obj))
        return;
      // this test should not be needed but I've noticed some very erratic
      // behavior of none being unregistered in some very rare situations.
      if (BUILTIN_TYPE(obj) == T_NONE)
        return;
      if (_hash != Qnil) {
        VALUE val = rb_hash_aref(_hash, obj);
        unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
        --n;
        if (n)
          rb_hash_aset(_hash, obj, INT2NUM(n));
        else
          rb_hash_delete(_hash, obj);
      }
    }
  };

  class GC_VALUE {
  protected:
    VALUE  _obj;

    static ID hash_id;
    static ID   lt_id;
    static ID   gt_id;
    static ID   eq_id;
    static ID   le_id;
    static ID   ge_id;

    static ID  pos_id;
    static ID  neg_id;
    static ID  inv_id;

    static ID  add_id;
    static ID  sub_id;
    static ID  mul_id;
    static ID  div_id;
    static ID  mod_id;

    static ID  and_id;
    static ID   or_id;
    static ID  xor_id;

    static ID  lshift_id;
    static ID  rshift_id;

    struct OpArgs
    {
      VALUE src;
      ID    id;
      int   nargs;
      VALUE target;
    };


  public:
    GC_VALUE() : _obj(Qnil)
    {
    }

    GC_VALUE(const GC_VALUE& item) : _obj(item._obj)
    {
      SwigGCReferences::instance().GC_register(_obj);
    }
    
    GC_VALUE(VALUE obj) :_obj(obj)
    {
      SwigGCReferences::instance().GC_register(_obj);
    }
    
    ~GC_VALUE() 
    {
      SwigGCReferences::instance().GC_unregister(_obj);
    }
    
    GC_VALUE & operator=(const GC_VALUE& item) 
    {
      SwigGCReferences::instance().GC_unregister(_obj);
      _obj = item._obj;
      SwigGCReferences::instance().GC_register(_obj);
      return *this;
    }

    operator VALUE() const
    {
      return _obj;
    }

    VALUE inspect() const
    {
      return rb_inspect(_obj);
    }

    VALUE to_s() const
    {
      return rb_inspect(_obj);
    }

    static VALUE swig_rescue_swallow(VALUE, VALUE)
    {
      /*
      VALUE errstr = rb_obj_as_string(rb_errinfo());
      printf("Swallowing error: '%s'\n", RSTRING_PTR(StringValue(errstr)));
      */
      return Qnil; /* Swallow Ruby exception */
    }

    static VALUE swig_rescue_funcall(VALUE p)
    {
      OpArgs* args = (OpArgs*) p;
      return rb_funcall(args->src, args->id, args->nargs, args->target);
    }

    bool relational_equal_op(const GC_VALUE& other, const ID& op_id, bool (*op_func)(const VALUE& a, const VALUE& b)) const
    {
      if (FIXNUM_P(_obj) && FIXNUM_P(other._obj)) {
        return op_func(_obj, other._obj);
      }
      bool res = false;
      VALUE ret = Qnil;
      SWIG_RUBY_THREAD_BEGIN_BLOCK;
      if (rb_respond_to(_obj, op_id)) {
        OpArgs  args;
        args.src    = _obj;
        args.id     = op_id;
        args.nargs  = 1;
        args.target = VALUE(other);
        ret = rb_rescue(VALUEFUNC(swig_rescue_funcall), VALUE(&args),
                       (VALUEFUNC(swig_rescue_swallow)), Qnil);
      }
      if (ret == Qnil) {
        VALUE a = rb_funcall2(         _obj, hash_id, 0, 0 );
        VALUE b = rb_funcall2( VALUE(other), hash_id, 0, 0 );
        res = op_func(a, b);
      } else {
        res = RTEST(ret);
      }
      SWIG_RUBY_THREAD_END_BLOCK;
      return res;
    }

    static bool operator_eq(const VALUE& a, const VALUE& b) { return a == b; }
    static bool operator_lt(const VALUE& a, const VALUE& b) { return a < b; }
    static bool operator_le(const VALUE& a, const VALUE& b) { return a <= b; }
    static bool operator_gt(const VALUE& a, const VALUE& b) { return a > b; }
    static bool operator_ge(const VALUE& a, const VALUE& b) { return a >= b; }

    bool operator==(const GC_VALUE& other) const { return relational_equal_op(other, eq_id, operator_eq); }
    bool operator<(const GC_VALUE& other) const { return relational_equal_op(other, lt_id, operator_lt); }
    bool operator<=(const GC_VALUE& other) const { return relational_equal_op(other, le_id, operator_le); }
    bool operator>(const GC_VALUE& other) const { return relational_equal_op(other, gt_id, operator_gt); }
    bool operator>=(const GC_VALUE& other) const { return relational_equal_op(other, ge_id, operator_ge); }

    bool operator!=(const GC_VALUE& other) const
    {
      return !(this->operator==(other));
    }

    GC_VALUE unary_op(const ID& op_id) const
    {
      VALUE ret = Qnil;
      SWIG_RUBY_THREAD_BEGIN_BLOCK;
      OpArgs  args;
      args.src    = _obj;
      args.id     = op_id;
      args.nargs  = 0;
      args.target = Qnil;
      ret = rb_rescue(VALUEFUNC(swig_rescue_funcall), VALUE(&args),
                     (VALUEFUNC(swig_rescue_swallow)), Qnil);
      SWIG_RUBY_THREAD_END_BLOCK;
      return ret;
    }

    GC_VALUE operator+() const { return unary_op(pos_id); }
    GC_VALUE operator-() const { return unary_op(neg_id); }
    GC_VALUE operator~() const { return unary_op(inv_id); }

    GC_VALUE binary_op(const GC_VALUE& other, const ID& op_id) const
    {
      VALUE ret = Qnil;
      SWIG_RUBY_THREAD_BEGIN_BLOCK;
      OpArgs  args;
      args.src    = _obj;
      args.id     = op_id;
      args.nargs  = 1;
      args.target = VALUE(other);
      ret = rb_rescue(VALUEFUNC(swig_rescue_funcall), VALUE(&args),
                     (VALUEFUNC(swig_rescue_swallow)), Qnil);
      SWIG_RUBY_THREAD_END_BLOCK;
      return GC_VALUE(ret);
    }

    GC_VALUE operator+(const GC_VALUE& other) const { return binary_op(other, add_id); }
    GC_VALUE operator-(const GC_VALUE& other) const { return binary_op(other, sub_id); }
    GC_VALUE operator*(const GC_VALUE& other) const { return binary_op(other, mul_id); }
    GC_VALUE operator/(const GC_VALUE& other) const { return binary_op(other, div_id); }
    GC_VALUE operator%(const GC_VALUE& other) const { return binary_op(other, mod_id); }
    GC_VALUE operator&(const GC_VALUE& other) const { return binary_op(other, and_id); }
    GC_VALUE operator^(const GC_VALUE& other) const { return binary_op(other, xor_id); }
    GC_VALUE operator|(const GC_VALUE& other) const { return binary_op(other, or_id); }
    GC_VALUE operator<<(const GC_VALUE& other) const { return binary_op(other, lshift_id); }
    GC_VALUE operator>>(const GC_VALUE& other) const { return binary_op(other, rshift_id); }
  };

  ID  GC_VALUE::hash_id = rb_intern("hash");
  ID  GC_VALUE::lt_id = rb_intern("<");
  ID  GC_VALUE::gt_id = rb_intern(">");
  ID  GC_VALUE::eq_id = rb_intern("==");
  ID  GC_VALUE::le_id = rb_intern("<=");
  ID  GC_VALUE::ge_id = rb_intern(">=");

  ID  GC_VALUE::pos_id = rb_intern("+@");
  ID  GC_VALUE::neg_id = rb_intern("-@");
  ID  GC_VALUE::inv_id = rb_intern("~");

  ID  GC_VALUE::add_id = rb_intern("+");
  ID  GC_VALUE::sub_id = rb_intern("-");
  ID  GC_VALUE::mul_id = rb_intern("*");
  ID  GC_VALUE::div_id = rb_intern("/");
  ID  GC_VALUE::mod_id = rb_intern("%");

  ID  GC_VALUE::and_id = rb_intern("&");
  ID  GC_VALUE::or_id  = rb_intern("|");
  ID  GC_VALUE::xor_id = rb_intern("^");

  ID  GC_VALUE::lshift_id = rb_intern("<<");
  ID  GC_VALUE::rshift_id = rb_intern(">>");

  typedef GC_VALUE LANGUAGE_OBJ;

} // namespace swig



#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <stddef.h>


namespace swig {
  struct stop_iteration {
  };

  /** 
   * Abstract base class used to represent all iterators of STL containers.
   */
  struct ConstIterator {
  public:
    typedef ConstIterator self_type;

  protected:
    GC_VALUE _seq;

  protected:
    ConstIterator(VALUE seq) : _seq(seq)
    {
    }

    // Random access iterator methods, but not required in Ruby
    virtual ptrdiff_t distance(const ConstIterator &x) const
    {
      throw std::invalid_argument("distance not supported");
    }

    virtual bool equal (const ConstIterator &x) const
    {
      throw std::invalid_argument("equal not supported");
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("advance not supported");
    }
      
  public:
    virtual ~ConstIterator() {}

    // Access iterator method, required by Ruby
    virtual VALUE value() const {
      throw std::invalid_argument("value not supported");
      return Qnil;
    };

    virtual VALUE setValue( const VALUE& v ) {
      throw std::invalid_argument("value= not supported");
      return Qnil;
    }

    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    virtual VALUE to_s() const {
      throw std::invalid_argument("to_s not supported");
      return Qnil;
    }

    virtual VALUE inspect() const {
      throw std::invalid_argument("inspect not supported");
      return Qnil;
    }
    
    virtual ConstIterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }

    //
    // C++ common/needed methods.  We emulate a bidirectional
    // operator, to be compatible with all the STL.
    // The iterator traits will then tell the STL what type of
    // iterator we really are.
    //
    ConstIterator() : _seq( Qnil )
    {
    }

    ConstIterator( const self_type& b ) : _seq( b._seq )
    {
    }

    self_type& operator=( const self_type& b )
    {
      _seq = b._seq;
      return *this;
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const ConstIterator& x) const
    {
      return ! operator==(x);
    }
      
    // Pre-decrement operator
    self_type& operator--()
    {
      return *previous();
    }

    // Pre-increment operator
    self_type& operator++()
    {
      return *next();
    }

    // Post-decrement operator
    self_type operator--(int)
    {
      self_type r = *this;
      previous();
      return r;
    }

    // Post-increment operator
    self_type operator++(int)
    {
      self_type r = *this;
      next();
      return r;
    }

    ConstIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    ConstIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }

    ConstIterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    ConstIterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const ConstIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::ConstIterator *");
	init = 1;
      }	
      return desc;
    }
  };


  /**
   * Abstract base class used to represent all non-const iterators of STL containers.
   * 
   */
  struct Iterator : public ConstIterator {
  public:
    typedef Iterator self_type;

  protected:
    Iterator(VALUE seq) : ConstIterator(seq)
    {
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("operation not supported");
    }

  public:
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::Iterator *");
	init = 1;
      }	
      return desc;
    }
    
    virtual Iterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }
      
    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const Iterator& x) const
    {
      return ! operator==(x);
    }
      
    Iterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    Iterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    Iterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    Iterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const Iterator& x) const
    {
      return x.distance(*this);
    }
  };

}


SWIGINTERN VALUE
SWIG_ruby_failed(VALUE SWIGUNUSEDPARM(arg1), VALUE SWIGUNUSEDPARM(arg2))
{
  return Qnil;
} 


/*@SWIG:/usr/local/share/swig/4.1.1/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE arg)
{
  VALUE *args = (VALUE *)arg;
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(VALUEFUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, VALUEFUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
/*@SWIG:/usr/local/share/swig/4.1.1/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULL(VALUE arg)
{
  VALUE *args = (VALUE *)arg;
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long long *res = (long long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULL(obj) : rb_big2ull(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (VALUE obj, unsigned long long *val)
{ 
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(VALUEFUNC(SWIG_AUX_NUM2ULL), (VALUE)a, VALUEFUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}


/*@SWIG:/usr/local/share/swig/4.1.1/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE arg)
{
  VALUE *args = (VALUE *)arg;
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(VALUEFUNC(SWIG_AUX_NUM2LONG), (VALUE)a, VALUEFUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
/*@SWIG:/usr/local/share/swig/4.1.1/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LL(VALUE arg)
{
  VALUE *args = (VALUE *)arg;
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long long *res = (long long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LL(obj) : rb_big2ll(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long_SS_long (VALUE obj, long long *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(VALUEFUNC(SWIG_AUX_NUM2LL), (VALUE)a, VALUEFUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  }
#endif
  return res;
}


  #define SWIG_From_long   LONG2NUM 


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE VALUE 
SWIG_From_long_SS_long  (long long value)
{
  return LL2NUM(value);
}
#endif


SWIGINTERNINLINE VALUE
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  (static_cast< long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  }
#endif
}


#include <algorithm>


#include <utility>


#include <set>


typedef int IntArray;

SWIGINTERN IntArray *new_IntArray(size_t nelements){
    return (new int[nelements]());
  }
SWIGINTERN int IntArray___getitem__(IntArray *self,size_t index){
    return self[index];
  }

SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}

SWIGINTERN void IntArray___setitem__(IntArray *self,size_t index,int value){
    self[index] = value;
  }
SWIGINTERN int *IntArray_cast(IntArray *self){
    return self;
  }
SWIGINTERN IntArray *IntArray_frompointer(int *t){
    return static_cast< IntArray * >(t);
  }

#include <config.h>
#include <Except.h>
#include <Exceptions.h>
#include <FieldTypes.h>
#include <Fields.h>
#include <FixFields.h>
#include <Message.h>
#include <Group.h>
#include <Field.h>
#include <FixCommonFields.h>
#include <Values.h>
#include <SessionID.h>
#include <Dictionary.h>
#include <SessionSettings.h>
#include <Session.h>
#include <Log.h>
#include <FileLog.h>
#include <MessageStore.h>
#include <FileStore.h>
#include <Application.h>
#include <Initiator.h>
#include <SocketInitiator.h>
#include <Acceptor.h>
#include <SocketAcceptor.h>
#include <DataDictionary.h>
#include <SocketMonitor.h>
#include <DatabaseConnectionID.h>
#include <DatabaseConnectionPool.h>

#ifdef HAVE_SSL
#include <SSLSocketAcceptor.h>
#include <SSLSocketInitiator.h>
#include <SSLSocketConnection.h>
#else
#include <SSLStubs.h>
#endif

#ifdef HAVE_MYSQL
#include <MySQLConnection.h>
#include <MySQLStore.h>
#include <MySQLLog.h>
#else
#include <MySQLStubs.h>
#endif

#ifdef HAVE_POSTGRESQL
#include <PostgreSQLConnection.h>
#include <PostgreSQLStore.h>
#include <PostgreSQLLog.h>
#else
#include <PostgreSQLStubs.h>
#endif

#include <functional>
#ifdef SWIGPYTHON
#include "datetime.h"
#endif

#ifdef SWIGPYTHON
template<typename Exception>
void raisePythonException(Exception const& e, swig_type_info* swigType)
{
  SWIG_Python_Raise(SWIG_NewPointerObj((new Exception(static_cast<const Exception&>(e))),swigType,SWIG_POINTER_OWN), typeid(Exception).name(), swigType);
}

bool tryPythonException(std::function<bool()> const& function)
{
  try
  {
    return function();
  }
  catch(FIX::DataDictionaryNotFound const& e)
  {
    raisePythonException<FIX::DataDictionaryNotFound>(e, SWIGTYPE_p_FIX__DataDictionaryNotFound); return false;
  }
  catch(FIX::FieldNotFound const& e)
  {
    raisePythonException<FIX::FieldNotFound>(e, SWIGTYPE_p_FIX__FieldNotFound); return false;
  }
  catch(FIX::FieldConvertError const& e)
  {
    raisePythonException<FIX::FieldConvertError>(e, SWIGTYPE_p_FIX__FieldConvertError); return false;
  }
  catch(FIX::MessageParseError const& e)
  {
    raisePythonException<FIX::MessageParseError>(e, SWIGTYPE_p_FIX__MessageParseError); return false;
  }
  catch(FIX::InvalidMessage const& e)
  {
    raisePythonException<FIX::InvalidMessage>(e, SWIGTYPE_p_FIX__InvalidMessage); return false;
  }
  catch(FIX::ConfigError const& e)
  {
    raisePythonException<FIX::ConfigError>(e, SWIGTYPE_p_FIX__ConfigError); return false;
  }
  catch(FIX::RuntimeError const& e)
  {
    raisePythonException<FIX::RuntimeError>(e, SWIGTYPE_p_FIX__RuntimeError); return false;
  }
  catch(FIX::InvalidTagNumber const& e)
  {
    raisePythonException<FIX::InvalidTagNumber>(e, SWIGTYPE_p_FIX__InvalidTagNumber); return false;
  }
  catch(FIX::RequiredTagMissing const& e)
  {
    raisePythonException<FIX::RequiredTagMissing>(e, SWIGTYPE_p_FIX__RequiredTagMissing); return false;
  }
  catch(FIX::TagNotDefinedForMessage const& e)
  {
    raisePythonException<FIX::TagNotDefinedForMessage>(e, SWIGTYPE_p_FIX__TagNotDefinedForMessage); return false;
  }
  catch(FIX::NoTagValue const& e)
  {
    raisePythonException<FIX::NoTagValue>(e, SWIGTYPE_p_FIX__NoTagValue); return false;
  }
  catch(FIX::IncorrectTagValue const& e)
  {
    raisePythonException<FIX::IncorrectTagValue>(e, SWIGTYPE_p_FIX__IncorrectTagValue); return false;
  }
  catch(FIX::IncorrectDataFormat const& e)
  {
    raisePythonException<FIX::IncorrectDataFormat>(e, SWIGTYPE_p_FIX__IncorrectDataFormat); return false;
  }
  catch(FIX::IncorrectMessageStructure const& e)
  {
    raisePythonException<FIX::IncorrectMessageStructure>(e, SWIGTYPE_p_FIX__IncorrectMessageStructure); return false;
  }
  catch(FIX::DuplicateFieldNumber const& e)
  {
    raisePythonException<FIX::DuplicateFieldNumber>(e, SWIGTYPE_p_FIX__DuplicateFieldNumber); return false;
  }
  catch(FIX::InvalidMessageType const& e)
  {
    raisePythonException<FIX::InvalidMessageType>(e, SWIGTYPE_p_FIX__InvalidMessageType); return false;
  }
  catch(FIX::UnsupportedMessageType const& e)
  {
    raisePythonException<FIX::UnsupportedMessageType>(e, SWIGTYPE_p_FIX__UnsupportedMessageType); return false;
  }
  catch(FIX::UnsupportedVersion const& e)
  {
    raisePythonException<FIX::UnsupportedVersion>(e, SWIGTYPE_p_FIX__UnsupportedVersion); return false;
  }
  catch(FIX::TagOutOfOrder const& e)
  {
    raisePythonException<FIX::TagOutOfOrder>(e, SWIGTYPE_p_FIX__TagOutOfOrder); return false;
  }
  catch(FIX::RepeatedTag const& e)
  {
    raisePythonException<FIX::RepeatedTag>(e, SWIGTYPE_p_FIX__RepeatedTag); return false;
  }
  catch(FIX::RepeatingGroupCountMismatch const& e)
  {
    raisePythonException<FIX::RepeatingGroupCountMismatch>(e, SWIGTYPE_p_FIX__RepeatingGroupCountMismatch); return false;
  }
  catch(FIX::DoNotSend const& e)
  {
    raisePythonException<FIX::DoNotSend>(e, SWIGTYPE_p_FIX__DoNotSend); return false;
  }
  catch(FIX::RejectLogon const& e)
  {
    raisePythonException<FIX::RejectLogon>(e, SWIGTYPE_p_FIX__RejectLogon); return false;
  }
  catch(FIX::SessionNotFound const& e)
  {
    raisePythonException<FIX::SessionNotFound>(e, SWIGTYPE_p_FIX__SessionNotFound); return false;
  }
  catch(FIX::IOException const& e)
  {
    raisePythonException<FIX::IOException>(e, SWIGTYPE_p_FIX__IOException); return false;
  }
  catch(FIX::SocketSendFailed const& e)
  {
    raisePythonException<FIX::SocketSendFailed>(e, SWIGTYPE_p_FIX__SocketSendFailed); return false;
  }
  catch(FIX::SocketRecvFailed const& e)
  {
    raisePythonException<FIX::SocketRecvFailed>(e, SWIGTYPE_p_FIX__SocketRecvFailed); return false;
  }
  catch(FIX::SocketCloseFailed const& e)
  {
    raisePythonException<FIX::SocketCloseFailed>(e, SWIGTYPE_p_FIX__SocketCloseFailed); return false;
  }
  catch(FIX::SocketException const& e)
  {
    raisePythonException<FIX::SocketException>(e, SWIGTYPE_p_FIX__SocketException); return false;
  }
  catch(FIX::Exception const& e)
  {
    raisePythonException<FIX::Exception>(e, SWIGTYPE_p_FIX__Exception); return false;
  }
  catch(std::exception const& e) 
  {
    SWIG_Error(SWIG_RuntimeError, e.what()); return false;
  }
  catch(...)
  {
    SWIG_Error(SWIG_RuntimeError, "unknown exception"); return false;
  }
}
#endif

#ifdef SWIGRUBY
template<typename Exception>
void raiseRubyException(Exception const& e, swig_type_info* swigType)
{
  rb_exc_raise(SWIG_Ruby_ExceptionType(swigType, SWIG_NewPointerObj((new Exception(static_cast<const Exception&>(e))),swigType,SWIG_POINTER_OWN)));
}

VALUE tryRubyException(std::function<VALUE()> const& function)
{
  try
  {
    return function();
  }
  catch(FIX::DataDictionaryNotFound const& e)
  {
    raiseRubyException<FIX::DataDictionaryNotFound>(e, SWIGTYPE_p_FIX__DataDictionaryNotFound); return Qnil;
  }
  catch(FIX::FieldNotFound const& e)
  {
    raiseRubyException<FIX::FieldNotFound>(e, SWIGTYPE_p_FIX__FieldNotFound); return Qnil;
  }
  catch(FIX::FieldConvertError const& e)
  {
    raiseRubyException<FIX::FieldConvertError>(e, SWIGTYPE_p_FIX__FieldConvertError); return Qnil;
  }
  catch(FIX::MessageParseError const& e)
  {
    raiseRubyException<FIX::MessageParseError>(e, SWIGTYPE_p_FIX__MessageParseError); return Qnil;
  }
  catch(FIX::InvalidMessage const& e)
  {
    raiseRubyException<FIX::InvalidMessage>(e, SWIGTYPE_p_FIX__InvalidMessage); return Qnil;
  }
  catch(FIX::ConfigError const& e)
  {
    raiseRubyException<FIX::ConfigError>(e, SWIGTYPE_p_FIX__ConfigError); return Qnil;
  }
  catch(FIX::RuntimeError const& e)
  {
    raiseRubyException<FIX::RuntimeError>(e, SWIGTYPE_p_FIX__RuntimeError); return Qnil;
  }
  catch(FIX::InvalidTagNumber const& e)
  {
    raiseRubyException<FIX::InvalidTagNumber>(e, SWIGTYPE_p_FIX__InvalidTagNumber); return Qnil;
  }
  catch(FIX::RequiredTagMissing const& e)
  {
    raiseRubyException<FIX::RequiredTagMissing>(e, SWIGTYPE_p_FIX__RequiredTagMissing); return Qnil;
  }
  catch(FIX::TagNotDefinedForMessage const& e)
  {
    raiseRubyException<FIX::TagNotDefinedForMessage>(e, SWIGTYPE_p_FIX__TagNotDefinedForMessage); return Qnil;
  }
  catch(FIX::NoTagValue const& e)
  {
    raiseRubyException<FIX::NoTagValue>(e, SWIGTYPE_p_FIX__NoTagValue); return Qnil;
  }
  catch(FIX::IncorrectTagValue const& e)
  {
    raiseRubyException<FIX::IncorrectTagValue>(e, SWIGTYPE_p_FIX__IncorrectTagValue); return Qnil;
  }
  catch(FIX::IncorrectDataFormat const& e)
  {
    raiseRubyException<FIX::IncorrectDataFormat>(e, SWIGTYPE_p_FIX__IncorrectDataFormat); return Qnil;
  }
  catch(FIX::IncorrectMessageStructure const& e)
  {
    raiseRubyException<FIX::IncorrectMessageStructure>(e, SWIGTYPE_p_FIX__IncorrectMessageStructure); return Qnil;
  }
  catch(FIX::DuplicateFieldNumber const& e)
  {
    raiseRubyException<FIX::DuplicateFieldNumber>(e, SWIGTYPE_p_FIX__DuplicateFieldNumber); return Qnil;
  }
  catch(FIX::InvalidMessageType const& e)
  {
    raiseRubyException<FIX::InvalidMessageType>(e, SWIGTYPE_p_FIX__InvalidMessageType); return Qnil;
  }
  catch(FIX::UnsupportedMessageType const& e)
  {
    raiseRubyException<FIX::UnsupportedMessageType>(e, SWIGTYPE_p_FIX__UnsupportedMessageType); return Qnil;
  }
  catch(FIX::UnsupportedVersion const& e)
  {
    raiseRubyException<FIX::UnsupportedVersion>(e, SWIGTYPE_p_FIX__UnsupportedVersion); return Qnil;
  }
  catch(FIX::TagOutOfOrder const& e)
  {
    raiseRubyException<FIX::TagOutOfOrder>(e, SWIGTYPE_p_FIX__TagOutOfOrder); return Qnil;
  }
  catch(FIX::RepeatedTag const& e)
  {
    raiseRubyException<FIX::RepeatedTag>(e, SWIGTYPE_p_FIX__RepeatedTag); return Qnil;
  }
  catch(FIX::RepeatingGroupCountMismatch const& e)
  {
    raiseRubyException<FIX::RepeatingGroupCountMismatch>(e, SWIGTYPE_p_FIX__RepeatingGroupCountMismatch); return Qnil;
  }
  catch(FIX::DoNotSend const& e)
  {
    raiseRubyException<FIX::DoNotSend>(e, SWIGTYPE_p_FIX__DoNotSend); return Qnil;
  }
  catch(FIX::RejectLogon const& e)
  {
    raiseRubyException<FIX::RejectLogon>(e, SWIGTYPE_p_FIX__RejectLogon); return Qnil;
  }
  catch(FIX::SessionNotFound const& e)
  {
    raiseRubyException<FIX::SessionNotFound>(e, SWIGTYPE_p_FIX__SessionNotFound); return Qnil;
  }
  catch(FIX::IOException const& e)
  {
    raiseRubyException<FIX::IOException>(e, SWIGTYPE_p_FIX__IOException); return Qnil;
  }
  catch(FIX::SocketSendFailed const& e)
  {
    raiseRubyException<FIX::SocketSendFailed>(e, SWIGTYPE_p_FIX__SocketSendFailed); return Qnil;
  }
  catch(FIX::SocketRecvFailed const& e)
  {
    raiseRubyException<FIX::SocketRecvFailed>(e, SWIGTYPE_p_FIX__SocketRecvFailed); return Qnil;
  }
  catch(FIX::SocketCloseFailed const& e)
  {
    raiseRubyException<FIX::SocketCloseFailed>(e, SWIGTYPE_p_FIX__SocketCloseFailed); return Qnil;
  }
  catch(FIX::SocketException const& e)
  {
    raiseRubyException<FIX::SocketException>(e, SWIGTYPE_p_FIX__SocketException); return Qnil;
  }
  catch(FIX::Exception const& e)
  {
    raiseRubyException<FIX::Exception>(e, SWIGTYPE_p_FIX__Exception); return Qnil;
  }
  catch(std::exception const& e) 
  {
    SWIG_Error(SWIG_RuntimeError, e.what()); return Qnil;
  }
  catch(...)
  {
    SWIG_Error(SWIG_RuntimeError, "unknown exception"); return Qnil;
  }
}
#endif
         
typedef FIX::UtcTimeStamp UtcTimeStamp;
typedef FIX::UtcDate UtcDate;
typedef FIX::UtcTimeOnly UtcTimeOnly;
typedef FIX::message_order message_order;
typedef FIX::Group Group;
typedef FIX::DataDictionary DataDictionary;
typedef FIX::DataDictionaryProvider DataDictionaryProvider;
typedef FIX::MsgType MsgType;
typedef FIX::BeginString BeginString;
typedef FIX::ApplVerID ApplVerID;
typedef FIX::SessionID SessionID;
typedef FIX::Session Session;
typedef FIX::Application Application;
typedef FIX::DateTime DateTime;
typedef FIX::TimeRange TimeRange;
typedef FIX::Responder Responder;
typedef FIX::Log Log;
typedef FIX::LogFactory LogFactory;
typedef FIX::MessageStore MessageStore;
typedef FIX::MessageStoreFactory MessageStoreFactory;
typedef FIX::Mutex Mutex;
typedef FIX::DOMDocumentPtr DOMDocumentPtr;
typedef FIX::SessionSettings SessionSettings;


namespace swig {
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  /*
    Partial specialization for pointers (traits_info)
  */
  template <class Type> struct traits_info<Type *> {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers (traits)
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category>
  struct traits_as { };

  template <class Type, class Category>
  struct traits_check { };

}


namespace swig {
  template <class Type> struct traits_asptr;
  template <class Type> struct traits_asval;
  struct pointer_category;
  template <class Type, class Category> struct traits_as;
  template <class Type> struct traits_from;
  template <class Type> struct traits_from_ptr;
  template <class Type> struct noconst_traits;
  template <class Type> swig_type_info* type_info();
  template <class Type> const char* type_name();
  template <class Type> VALUE from(const Type& val);
}



namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static VALUE from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static VALUE from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static VALUE from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static VALUE from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline VALUE from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline VALUE from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(VALUE obj, Type **val) {
      Type *p = 0;
      swig_type_info *descriptor = type_info<Type>();
      int res = descriptor ? SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0) : SWIG_ERROR;
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(VALUE obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(VALUE obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(VALUE obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(VALUE obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(VALUE obj) {
      Type v;
      int res = asval(obj, &v);
      if (!SWIG_IsOK(res)) {
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
        throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(VALUE obj) {
      Type *v = 0;      
      int res = traits_asptr<Type>::asptr(obj, &v);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
        throw std::invalid_argument("bad type");
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(VALUE obj) {
      Type *v = 0;      
      int res = traits_asptr<Type>::asptr(obj, &v);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
        throw std::invalid_argument("bad type");
      }
    }
  };

  template <class Type>
  inline Type as(VALUE obj) {
    return traits_as< Type, typename traits< Type >::category >::as(obj);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(VALUE obj) {
      int res = asval(obj, (Type *)(0));
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(VALUE obj) {
      int res = asptr(obj, (Type **)(0));
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(VALUE obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


  namespace swig {
    template <>  struct traits< FIX::SessionID > {
      typedef pointer_category category;
      static const char* type_name() { return"FIX::SessionID"; }
    };
  }


#include <functional>


namespace swig {
  template < class T >
  struct yield
  {
    bool
    operator()( const T& v ) const
    { 
      return RTEST( rb_yield( swig::from< T >(v) ) );
    }
  };


  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence>
  inline void
  resize(Sequence *seq, typename Sequence::size_type n, typename Sequence::value_type x) {
    seq->resize(n, x);
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, (i == size && j == size));
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {

  /** 
   * Templated base classes for all custom const_iterators.
   *
   */
  template<typename OutConstIterator>
  class ConstIterator_T :  public ConstIterator
  {
  public:
    typedef OutConstIterator const_iter;
    typedef typename std::iterator_traits<const_iter>::value_type value_type;    
    typedef ConstIterator_T<const_iter> self_type;

  protected:

    
    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:
    ConstIterator_T() : ConstIterator(Qnil)
    {
    }

    ConstIterator_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator(seq), current(curr)
    {
    }

    const const_iter& get_current() const
    {
      return current;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    const_iter current;
  };


  /** 
   * Templated base classes for all custom non-const iterators.
   *
   */
  template<typename InOutIterator>
  class Iterator_T :  public Iterator
  {
  public:
    typedef InOutIterator nonconst_iter;

    // Make this class iterator STL compatible, by using iterator_traits
    typedef typename std::iterator_traits<nonconst_iter >::iterator_category iterator_category;
    typedef typename std::iterator_traits<nonconst_iter >::value_type        value_type;
    typedef typename std::iterator_traits<nonconst_iter >::difference_type   difference_type;
    typedef typename std::iterator_traits<nonconst_iter >::pointer           pointer;
    typedef typename std::iterator_traits<nonconst_iter >::reference         reference;

    typedef Iterator                         base;
    typedef Iterator_T< nonconst_iter > self_type;

  protected:

    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:

    Iterator_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator(seq), current(curr)
    {
    }

    const nonconst_iter& get_current() const
    {
      return current;
    }

    self_type& operator=( const self_type& b )
    {
      base::operator=( b );
      return *this;
    }
    
    self_type& operator=( const value_type& b )
    {
      *current = b;
      return *this;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    value_type& operator*()
    {
      return *current;
    }
    
    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    nonconst_iter current;
  };


  /**
   * Auxiliary functor to store the value of a ruby object inside
   * a reference of a compatible C++ type.  ie: Ruby -> C++
   * 
   */
  template <class ValueType>
  struct asval_oper 
  {
    typedef ValueType    value_type;
    typedef bool        result_type;
    bool operator()(VALUE obj, value_type& v) const
    {
      return ( swig::asval< value_type >(obj, &v) == SWIG_OK );
    }
  };

  /**
   * Auxiliary functor to return a ruby object from a C++ type. 
   * ie: C++ -> Ruby
   * 
   */
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef VALUE result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };


  /** 
   * ConstIterator class for a const_iterator with no end() boundaries.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorOpen_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;
    typedef ConstIteratorOpen_T<OutConstIterator, ValueType, FromOper> self_type;
    
    ConstIteratorOpen_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * Iterator class for an iterator with no end() boundaries.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorOpen_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper  from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;

  public:
    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }

    virtual VALUE setValue( const VALUE& v )
    {
      value_type& dst = *base::current;
      if ( asval(v, dst) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * ConstIterator class for a const_iterator where begin() and end() boundaries are known.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorClosed_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;    
    typedef ConstIteratorClosed_T<OutConstIterator, ValueType, FromOper> self_type;
    
  protected:
    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    ConstIteratorClosed_T(const_iter curr, const_iter first, 
			  const_iter last, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }


  private:
    const_iter begin;
    const_iter end;
  };

  /** 
   * Iterator class for a iterator where begin() and end() boundaries are known.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorClosed_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    // Iterator setter method, required by Ruby
    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      value_type& dst = *base::current;
      if ( asval( v, dst ) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorOpen_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, bool, FromOper, AsvalOper> self_type;

    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }

    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    virtual VALUE setValue( const VALUE& v )
    {
      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }    
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
    
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorClosed_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, bool, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }

    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }

    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };


  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, const InOutIter& begin,
			 const InOutIter& end, VALUE seq = Qnil)
  {
    return new IteratorClosed_T<InOutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, VALUE seq = Qnil)
  {
    return new IteratorOpen_T<InOutIter>(current, seq);
  }

  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, const OutIter& begin,
                       const OutIter& end, VALUE seq = Qnil)
  {
    return new ConstIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, VALUE seq = Qnil)
  {
    return new ConstIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{

  /**
   * This class is a proxy class for references, used to return and set values
   * of an element of a Ruby Array of stuff.
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   */
  template <class T>
  struct RubySequence_Ref
  {
    RubySequence_Ref(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      VALUE item = rb_ary_entry(_seq, _index );
      try {
	return swig::as<T>(item);
      } catch (const std::invalid_argument& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	VALUE lastErr = rb_gv_get("$!");
	if ( lastErr == Qnil ) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	VALUE str = rb_str_new2(msg);
	str = rb_str_cat2( str, e.what() );
	SWIG_Ruby_ExceptionType( NULL, str );
	throw;
      }
    }

    RubySequence_Ref& operator=(const T& v)
    {
      rb_ary_set(_seq, _index, swig::from< T >(v));
      return *this;
    }

  private:
    VALUE  _seq;
    int _index;
  };


  /**
   * This class is a proxy to return a pointer to a class, usually
   * RubySequence_Ref. 
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   */
  template <class T>
  struct RubySequence_ArrowProxy
  {
    RubySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };


  /**
   * Input Iterator.  This adapator class is a random access iterator that 
   * allows you to use STL algorithms with a Ruby class (a Ruby Array by default).
   */
  template <class T, class Reference = RubySequence_Ref< T > >
  struct RubySequence_InputIterator
  {
    typedef RubySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef ptrdiff_t difference_type;

    RubySequence_InputIterator()
    {
    }

    RubySequence_InputIterator(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    RubySequence_ArrowProxy<T>
    operator->() const {
      return RubySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    VALUE  _seq;
    difference_type _index;
  };


  /**
   * This adaptor class allows you to use a Ruby Array as if it was an STL
   * container, giving it begin(), end(), and iterators.
   */
  template <class T>
  struct RubySequence_Cont
  {
    typedef RubySequence_Ref<T> reference;
    typedef const RubySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef RubySequence_InputIterator<T, reference> iterator;
    typedef RubySequence_InputIterator<T, const_reference> const_iterator;

    RubySequence_Cont(VALUE  seq) : _seq(0)
    {
      if (!rb_obj_is_kind_of(seq, rb_cArray)) {
	throw std::invalid_argument("an Array is expected");
      }
      _seq = seq;
    }

    ~RubySequence_Cont()
    {
    }

    size_type size() const
    {
      return RARRAY_LEN(_seq);
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check() const
    {
      int s = (int) size();
      for (int i = 0; i < s; ++i) {
	VALUE item = rb_ary_entry(_seq, i );
	if (!swig::check<value_type>(item))
	  return false;
      }
      return true;
    }

  private:
    VALUE  _seq;
  };

}


namespace swig {
  template <class RubySeq, class Seq>
  inline void
  assign(const RubySeq& rubyseq, Seq* seq) {
    // seq->assign(rubyseq.begin(), rubyseq.end()); // not used as not always implemented
    typedef typename RubySeq::value_type value_type;
    typename RubySeq::const_iterator it = rubyseq.begin();
    for (;it != rubyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  RubySequence_Cont<value_type> rubyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return rubyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (const std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, "%s", e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	swig_type_info *descriptor = swig::type_info<sequence>();
	if (descriptor && SWIG_IsOK(SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0))) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  // Partial specialization for GC_VALUE's.  No need to typecheck each
  // element.
  template< class Seq >
  struct traits_asptr_stdseq< Seq, swig::GC_VALUE > {
    typedef Seq sequence;
    typedef swig::GC_VALUE value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  if (seq) {
	    RubySequence_Cont<value_type> rubyseq(obj);
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return true;
	  }
	} catch (const std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, "%s", e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	swig_type_info *descriptor = swig::type_info<sequence>();
	if (descriptor && SWIG_IsOK(SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0))) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static VALUE from(const sequence& seq) {






      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	VALUE obj = rb_ary_new2((int)size);
	int i = 0;
	for (const_iterator it = seq.begin();
	     it != seq.end(); ++it, ++i) {
	  rb_ary_push(obj, swig::from< value_type >(*it));
	}
	rb_obj_freeze(obj);  // treat as immutable result
	return obj;
      } else {
	rb_raise(rb_eRangeError,"sequence size not valid in ruby");
	return Qnil;
      }
    }
  };
}


  namespace swig {
    template <class RubySeq, class T> 
    inline void 
    assign(const RubySeq& rubyseq, std::set<T>* seq) {
      // seq->insert(rubyseq.begin(), rubyseq.end()); // not used as not always implemented
      typedef typename RubySeq::value_type value_type;
      typename RubySeq::const_iterator it = rubyseq.begin();
      for (;it != rubyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
    }

    template <class T>
    struct traits_asptr<std::set<T> >  {
      static int asptr(VALUE obj, std::set<T> **s) {  
	return traits_asptr_stdseq<std::set<T> >::asptr(obj, s);
      }
    };

    template <class T>
    struct traits_from<std::set<T> > {
      static VALUE from(const std::set<T>& vec) {
	return traits_from_stdseq<std::set<T> >::from(vec);
      }
    };


    /** 
     * Set Iterator class for an iterator with no end() boundaries.
     *
     */
    template<typename InOutIterator, 
	     typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	     typename FromOper = from_oper<ValueType>,
	     typename AsvalOper = asval_oper<ValueType> >
      class SetIteratorOpen_T :  public Iterator_T<InOutIterator>
    {
    public:
      FromOper  from;
      AsvalOper asval;
      typedef InOutIterator nonconst_iter;
      typedef ValueType value_type;
      typedef Iterator_T<nonconst_iter>  base;
      typedef SetIteratorOpen_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;

    public:
      SetIteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
	: Iterator_T<InOutIterator>(curr, seq)
      {
      }
    
      virtual VALUE value() const {
	return from(static_cast<const value_type&>(*(base::current)));
      }

      // no setValue allowed
    
      Iterator *dup() const
      {
	return new self_type(*this);
      }
    };


    /** 
     * Set Iterator class for a iterator where begin() and end() boundaries
       are known.
     *
     */
    template<typename InOutIterator, 
	     typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	     typename FromOper = from_oper<ValueType>,
	     typename AsvalOper = asval_oper<ValueType> >
    class SetIteratorClosed_T :  public Iterator_T<InOutIterator>
    {
    public:
      FromOper   from;
      AsvalOper asval;
      typedef InOutIterator nonconst_iter;
      typedef ValueType value_type;
      typedef Iterator_T<nonconst_iter>  base;
      typedef SetIteratorClosed_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;
    
    protected:
      virtual Iterator* advance(ptrdiff_t n)
      {
	std::advance( base::current, n );
	if ( base::current == end )
	  throw stop_iteration();
	return this;
      }

    public:
      SetIteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		       nonconst_iter last, VALUE seq = Qnil)
	: Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
      {
      }
    
      virtual VALUE value() const {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  return from(static_cast<const value_type&>(*(base::current)));
	}
      }

      // no setValue allowed
    
    
      Iterator *dup() const
      {
	return new self_type(*this);
      }

    private:
      nonconst_iter begin;
      nonconst_iter end;
    };

    // Template specialization to construct a closed iterator for sets
    // this turns a nonconst iterator into a const one for ruby to avoid
    // allowing the user to change the value
    template< typename InOutIter >
    inline Iterator*
    make_set_nonconst_iterator(const InOutIter& current, 
			       const InOutIter& begin,
			       const InOutIter& end, 
			       VALUE seq = Qnil)
    {
      return new SetIteratorClosed_T< InOutIter >(current, 
						  begin, end, seq);
    }

    // Template specialization to construct an open iterator for sets
    // this turns a nonconst iterator into a const one for ruby to avoid
    // allowing the user to change the value
    template< typename InOutIter >
    inline Iterator*
    make_set_nonconst_iterator(const InOutIter& current, 
			       VALUE seq = Qnil)
    {
      return new SetIteratorOpen_T< InOutIter >(current, seq);
    }

  }


      namespace swig {
	template <>  struct traits<std::set< FIX::SessionID, std::less< FIX::SessionID >, std::allocator< FIX::SessionID > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::set<" "FIX::SessionID" "," "std::less< FIX::SessionID >" "," "std::allocator< FIX::SessionID >" " >";
	  }
	};
      }
    
SWIGINTERN std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *std_set_Sl_FIX_SessionID_Sg__dup(std::set< FIX::SessionID > *self){
      return new std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >(*self);
    }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg__inspect(std::set< FIX::SessionID > *self){
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator i = self->begin();
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > >();
      VALUE str = rb_str_new2(type_name);
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg__to_a(std::set< FIX::SessionID > *self){
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator i = self->begin();
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg__to_s(std::set< FIX::SessionID > *self){
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::iterator i = self->begin();
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg__slice(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::difference_type i,std::set< FIX::SessionID >::difference_type length){
      if ( length < 0 )
        return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) {
        if ( i + static_cast<std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::difference_type>(len) < 0 )
          return Qnil;
        else
          i = len + i;
      }
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::difference_type j = length + i;
      if ( j > static_cast<std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::difference_type>(len) )
        j = len;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >* >( swig::getslice(self, i, j) );
      }
      catch( const std::out_of_range& ) {
      }
      return r;
    }
SWIGINTERN std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *std_set_Sl_FIX_SessionID_Sg__each(std::set< FIX::SessionID > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator i = self->begin();
	std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg____delete2__(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *std_set_Sl_FIX_SessionID_Sg__select(std::set< FIX::SessionID > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >* r = new std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >();
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator i = self->begin();
      std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_set_Sl_FIX_SessionID_Sg__delete_at(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::difference_type i){
      VALUE r = Qnil;
      try {
	std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (const std::out_of_range&) {
      }
      return r;
    }
SWIGINTERN std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *std_set_Sl_FIX_SessionID_Sg__reject_bang(std::set< FIX::SessionID > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      for ( std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::iterator i = self->begin(); i != self->end(); ) {
        VALUE r = swig::from< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::value_type >(*i);
        std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >::iterator current = i++;
        if ( RTEST( rb_yield(r) ) )
          self->erase(current);
      }

      return self;
    }
SWIGINTERN std::set< FIX::SessionID >::value_type std_set_Sl_FIX_SessionID_Sg__push(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::value_type const &x){
      self->insert(x);
      return x;
    }
SWIGINTERN bool std_set_Sl_FIX_SessionID_Sg____contains__(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::value_type const &x){
      return self->find(x) != self->end();
    }
SWIGINTERN std::set< FIX::SessionID >::value_type std_set_Sl_FIX_SessionID_Sg____getitem__(std::set< FIX::SessionID > const *self,std::set< FIX::SessionID >::difference_type i){
      return *(swig::cgetpos(self, i));
    }

SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE VALUE 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return ULL2NUM(value);
}
#endif


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}

SWIGINTERN void std_set_Sl_FIX_SessionID_Sg__erase__SWIG_1(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::iterator pos){ self->erase(pos); }
SWIGINTERN void std_set_Sl_FIX_SessionID_Sg__erase__SWIG_2(std::set< FIX::SessionID > *self,std::set< FIX::SessionID >::iterator first,std::set< FIX::SessionID >::iterator last){ self->erase(first, last); }


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    char *cstr = StringValuePtr(obj); 
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy(new char[size], cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}

SWIGINTERN std::string FIX_Exception___str__(FIX::Exception *self){
    return self->what();
  }

SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}




SWIGINTERN std::string FIX_FieldBase___str__(FIX::FieldBase *self){
    return self->getFixString();
  }

SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


/*@SWIG:/usr/local/share/swig/4.1.1/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE arg)
{
  VALUE *args = (VALUE *)arg;
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = NUM2DBL(obj); (void)type;
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(VALUEFUNC(SWIG_AUX_NUM2DBL), (VALUE)a, VALUEFUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


  #define SWIG_From_double   rb_float_new 


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


#include <memory>


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}

SWIGINTERN std::string FIX_Message___str__(FIX::Message *self){
    return self->toString();
  }

SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN std::string FIX_SessionID___str__(FIX::SessionID *self){
    return self->toString();
  }
SWIGINTERN void FIX_SessionSettings_setFromString(FIX::SessionSettings *self,std::string const &str){
        std::stringstream(str) >> (*self);
    }

SWIGINTERN int
SWIG_AsVal_short (VALUE obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}

/* ---------------------------------------------------
 * C++ director class helpers
 * --------------------------------------------------- */

static int Application_onCreate_call_depth = 0;
VALUE Application_onCreate_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onCreate_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onCreate_call_depth--;
  return result;
}

VALUE Application_onCreate_rescue(VALUE args, VALUE error) {
  Application_onCreate_call_depth--;
  if (Application_onCreate_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING_PTR(message) );
      exit(1);
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_onLogon_call_depth = 0;
VALUE Application_onLogon_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onLogon_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onLogon_call_depth--;
  return result;
}

VALUE Application_onLogon_rescue(VALUE args, VALUE error) {
  Application_onLogon_call_depth--;
  if (Application_onLogon_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING_PTR(message) );
      exit(1);
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_onLogout_call_depth = 0;
VALUE Application_onLogout_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onLogout_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onLogout_call_depth--;
  return result;
}

VALUE Application_onLogout_rescue(VALUE args, VALUE error) {
  Application_onLogout_call_depth--;
  if (Application_onLogout_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING_PTR(message) );
      exit(1);
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_toAdmin_call_depth = 0;
VALUE Application_toAdmin_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_toAdmin_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_toAdmin_call_depth--;
  return result;
}

VALUE Application_toAdmin_rescue(VALUE args, VALUE error) {
  Application_toAdmin_call_depth--;
  if (Application_toAdmin_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING_PTR(message) );
      exit(1);
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_toApp_call_depth = 0;
VALUE Application_toApp_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_toApp_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_toApp_call_depth--;
  return result;
}

VALUE Application_toApp_rescue(VALUE args, VALUE error) {
  Application_toApp_call_depth--;
  if (Application_toApp_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_toApp_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__DoNotSend, 0 ) != -1 ) {
        throw *((FIX::DoNotSend*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING_PTR(message) );
        exit(1);
      }
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_fromAdmin_call_depth = 0;
VALUE Application_fromAdmin_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_fromAdmin_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_fromAdmin_call_depth--;
  return result;
}

VALUE Application_fromAdmin_rescue(VALUE args, VALUE error) {
  Application_fromAdmin_call_depth--;
  if (Application_fromAdmin_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_fromAdmin_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__FieldNotFound, 0 ) != -1 ) {
        throw *((FIX::FieldNotFound*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectDataFormat, 0 ) != -1 ) {
        throw *((FIX::IncorrectDataFormat*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectTagValue, 0 ) != -1 ) {
        throw *((FIX::IncorrectTagValue*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__RejectLogon, 0 ) != -1 ) {
        throw *((FIX::RejectLogon*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING_PTR(message) );
        exit(1);
      }
    }
  }
  rb_exc_raise(error);
  return Qnil;
}

static int Application_fromApp_call_depth = 0;
VALUE Application_fromApp_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_fromApp_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_fromApp_call_depth--;
  return result;
}

VALUE Application_fromApp_rescue(VALUE args, VALUE error) {
  Application_fromApp_call_depth--;
  if (Application_fromApp_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_fromApp_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__FieldNotFound, 0 ) != -1 ) {
        throw *((FIX::FieldNotFound*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectDataFormat, 0 ) != -1 ) {
        throw *((FIX::IncorrectDataFormat*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectTagValue, 0 ) != -1 ) {
        throw *((FIX::IncorrectTagValue*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__UnsupportedMessageType, 0 ) != -1 ) {
        throw *((FIX::UnsupportedMessageType*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING_PTR(message) );
        exit(1);
      }
    }
  }
  rb_exc_raise(error);
  return Qnil;
}



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "QuickfixRuby.h"

SwigDirector_Application::SwigDirector_Application(VALUE self): FIX::Application(), Swig::Director(self) {
  
}



SwigDirector_Application::~SwigDirector_Application() {
}

void SwigDirector_Application::onCreate(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onCreate");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onCreate_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onCreate_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::onLogon(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onLogon");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onLogon_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onLogon_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::onLogout(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onLogout");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onLogout_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onLogout_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::toAdmin(FIX::Message &arg0,FIX::SessionID const &arg1) {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("toAdmin");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_toAdmin_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_toAdmin_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::toApp(FIX::Message &arg0,FIX::SessionID const &arg1) noexcept {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("toApp");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_toApp_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_toApp_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::fromAdmin(FIX::Message const &arg0,FIX::SessionID const &arg1) noexcept {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("fromAdmin");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_fromAdmin_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_fromAdmin_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::fromApp(FIX::Message const &arg0,FIX::SessionID const &arg1) noexcept {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE SWIGUNUSED result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("fromApp");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_fromApp_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_fromApp_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


static swig_class SwigClassGC_VALUE;

/*
  Document-method: Quickfix::GC_VALUE.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_inspect(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  swig::GC_VALUE r1 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  r1 = self; arg1 = &r1;
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::GC_VALUE const *)arg1)->inspect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::GC_VALUE.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_to_s(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  swig::GC_VALUE r1 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  r1 = self; arg1 = &r1;
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::GC_VALUE const *)arg1)->to_s();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassConstIterator;

SWIGINTERN void
free_swig_ConstIterator(void *self) {
    swig::ConstIterator *arg1 = (swig::ConstIterator *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","value", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (VALUE)((swig::ConstIterator const *)arg1)->value();
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.dup

  call-seq:
    dup -> ConstIterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->dup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::ConstIterator const *)arg1)->inspect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::ConstIterator const *)arg1)->to_s();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::ConstIterator *)(arg1)->next(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::ConstIterator *)(arg1)->next();
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.next", 
    "    swig::ConstIterator ConstIterator.next(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::ConstIterator *)(arg1)->previous(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::ConstIterator *)(arg1)->previous();
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.previous", 
    "    swig::ConstIterator ConstIterator.previous(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.previous()\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((swig::ConstIterator const *)arg1)->operator ==((swig::ConstIterator const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.+

  call-seq:
    +(n) -> ConstIterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator +(arg2);
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::ConstIterator.-

  call-seq:
    -(n) -> ConstIterator
    -(x) -> ptrdiff_t

Subtraction operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator -(arg2);
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((swig::ConstIterator const *)arg1)->operator -((swig::ConstIterator const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.__sub__", 
    "    swig::ConstIterator ConstIterator.__sub__(ptrdiff_t n)\n"
    "    ptrdiff_t ConstIterator.__sub__(swig::ConstIterator const &x)\n");
  
  return Qnil;
}


static swig_class SwigClassIterator;

SWIGINTERN VALUE
_wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  VALUE *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE temp2 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  temp2 = static_cast< VALUE >(argv[0]);
  arg2 = &temp2;
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)(arg1)->setValue((VALUE const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.dup

  call-seq:
    dup -> Iterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::Iterator *)((swig::Iterator const *)arg1)->dup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::Iterator *)(arg1)->next(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::Iterator *)(arg1)->next();
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.next", 
    "    swig::Iterator Iterator.next(size_t n)\n"
    "    swig::Iterator * Iterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (swig::Iterator *)(arg1)->previous(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::Iterator *)(arg1)->previous();
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.previous", 
    "    swig::Iterator Iterator.previous(size_t n)\n"
    "    swig::Iterator * Iterator.previous()\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_Iterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::Iterator const *)arg1)->inspect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_Iterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)((swig::Iterator const *)arg1)->to_s();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((swig::Iterator const *)arg1)->operator ==((swig::Iterator const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.+

  call-seq:
    +(n) -> Iterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator +(arg2);
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Iterator.-

  call-seq:
    -(n) -> Iterator
    -(x) -> ptrdiff_t

Subtraction operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator -(arg2);
      } catch(swig::stop_iteration &_e) {
        {
          (void)_e;
              SWIG_Ruby_ExceptionType(NULL, Qnil);
              SWIG_fail;
            }
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((swig::Iterator const *)arg1)->operator -((swig::Iterator const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__Iterator, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Iterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.__sub__", 
    "    swig::Iterator Iterator.__sub__(ptrdiff_t n)\n"
    "    ptrdiff_t Iterator.__sub__(swig::Iterator const &x)\n");
  
  return Qnil;
}


SWIGINTERN void
free_swig_Iterator(void *self) {
    swig::Iterator *arg1 = (swig::Iterator *)self;
    delete arg1;
}

static swig_class SwigClassIntArray;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IntArray_allocate(VALUE self)
#else
_wrap_IntArray_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IntArray);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IntArray(int argc, VALUE *argv, VALUE self) {
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntArray";
  IntArray *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "size_t","IntArray", 1, argv[0] ));
  } 
  arg1 = static_cast< size_t >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (IntArray *)new_IntArray(SWIG_STD_MOVE(arg1));
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void delete_IntArray(IntArray *self){
    delete[] self;
  }
SWIGINTERN void
free_IntArray(void *self) {
    IntArray *arg1 = (IntArray *)self;
    delete_IntArray(arg1);
}

/*
  Document-method: Quickfix::IntArray.[]

  call-seq:
    [](index) -> int

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_IntArray___getitem__(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)IntArray___getitem__(arg1,SWIG_STD_MOVE(arg2));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::IntArray.[]=

  call-seq:
    []=(index, value)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_IntArray___setitem__(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  size_t arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      IntArray___setitem__(arg1,SWIG_STD_MOVE(arg2),arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntArray_cast(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","cast", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int *)IntArray_cast(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntArray_frompointer(int argc, VALUE *argv, VALUE self) {
  int *arg1 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IntArray *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "int *","IntArray_frompointer", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< int * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (IntArray *)IntArray_frompointer(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IntArray, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassSessionIDSet;

SWIGINTERN VALUE
_wrap_new_SessionIDSet__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< FIX::SessionID > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionIDSet";
  std::set< FIX::SessionID > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_FIX__SessionID_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< FIX::SessionID > const &","set<(FIX::SessionID)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< FIX::SessionID > const &","set<(FIX::SessionID)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID > *)new std::set< FIX::SessionID >((std::less< FIX::SessionID > const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.dup

  call-seq:
    dup -> SessionIDSet

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_dup(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *)std_set_Sl_FIX_SessionID_Sg__dup(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_inspect(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)std_set_Sl_FIX_SessionID_Sg__inspect(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.to_a

  call-seq:
    to_a -> VALUE

Convert SessionIDSet to an Array.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_to_a(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)std_set_Sl_FIX_SessionID_Sg__to_a(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_to_s(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)std_set_Sl_FIX_SessionID_Sg__to_s(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.slice

  call-seq:
    slice(i, length) -> VALUE

Return a slice (portion of) the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_slice(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::difference_type arg2 ;
  std::set< FIX::SessionID >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","slice", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::difference_type","slice", 2, argv[0] ));
  } 
  arg2 = static_cast< std::set< FIX::SessionID >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::difference_type","slice", 3, argv[1] ));
  } 
  arg3 = static_cast< std::set< FIX::SessionID >::difference_type >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = (VALUE)std_set_Sl_FIX_SessionID_Sg__slice(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch(std::invalid_argument &_e) {
        SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.each

  call-seq:
    each -> SessionIDSet

Iterate thru each element in the SessionIDSet.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_each(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *)std_set_Sl_FIX_SessionID_Sg__each(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet___delete2__(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","__delete2__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::value_type const &","__delete2__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::value_type const &","__delete2__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::value_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)std_set_Sl_FIX_SessionID_Sg____delete2__(arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.select

  call-seq:
    select -> SessionIDSet

Iterate thru each element in the SessionIDSet and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_select(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *)std_set_Sl_FIX_SessionID_Sg__select(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_delete_at(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","delete_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::difference_type","delete_at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::set< FIX::SessionID >::difference_type >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (VALUE)std_set_Sl_FIX_SessionID_Sg__delete_at(arg1,SWIG_STD_MOVE(arg2));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.reject!

  call-seq:
    reject! -> SessionIDSet

Iterate thru each element in the SessionIDSet and reject those that fail a condition.  A block must be provided.  SessionIDSet is modified in place.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_rejectN___(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","reject_bang", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *)std_set_Sl_FIX_SessionID_Sg__reject_bang(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.push

  call-seq:
    push(x) -> SessionID

Add an element at the end of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_push(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","push", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::value_type const &","push", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::value_type const &","push", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::value_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = std_set_Sl_FIX_SessionID_Sg__push(arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >::value_type(result)), SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_includeq___(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::value_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::value_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::value_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)std_set_Sl_FIX_SessionID_Sg____contains__(arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.[]

  call-seq:
    [](i) -> SessionID

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet___getitem__(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  std::set< FIX::SessionID >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::set< FIX::SessionID >::difference_type >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      try {
        result = std_set_Sl_FIX_SessionID_Sg____getitem__((std::set< FIX::SessionID > const *)arg1,SWIG_STD_MOVE(arg2));
      } catch(std::out_of_range &_e) {
        SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
          }
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >::value_type(result)), SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionIDSet__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SessionIDSet";
  std::set< FIX::SessionID > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID > *)new std::set< FIX::SessionID >();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SessionIDSet_allocate(VALUE self)
#else
_wrap_SessionIDSet_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SessionIDSet__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionIDSet";
  std::set< FIX::SessionID > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *ptr = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > const &","set<(FIX::SessionID)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID > const &","set<(FIX::SessionID)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID > *)new std::set< FIX::SessionID >((std::set< FIX::SessionID > const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionIDSet(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionIDSet__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_FIX__SessionID_t, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionIDSet__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = swig::asptr(argv[0], (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionIDSet__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SessionIDSet.new", 
    "    SessionIDSet.new(std::less< FIX::SessionID > const &other)\n"
    "    SessionIDSet.new()\n"
    "    SessionIDSet.new(std::set< FIX::SessionID > const &other)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.empty?

  call-seq:
    empty? -> bool

Check if the SessionIDSet is empty or not.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((std::set< FIX::SessionID > const *)arg1)->empty();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.size

  call-seq:
    size -> std::set< FIX::SessionID >::size_type

Size or Length of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_size(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((std::set< FIX::SessionID > const *)arg1)->size();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.clear

  call-seq:
    clear

Clear SessionIDSet contents.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_clear(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_swap(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID > * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->swap(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.erase

  call-seq:
    erase(x) -> std::set< FIX::SessionID >::size_type
    erase(pos)
    erase(first, last)

Delete a portion of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->erase((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_count(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((std::set< FIX::SessionID > const *)arg1)->count((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.begin

  call-seq:
    begin -> std::set< FIX::SessionID >::iterator

Return an iterator to the beginning of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_begin(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.end

  call-seq:
    end -> std::set< FIX::SessionID >::iterator

Return an iterator to past the end of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_end(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.rbegin

  call-seq:
    rbegin -> std::set< FIX::SessionID >::reverse_iterator

Return a reverse iterator to the beginning (the end) of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_rbegin(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->rbegin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::reverse_iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.rend

  call-seq:
    rend -> std::set< FIX::SessionID >::reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_rend(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->rend();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::reverse_iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.erase

  call-seq:
    erase(x) -> std::set< FIX::SessionID >::size_type
    erase(pos)
    erase(first, last)

Delete a portion of the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::set< FIX::SessionID >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 2, argv[0] ));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      std_set_Sl_FIX_SessionID_Sg__erase__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::iterator arg2 ;
  std::set< FIX::SessionID >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::set< FIX::SessionID >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::set< FIX::SessionID >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::iterator","erase", 3, argv[1] ));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      std_set_Sl_FIX_SessionID_Sg__erase__SWIG_2(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionIDSet_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    int res = swig::asptr(argv[0], (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionIDSet_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = swig::asptr(argv[0], (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_SessionIDSet_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    int res = swig::asptr(argv[0], (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::set< FIX::SessionID >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_SessionIDSet_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SessionIDSet.erase", 
    "    std::set< FIX::SessionID >::size_type SessionIDSet.erase(std::set< FIX::SessionID >::key_type const &x)\n"
    "    void SessionIDSet.erase(std::set< FIX::SessionID >::iterator pos)\n"
    "    void SessionIDSet.erase(std::set< FIX::SessionID >::iterator first, std::set< FIX::SessionID >::iterator last)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.find

  call-seq:
    find(x) -> std::set< FIX::SessionID >::iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_find(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->find((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->lower_bound((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::set< FIX::SessionID >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->upper_bound((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((swig::make_set_nonconst_iterator<std::set< FIX::SessionID >::iterator>(result, self)), swig::Iterator::descriptor(), SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionIDSet_equal_range(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  SwigValueWrapper< std::pair< std::set< FIX::SessionID >::iterator,std::set< FIX::SessionID >::iterator > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","equal_range", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::key_type const &","equal_range", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::key_type const &","equal_range", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::key_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->equal_range((std::set< FIX::SessionID >::key_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = rb_ary_new2(2);
  rb_ary_push(vresult, SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::pair< std::set< FIX::SessionID >::iterator,std::set< FIX::SessionID >::iterator > & >(result).first),
      swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
  rb_ary_push(vresult, SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::pair< std::set< FIX::SessionID >::iterator,std::set< FIX::SessionID >::iterator > & >(result).second),
      swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::SessionIDSet.insert

  call-seq:
    insert(x) -> std::pair< std::set< FIX::SessionID >::iterator,bool >

Insert one or more new elements in the SessionIDSet.
*/
SWIGINTERN VALUE
_wrap_SessionIDSet_insert(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *) 0 ;
  std::set< FIX::SessionID >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  SwigValueWrapper< std::pair< std::set< FIX::SessionID >::iterator,bool > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::set< FIX::SessionID > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::set< FIX::SessionID > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::set< FIX::SessionID >::value_type const &","insert", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::set< FIX::SessionID >::value_type const &","insert", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::set< FIX::SessionID >::value_type * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->insert((std::set< FIX::SessionID >::value_type const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = rb_ary_new2(2);
  rb_ary_push(vresult, SWIG_NewPointerObj((swig::make_set_nonconst_iterator((&result)->first)), swig::Iterator::descriptor(), SWIG_POINTER_OWN));
  rb_ary_push(vresult, SWIG_From_bool  (static_cast< const std::pair< std::set< FIX::SessionID >::iterator,bool > & >(result).second));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_set_Sl_FIX_SessionID_Sg_(void *self) {
    std::set< FIX::SessionID > *arg1 = (std::set< FIX::SessionID > *)self;
    delete arg1;
}

static swig_class SwigClassException;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Exception_allocate(VALUE self)
#else
_wrap_Exception_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Exception);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Exception(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Exception";
  FIX::Exception *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Exception", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Exception", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","Exception", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Exception", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Exception *)new FIX::Exception((std::string const &)*arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_Exception(void *self) {
    FIX::Exception *arg1 = (FIX::Exception *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Exception_type_set(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","type", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","type", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->type = *arg2;
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_type_get(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  result = (std::string *) & ((arg1)->type);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_detail_set(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","detail", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","detail", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","detail", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->detail = *arg2;
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_detail_get(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","detail", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  result = (std::string *) & ((arg1)->detail);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception___str__(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX_Exception___str__(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassDataDictionaryNotFound;

SWIGINTERN VALUE
_wrap_new_DataDictionaryNotFound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionaryNotFound";
  FIX::DataDictionaryNotFound *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DataDictionaryNotFound", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DataDictionaryNotFound", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DataDictionaryNotFound", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DataDictionaryNotFound", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionaryNotFound *)new FIX::DataDictionaryNotFound((std::string const &)*arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DataDictionaryNotFound_allocate(VALUE self)
#else
_wrap_DataDictionaryNotFound_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DataDictionaryNotFound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DataDictionaryNotFound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionaryNotFound";
  FIX::DataDictionaryNotFound *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DataDictionaryNotFound", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DataDictionaryNotFound", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionaryNotFound *)new FIX::DataDictionaryNotFound((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DataDictionaryNotFound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionaryNotFound__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_DataDictionaryNotFound__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "DataDictionaryNotFound.new", 
    "    DataDictionaryNotFound.new(std::string const &version, std::string const &what)\n"
    "    DataDictionaryNotFound.new(std::string const &version)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DataDictionaryNotFound(void *self) {
    FIX::DataDictionaryNotFound *arg1 = (FIX::DataDictionaryNotFound *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DataDictionaryNotFound_version_set(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionaryNotFound *arg1 = (FIX::DataDictionaryNotFound *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionaryNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionaryNotFound *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionaryNotFound * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","version", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","version", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->version = *arg2;
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionaryNotFound_version_get(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionaryNotFound *arg1 = (FIX::DataDictionaryNotFound *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionaryNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionaryNotFound *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionaryNotFound * >(argp1);
  result = (std::string *) & ((arg1)->version);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassFieldNotFound;

SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  FIX::FieldNotFound *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FieldNotFound", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FieldNotFound", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FieldNotFound", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldNotFound *)new FIX::FieldNotFound(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  FIX::FieldNotFound *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FieldNotFound", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldNotFound *)new FIX::FieldNotFound(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FieldNotFound_allocate(VALUE self)
#else
_wrap_FieldNotFound_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldNotFound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  FIX::FieldNotFound *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldNotFound *)new FIX::FieldNotFound();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldNotFound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldNotFound__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_FieldNotFound__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FieldNotFound__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldNotFound.new", 
    "    FieldNotFound.new(int field, std::string const &what)\n"
    "    FieldNotFound.new(int field)\n"
    "    FieldNotFound.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldNotFound_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::FieldNotFound *arg1 = (FIX::FieldNotFound *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldNotFound *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldNotFound * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldNotFound_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::FieldNotFound *arg1 = (FIX::FieldNotFound *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldNotFound *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldNotFound * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldNotFound(void *self) {
    FIX::FieldNotFound *arg1 = (FIX::FieldNotFound *)self;
    delete arg1;
}

static swig_class SwigClassFieldConvertError;

SWIGINTERN VALUE
_wrap_new_FieldConvertError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldConvertError";
  FIX::FieldConvertError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FieldConvertError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FieldConvertError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldConvertError *)new FIX::FieldConvertError((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FieldConvertError_allocate(VALUE self)
#else
_wrap_FieldConvertError_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldConvertError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FieldConvertError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::FieldConvertError";
  FIX::FieldConvertError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldConvertError *)new FIX::FieldConvertError();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldConvertError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldConvertError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldConvertError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FieldConvertError.new", 
    "    FieldConvertError.new(std::string const &what)\n"
    "    FieldConvertError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldConvertError(void *self) {
    FIX::FieldConvertError *arg1 = (FIX::FieldConvertError *)self;
    delete arg1;
}

static swig_class SwigClassMessageParseError;

SWIGINTERN VALUE
_wrap_new_MessageParseError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::MessageParseError";
  FIX::MessageParseError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MessageParseError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MessageParseError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageParseError *)new FIX::MessageParseError((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MessageParseError_allocate(VALUE self)
#else
_wrap_MessageParseError_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageParseError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MessageParseError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::MessageParseError";
  FIX::MessageParseError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageParseError *)new FIX::MessageParseError();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MessageParseError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MessageParseError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MessageParseError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "MessageParseError.new", 
    "    MessageParseError.new(std::string const &what)\n"
    "    MessageParseError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageParseError(void *self) {
    FIX::MessageParseError *arg1 = (FIX::MessageParseError *)self;
    delete arg1;
}

static swig_class SwigClassInvalidMessage;

SWIGINTERN VALUE
_wrap_new_InvalidMessage__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessage";
  FIX::InvalidMessage *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","InvalidMessage", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","InvalidMessage", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidMessage *)new FIX::InvalidMessage((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_InvalidMessage_allocate(VALUE self)
#else
_wrap_InvalidMessage_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidMessage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_InvalidMessage__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessage";
  FIX::InvalidMessage *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidMessage *)new FIX::InvalidMessage();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidMessage(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidMessage__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InvalidMessage__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "InvalidMessage.new", 
    "    InvalidMessage.new(std::string const &what)\n"
    "    InvalidMessage.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidMessage(void *self) {
    FIX::InvalidMessage *arg1 = (FIX::InvalidMessage *)self;
    delete arg1;
}

static swig_class SwigClassConfigError;

SWIGINTERN VALUE
_wrap_new_ConfigError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::ConfigError";
  FIX::ConfigError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","ConfigError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ConfigError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ConfigError *)new FIX::ConfigError((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_ConfigError_allocate(VALUE self)
#else
_wrap_ConfigError_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ConfigError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_ConfigError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::ConfigError";
  FIX::ConfigError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ConfigError *)new FIX::ConfigError();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ConfigError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ConfigError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ConfigError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ConfigError.new", 
    "    ConfigError.new(std::string const &what)\n"
    "    ConfigError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ConfigError(void *self) {
    FIX::ConfigError *arg1 = (FIX::ConfigError *)self;
    delete arg1;
}

static swig_class SwigClassRuntimeError;

SWIGINTERN VALUE
_wrap_new_RuntimeError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RuntimeError";
  FIX::RuntimeError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","RuntimeError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","RuntimeError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RuntimeError *)new FIX::RuntimeError((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_RuntimeError_allocate(VALUE self)
#else
_wrap_RuntimeError_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RuntimeError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_RuntimeError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::RuntimeError";
  FIX::RuntimeError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RuntimeError *)new FIX::RuntimeError();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RuntimeError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RuntimeError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RuntimeError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RuntimeError.new", 
    "    RuntimeError.new(std::string const &what)\n"
    "    RuntimeError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RuntimeError(void *self) {
    FIX::RuntimeError *arg1 = (FIX::RuntimeError *)self;
    delete arg1;
}

static swig_class SwigClassInvalidTagNumber;

SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  FIX::InvalidTagNumber *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","InvalidTagNumber", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","InvalidTagNumber", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","InvalidTagNumber", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  FIX::InvalidTagNumber *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","InvalidTagNumber", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_InvalidTagNumber_allocate(VALUE self)
#else
_wrap_InvalidTagNumber_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidTagNumber);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  FIX::InvalidTagNumber *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidTagNumber(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidTagNumber__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_InvalidTagNumber__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_InvalidTagNumber__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InvalidTagNumber.new", 
    "    InvalidTagNumber.new(int field, std::string const &what)\n"
    "    InvalidTagNumber.new(int field)\n"
    "    InvalidTagNumber.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InvalidTagNumber_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidTagNumber *arg1 = (FIX::InvalidTagNumber *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__InvalidTagNumber, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::InvalidTagNumber *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::InvalidTagNumber * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InvalidTagNumber_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidTagNumber *arg1 = (FIX::InvalidTagNumber *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__InvalidTagNumber, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::InvalidTagNumber *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::InvalidTagNumber * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidTagNumber(void *self) {
    FIX::InvalidTagNumber *arg1 = (FIX::InvalidTagNumber *)self;
    delete arg1;
}

static swig_class SwigClassRequiredTagMissing;

SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  FIX::RequiredTagMissing *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RequiredTagMissing", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","RequiredTagMissing", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","RequiredTagMissing", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  FIX::RequiredTagMissing *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RequiredTagMissing", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_RequiredTagMissing_allocate(VALUE self)
#else
_wrap_RequiredTagMissing_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RequiredTagMissing);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  FIX::RequiredTagMissing *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RequiredTagMissing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RequiredTagMissing__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RequiredTagMissing__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RequiredTagMissing__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RequiredTagMissing.new", 
    "    RequiredTagMissing.new(int field, std::string const &what)\n"
    "    RequiredTagMissing.new(int field)\n"
    "    RequiredTagMissing.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RequiredTagMissing_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RequiredTagMissing *arg1 = (FIX::RequiredTagMissing *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RequiredTagMissing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RequiredTagMissing *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RequiredTagMissing * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RequiredTagMissing_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RequiredTagMissing *arg1 = (FIX::RequiredTagMissing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RequiredTagMissing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RequiredTagMissing *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RequiredTagMissing * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RequiredTagMissing(void *self) {
    FIX::RequiredTagMissing *arg1 = (FIX::RequiredTagMissing *)self;
    delete arg1;
}

static swig_class SwigClassTagNotDefinedForMessage;

SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  FIX::TagNotDefinedForMessage *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","TagNotDefinedForMessage", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","TagNotDefinedForMessage", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","TagNotDefinedForMessage", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  FIX::TagNotDefinedForMessage *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","TagNotDefinedForMessage", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_TagNotDefinedForMessage_allocate(VALUE self)
#else
_wrap_TagNotDefinedForMessage_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TagNotDefinedForMessage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  FIX::TagNotDefinedForMessage *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TagNotDefinedForMessage(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TagNotDefinedForMessage__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_TagNotDefinedForMessage__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_TagNotDefinedForMessage__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "TagNotDefinedForMessage.new", 
    "    TagNotDefinedForMessage.new(int field, std::string const &what)\n"
    "    TagNotDefinedForMessage.new(int field)\n"
    "    TagNotDefinedForMessage.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagNotDefinedForMessage_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::TagNotDefinedForMessage *arg1 = (FIX::TagNotDefinedForMessage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagNotDefinedForMessage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagNotDefinedForMessage *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagNotDefinedForMessage * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagNotDefinedForMessage_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::TagNotDefinedForMessage *arg1 = (FIX::TagNotDefinedForMessage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagNotDefinedForMessage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagNotDefinedForMessage *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagNotDefinedForMessage * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_TagNotDefinedForMessage(void *self) {
    FIX::TagNotDefinedForMessage *arg1 = (FIX::TagNotDefinedForMessage *)self;
    delete arg1;
}

static swig_class SwigClassNoTagValue;

SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  FIX::NoTagValue *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","NoTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","NoTagValue", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","NoTagValue", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::NoTagValue *)new FIX::NoTagValue(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  FIX::NoTagValue *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","NoTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::NoTagValue *)new FIX::NoTagValue(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_NoTagValue_allocate(VALUE self)
#else
_wrap_NoTagValue_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__NoTagValue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  FIX::NoTagValue *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::NoTagValue *)new FIX::NoTagValue();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_NoTagValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_NoTagValue__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_NoTagValue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_NoTagValue__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "NoTagValue.new", 
    "    NoTagValue.new(int field, std::string const &what)\n"
    "    NoTagValue.new(int field)\n"
    "    NoTagValue.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NoTagValue_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::NoTagValue *arg1 = (FIX::NoTagValue *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NoTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NoTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NoTagValue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NoTagValue_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::NoTagValue *arg1 = (FIX::NoTagValue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NoTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NoTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NoTagValue * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_NoTagValue(void *self) {
    FIX::NoTagValue *arg1 = (FIX::NoTagValue *)self;
    delete arg1;
}

static swig_class SwigClassIncorrectTagValue;

SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  FIX::IncorrectTagValue *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IncorrectTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","IncorrectTagValue", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","IncorrectTagValue", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  FIX::IncorrectTagValue *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IncorrectTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IncorrectTagValue_allocate(VALUE self)
#else
_wrap_IncorrectTagValue_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectTagValue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  FIX::IncorrectTagValue *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectTagValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectTagValue__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IncorrectTagValue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_IncorrectTagValue__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IncorrectTagValue.new", 
    "    IncorrectTagValue.new(int field, std::string const &what)\n"
    "    IncorrectTagValue.new(int field)\n"
    "    IncorrectTagValue.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectTagValue_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectTagValue *arg1 = (FIX::IncorrectTagValue *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectTagValue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectTagValue_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectTagValue *arg1 = (FIX::IncorrectTagValue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectTagValue * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectTagValue(void *self) {
    FIX::IncorrectTagValue *arg1 = (FIX::IncorrectTagValue *)self;
    delete arg1;
}

static swig_class SwigClassIncorrectDataFormat;

SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  FIX::IncorrectDataFormat *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IncorrectDataFormat", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","IncorrectDataFormat", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","IncorrectDataFormat", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  FIX::IncorrectDataFormat *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IncorrectDataFormat", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IncorrectDataFormat_allocate(VALUE self)
#else
_wrap_IncorrectDataFormat_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectDataFormat);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  FIX::IncorrectDataFormat *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectDataFormat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectDataFormat__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IncorrectDataFormat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_IncorrectDataFormat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IncorrectDataFormat.new", 
    "    IncorrectDataFormat.new(int field, std::string const &what)\n"
    "    IncorrectDataFormat.new(int field)\n"
    "    IncorrectDataFormat.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectDataFormat_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectDataFormat *arg1 = (FIX::IncorrectDataFormat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectDataFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectDataFormat *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectDataFormat * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectDataFormat_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectDataFormat *arg1 = (FIX::IncorrectDataFormat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectDataFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectDataFormat *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectDataFormat * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectDataFormat(void *self) {
    FIX::IncorrectDataFormat *arg1 = (FIX::IncorrectDataFormat *)self;
    delete arg1;
}

static swig_class SwigClassIncorrectMessageStructure;

SWIGINTERN VALUE
_wrap_new_IncorrectMessageStructure__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectMessageStructure";
  FIX::IncorrectMessageStructure *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","IncorrectMessageStructure", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","IncorrectMessageStructure", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectMessageStructure *)new FIX::IncorrectMessageStructure((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IncorrectMessageStructure_allocate(VALUE self)
#else
_wrap_IncorrectMessageStructure_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectMessageStructure);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IncorrectMessageStructure__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::IncorrectMessageStructure";
  FIX::IncorrectMessageStructure *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IncorrectMessageStructure *)new FIX::IncorrectMessageStructure();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectMessageStructure(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectMessageStructure__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IncorrectMessageStructure__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IncorrectMessageStructure.new", 
    "    IncorrectMessageStructure.new(std::string const &what)\n"
    "    IncorrectMessageStructure.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectMessageStructure(void *self) {
    FIX::IncorrectMessageStructure *arg1 = (FIX::IncorrectMessageStructure *)self;
    delete arg1;
}

static swig_class SwigClassDuplicateFieldNumber;

SWIGINTERN VALUE
_wrap_new_DuplicateFieldNumber__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DuplicateFieldNumber";
  FIX::DuplicateFieldNumber *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DuplicateFieldNumber", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DuplicateFieldNumber", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DuplicateFieldNumber *)new FIX::DuplicateFieldNumber((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DuplicateFieldNumber_allocate(VALUE self)
#else
_wrap_DuplicateFieldNumber_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DuplicateFieldNumber);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DuplicateFieldNumber__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::DuplicateFieldNumber";
  FIX::DuplicateFieldNumber *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DuplicateFieldNumber *)new FIX::DuplicateFieldNumber();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DuplicateFieldNumber(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DuplicateFieldNumber__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DuplicateFieldNumber__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DuplicateFieldNumber.new", 
    "    DuplicateFieldNumber.new(std::string const &what)\n"
    "    DuplicateFieldNumber.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DuplicateFieldNumber(void *self) {
    FIX::DuplicateFieldNumber *arg1 = (FIX::DuplicateFieldNumber *)self;
    delete arg1;
}

static swig_class SwigClassInvalidMessageType;

SWIGINTERN VALUE
_wrap_new_InvalidMessageType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessageType";
  FIX::InvalidMessageType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","InvalidMessageType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","InvalidMessageType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidMessageType *)new FIX::InvalidMessageType((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_InvalidMessageType_allocate(VALUE self)
#else
_wrap_InvalidMessageType_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidMessageType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_InvalidMessageType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessageType";
  FIX::InvalidMessageType *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::InvalidMessageType *)new FIX::InvalidMessageType();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidMessageType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidMessageType__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InvalidMessageType__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "InvalidMessageType.new", 
    "    InvalidMessageType.new(std::string const &what)\n"
    "    InvalidMessageType.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidMessageType(void *self) {
    FIX::InvalidMessageType *arg1 = (FIX::InvalidMessageType *)self;
    delete arg1;
}

static swig_class SwigClassUnsupportedMessageType;

SWIGINTERN VALUE
_wrap_new_UnsupportedMessageType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedMessageType";
  FIX::UnsupportedMessageType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","UnsupportedMessageType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","UnsupportedMessageType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UnsupportedMessageType *)new FIX::UnsupportedMessageType((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UnsupportedMessageType_allocate(VALUE self)
#else
_wrap_UnsupportedMessageType_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnsupportedMessageType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UnsupportedMessageType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedMessageType";
  FIX::UnsupportedMessageType *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UnsupportedMessageType *)new FIX::UnsupportedMessageType();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnsupportedMessageType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnsupportedMessageType__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnsupportedMessageType__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnsupportedMessageType.new", 
    "    UnsupportedMessageType.new(std::string const &what)\n"
    "    UnsupportedMessageType.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnsupportedMessageType(void *self) {
    FIX::UnsupportedMessageType *arg1 = (FIX::UnsupportedMessageType *)self;
    delete arg1;
}

static swig_class SwigClassUnsupportedVersion;

SWIGINTERN VALUE
_wrap_new_UnsupportedVersion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedVersion";
  FIX::UnsupportedVersion *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","UnsupportedVersion", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","UnsupportedVersion", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UnsupportedVersion *)new FIX::UnsupportedVersion((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UnsupportedVersion_allocate(VALUE self)
#else
_wrap_UnsupportedVersion_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnsupportedVersion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UnsupportedVersion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedVersion";
  FIX::UnsupportedVersion *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UnsupportedVersion *)new FIX::UnsupportedVersion();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnsupportedVersion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnsupportedVersion__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnsupportedVersion__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnsupportedVersion.new", 
    "    UnsupportedVersion.new(std::string const &what)\n"
    "    UnsupportedVersion.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnsupportedVersion(void *self) {
    FIX::UnsupportedVersion *arg1 = (FIX::UnsupportedVersion *)self;
    delete arg1;
}

static swig_class SwigClassTagOutOfOrder;

SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  FIX::TagOutOfOrder *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","TagOutOfOrder", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","TagOutOfOrder", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","TagOutOfOrder", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  FIX::TagOutOfOrder *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","TagOutOfOrder", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_TagOutOfOrder_allocate(VALUE self)
#else
_wrap_TagOutOfOrder_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TagOutOfOrder);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  FIX::TagOutOfOrder *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TagOutOfOrder(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TagOutOfOrder__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_TagOutOfOrder__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_TagOutOfOrder__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "TagOutOfOrder.new", 
    "    TagOutOfOrder.new(int field, std::string const &what)\n"
    "    TagOutOfOrder.new(int field)\n"
    "    TagOutOfOrder.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagOutOfOrder_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::TagOutOfOrder *arg1 = (FIX::TagOutOfOrder *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagOutOfOrder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagOutOfOrder *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagOutOfOrder * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagOutOfOrder_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::TagOutOfOrder *arg1 = (FIX::TagOutOfOrder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagOutOfOrder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagOutOfOrder *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagOutOfOrder * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_TagOutOfOrder(void *self) {
    FIX::TagOutOfOrder *arg1 = (FIX::TagOutOfOrder *)self;
    delete arg1;
}

static swig_class SwigClassRepeatedTag;

SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  FIX::RepeatedTag *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RepeatedTag", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","RepeatedTag", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","RepeatedTag", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatedTag *)new FIX::RepeatedTag(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  FIX::RepeatedTag *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RepeatedTag", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatedTag *)new FIX::RepeatedTag(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_RepeatedTag_allocate(VALUE self)
#else
_wrap_RepeatedTag_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RepeatedTag);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  FIX::RepeatedTag *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatedTag *)new FIX::RepeatedTag();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RepeatedTag(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RepeatedTag__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RepeatedTag__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RepeatedTag__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RepeatedTag.new", 
    "    RepeatedTag.new(int field, std::string const &what)\n"
    "    RepeatedTag.new(int field)\n"
    "    RepeatedTag.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatedTag_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatedTag *arg1 = (FIX::RepeatedTag *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatedTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatedTag *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatedTag * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatedTag_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatedTag *arg1 = (FIX::RepeatedTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatedTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatedTag *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatedTag * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RepeatedTag(void *self) {
    FIX::RepeatedTag *arg1 = (FIX::RepeatedTag *)self;
    delete arg1;
}

static swig_class SwigClassRepeatingGroupCountMismatch;

SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RepeatingGroupCountMismatch", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","RepeatingGroupCountMismatch", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","RepeatingGroupCountMismatch", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","RepeatingGroupCountMismatch", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_RepeatingGroupCountMismatch_allocate(VALUE self)
#else
_wrap_RepeatingGroupCountMismatch_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RepeatingGroupCountMismatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RepeatingGroupCountMismatch(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RepeatingGroupCountMismatch__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RepeatingGroupCountMismatch__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RepeatingGroupCountMismatch__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RepeatingGroupCountMismatch.new", 
    "    RepeatingGroupCountMismatch.new(int field, std::string const &what)\n"
    "    RepeatingGroupCountMismatch.new(int field)\n"
    "    RepeatingGroupCountMismatch.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatingGroupCountMismatch_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatingGroupCountMismatch *arg1 = (FIX::RepeatingGroupCountMismatch *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatingGroupCountMismatch *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatingGroupCountMismatch * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatingGroupCountMismatch_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatingGroupCountMismatch *arg1 = (FIX::RepeatingGroupCountMismatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatingGroupCountMismatch *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatingGroupCountMismatch * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RepeatingGroupCountMismatch(void *self) {
    FIX::RepeatingGroupCountMismatch *arg1 = (FIX::RepeatingGroupCountMismatch *)self;
    delete arg1;
}

static swig_class SwigClassDoNotSend;

SWIGINTERN VALUE
_wrap_new_DoNotSend__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DoNotSend";
  FIX::DoNotSend *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DoNotSend", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DoNotSend", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DoNotSend *)new FIX::DoNotSend((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DoNotSend_allocate(VALUE self)
#else
_wrap_DoNotSend_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DoNotSend);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DoNotSend__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::DoNotSend";
  FIX::DoNotSend *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DoNotSend *)new FIX::DoNotSend();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DoNotSend(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DoNotSend__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DoNotSend__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DoNotSend.new", 
    "    DoNotSend.new(std::string const &what)\n"
    "    DoNotSend.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DoNotSend(void *self) {
    FIX::DoNotSend *arg1 = (FIX::DoNotSend *)self;
    delete arg1;
}

static swig_class SwigClassRejectLogon;

SWIGINTERN VALUE
_wrap_new_RejectLogon__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RejectLogon";
  FIX::RejectLogon *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","RejectLogon", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","RejectLogon", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RejectLogon *)new FIX::RejectLogon((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_RejectLogon_allocate(VALUE self)
#else
_wrap_RejectLogon_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RejectLogon);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_RejectLogon__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::RejectLogon";
  FIX::RejectLogon *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::RejectLogon *)new FIX::RejectLogon();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RejectLogon(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RejectLogon__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RejectLogon__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RejectLogon.new", 
    "    RejectLogon.new(std::string const &what)\n"
    "    RejectLogon.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RejectLogon(void *self) {
    FIX::RejectLogon *arg1 = (FIX::RejectLogon *)self;
    delete arg1;
}

static swig_class SwigClassSessionNotFound;

SWIGINTERN VALUE
_wrap_new_SessionNotFound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionNotFound";
  FIX::SessionNotFound *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SessionNotFound", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionNotFound", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionNotFound *)new FIX::SessionNotFound((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SessionNotFound_allocate(VALUE self)
#else
_wrap_SessionNotFound_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionNotFound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SessionNotFound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SessionNotFound";
  FIX::SessionNotFound *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionNotFound *)new FIX::SessionNotFound();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionNotFound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionNotFound__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionNotFound__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SessionNotFound.new", 
    "    SessionNotFound.new(std::string const &what)\n"
    "    SessionNotFound.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionNotFound(void *self) {
    FIX::SessionNotFound *arg1 = (FIX::SessionNotFound *)self;
    delete arg1;
}

static swig_class SwigClassIOException;

SWIGINTERN VALUE
_wrap_new_IOException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IOException";
  FIX::IOException *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","IOException", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","IOException", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IOException *)new FIX::IOException((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IOException_allocate(VALUE self)
#else
_wrap_IOException_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IOException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IOException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::IOException";
  FIX::IOException *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IOException *)new FIX::IOException();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IOException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IOException__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IOException__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IOException.new", 
    "    IOException.new(std::string const &what)\n"
    "    IOException.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IOException(void *self) {
    FIX::IOException *arg1 = (FIX::IOException *)self;
    delete arg1;
}

static swig_class SwigClassSocketException;

SWIGINTERN VALUE
_wrap_new_SocketException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SocketException";
  FIX::SocketException *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketException *)new FIX::SocketException();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketException_allocate(VALUE self)
#else
_wrap_SocketException_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketException";
  FIX::SocketException *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SocketException", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SocketException", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketException *)new FIX::SocketException((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketException__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketException__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketException.new", 
    "    SocketException.new()\n"
    "    SocketException.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SocketException_errorToWhat(int argc, VALUE *argv, VALUE self) {
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::SocketException::errorToWhat();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketException(void *self) {
    FIX::SocketException *arg1 = (FIX::SocketException *)self;
    delete arg1;
}

static swig_class SwigClassSocketSendFailed;

SWIGINTERN VALUE
_wrap_new_SocketSendFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SocketSendFailed";
  FIX::SocketSendFailed *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketSendFailed *)new FIX::SocketSendFailed();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketSendFailed_allocate(VALUE self)
#else
_wrap_SocketSendFailed_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketSendFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketSendFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketSendFailed";
  FIX::SocketSendFailed *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SocketSendFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SocketSendFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketSendFailed *)new FIX::SocketSendFailed((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketSendFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketSendFailed__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketSendFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketSendFailed.new", 
    "    SocketSendFailed.new()\n"
    "    SocketSendFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketSendFailed(void *self) {
    FIX::SocketSendFailed *arg1 = (FIX::SocketSendFailed *)self;
    delete arg1;
}

static swig_class SwigClassSocketRecvFailed;

SWIGINTERN VALUE
_wrap_new_SocketRecvFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ssize_t arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketRecvFailed";
  FIX::SocketRecvFailed *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ssize_t,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ssize_t","SocketRecvFailed", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ssize_t","SocketRecvFailed", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< ssize_t * >(argp1));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketRecvFailed *)new FIX::SocketRecvFailed(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketRecvFailed_allocate(VALUE self)
#else
_wrap_SocketRecvFailed_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketRecvFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketRecvFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketRecvFailed";
  FIX::SocketRecvFailed *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SocketRecvFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SocketRecvFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketRecvFailed *)new FIX::SocketRecvFailed((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketRecvFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ssize_t, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketRecvFailed__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketRecvFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketRecvFailed.new", 
    "    SocketRecvFailed.new(ssize_t size)\n"
    "    SocketRecvFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketRecvFailed(void *self) {
    FIX::SocketRecvFailed *arg1 = (FIX::SocketRecvFailed *)self;
    delete arg1;
}

static swig_class SwigClassSocketCloseFailed;

SWIGINTERN VALUE
_wrap_new_SocketCloseFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SocketCloseFailed";
  FIX::SocketCloseFailed *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketCloseFailed *)new FIX::SocketCloseFailed();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketCloseFailed_allocate(VALUE self)
#else
_wrap_SocketCloseFailed_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketCloseFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketCloseFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketCloseFailed";
  FIX::SocketCloseFailed *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SocketCloseFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SocketCloseFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketCloseFailed *)new FIX::SocketCloseFailed((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketCloseFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketCloseFailed__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketCloseFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketCloseFailed.new", 
    "    SocketCloseFailed.new()\n"
    "    SocketCloseFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketCloseFailed(void *self) {
    FIX::SocketCloseFailed *arg1 = (FIX::SocketCloseFailed *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PRECISION_FACTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(FIX::PRECISION_FACTOR), SWIGTYPE_p_int,  0 );
  return _val;
}


static swig_class SwigClassDateTime;

SWIGINTERN VALUE
_wrap_DateTime_m_date_set(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","m_date", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","m_date", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->m_date = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_m_date_get(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","m_date", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  result = (int) ((arg1)->m_date);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_m_time_set(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int64_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","m_time", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_int64_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int64_t","m_time", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int64_t","m_time", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< int64_t * >(argp2));
    }
  }
  if (arg1) (arg1)->m_time = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_m_time_get(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int64_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","m_time", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  result =  ((arg1)->m_time);
  vresult = SWIG_NewPointerObj((new int64_t(result)), SWIGTYPE_p_int64_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DateTime__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::DateTime";
  FIX::DateTime *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DateTime *)new FIX::DateTime();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DateTime__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int64_t arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DateTime";
  FIX::DateTime *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DateTime", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_int64_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int64_t","DateTime", 2, argv[1] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int64_t","DateTime", 2, argv[1]));
    } else {
      arg2 = *(reinterpret_cast< int64_t * >(argp2));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DateTime *)new FIX::DateTime(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DateTime__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DateTime";
  FIX::DateTime *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DateTime", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","DateTime", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","DateTime", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","DateTime", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","DateTime", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","DateTime", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","DateTime", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DateTime *)new FIX::DateTime(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DateTime_allocate(VALUE self)
#else
_wrap_DateTime_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DateTime);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DateTime__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DateTime";
  FIX::DateTime *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DateTime", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","DateTime", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","DateTime", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","DateTime", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","DateTime", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","DateTime", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","DateTime", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "int","DateTime", 8, argv[7] ));
  } 
  arg8 = static_cast< int >(val8);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DateTime *)new FIX::DateTime(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DateTime(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs;
  if (argc > 8) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DateTime__SWIG_0(nargs, args, self);
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_int64_t, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_DateTime__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_DateTime__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_DateTime__SWIG_3(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 8, "DateTime.new", 
    "    DateTime.new()\n"
    "    DateTime.new(int date, int64_t time)\n"
    "    DateTime.new(int year, int month, int day, int hour, int minute, int second, int millis)\n"
    "    DateTime.new(int year, int month, int day, int hour, int minute, int second, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DateTime(void *self) {
    FIX::DateTime *arg1 = (FIX::DateTime *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DateTime_getYear(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getYear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getYear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getMonth(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getMonth", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getMonth();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getDay(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getDay();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getDate(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getDate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getDate();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getJulianDate(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getJulianDate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getJulianDate();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getHour(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getHour", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getHour();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getMinute(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getMinute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getMinute();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getSecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getSecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getSecond();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getMillisecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getMillisecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getMillisecond();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getMicrosecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getMicrosecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getMicrosecond();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getNanosecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getNanosecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (unsigned int)((FIX::DateTime const *)arg1)->getNanosecond();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getFraction(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getFraction", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFraction", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getFraction(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getWeekDay(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getWeekDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::DateTime const *)arg1)->getWeekDay();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getTimeT(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  time_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getTimeT", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::DateTime const *)arg1)->getTimeT();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    vresult = rb_time_new(result, 0);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_getTmUtc(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  tm result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const *","getTmUtc", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::DateTime const *)arg1)->getTmUtc();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new tm(result)), SWIGTYPE_p_tm, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setYMD(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setYMD", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setYMD", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setYMD", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","setYMD", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setYMD(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setHMS__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setHMS", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setHMS", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setHMS", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","setHMS", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","setHMS", 5, argv[3] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setHMS(arg2,arg3,arg4,arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setHMS__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setHMS", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setHMS", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setHMS", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","setHMS", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","setHMS", 5, argv[3] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","setHMS", 6, argv[4] ));
  } 
  arg6 = static_cast< int >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setHMS(arg2,arg3,arg4,arg5,arg6);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DateTime_setHMS(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 5) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_DateTime_setHMS__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_DateTime_setHMS__SWIG_1(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "DateTime.setHMS", 
    "    void DateTime.setHMS(int hour, int minute, int second, int millis)\n"
    "    void DateTime.setHMS(int hour, int minute, int second, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setHour(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setHour", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setHour", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setHour(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setMinute(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setMinute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setMinute", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setMinute(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setSecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setSecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setSecond", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setSecond(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setMillisecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setMillisecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setMillisecond", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setMillisecond(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setMicrosecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setMicrosecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setMicrosecond", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setMicrosecond(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setNanosecond(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setNanosecond", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNanosecond", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNanosecond(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_setFraction(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","setFraction", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setFraction", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setFraction", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setFraction(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_clearDate(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","clearDate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clearDate();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_clearTime(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","clearTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clearTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  int arg2 ;
  int64_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int64_t,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int64_t","set", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int64_t","set", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< int64_t * >(argp3));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->set(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = (FIX::DateTime *) 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DateTime, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->set((FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DateTime_set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DateTime_set__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_int64_t, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DateTime_set__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DateTime.set", 
    "    void DateTime.set(int date, int64_t time)\n"
    "    void DateTime.set(FIX::DateTime const &other)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_convertToNanos(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DateTime::convertToNanos", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::convertToNanos", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)FIX::DateTime::convertToNanos(arg1,arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_makeHMS(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int64_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DateTime::makeHMS", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::makeHMS", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DateTime::makeHMS", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","FIX::DateTime::makeHMS", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::makeHMS(arg1,arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new int64_t(result)), SWIGTYPE_p_int64_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_nowUtc(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::nowUtc();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_nowLocal(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::nowLocal();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromUtcTimeT__SWIG_0(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromUtcTimeT", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromUtcTimeT(SWIG_STD_MOVE(arg1),arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromUtcTimeT__SWIG_1(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromUtcTimeT(SWIG_STD_MOVE(arg1));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromLocalTimeT__SWIG_0(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromLocalTimeT", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromLocalTimeT(SWIG_STD_MOVE(arg1),arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromLocalTimeT__SWIG_1(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromLocalTimeT(SWIG_STD_MOVE(arg1));
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromUtcTimeT__SWIG_2(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromUtcTimeT", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromUtcTimeT", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromUtcTimeT(SWIG_STD_MOVE(arg1),arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DateTime_fromUtcTimeT(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_DateTime_fromUtcTimeT__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DateTime_fromUtcTimeT__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DateTime_fromUtcTimeT__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "DateTime.fromUtcTimeT", 
    "    FIX::DateTime DateTime.fromUtcTimeT(time_t t, int millis)\n"
    "    FIX::DateTime DateTime.fromUtcTimeT(time_t t)\n"
    "    FIX::DateTime DateTime.fromUtcTimeT(time_t t, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromLocalTimeT__SWIG_2(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromLocalTimeT", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromLocalTimeT", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromLocalTimeT(SWIG_STD_MOVE(arg1),arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DateTime_fromLocalTimeT(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_DateTime_fromLocalTimeT__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DateTime_fromLocalTimeT__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DateTime_fromLocalTimeT__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "DateTime.fromLocalTimeT", 
    "    FIX::DateTime DateTime.fromLocalTimeT(time_t t, int millis)\n"
    "    FIX::DateTime DateTime.fromLocalTimeT(time_t t)\n"
    "    FIX::DateTime DateTime.fromLocalTimeT(time_t t, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromTm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_tm,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const &","FIX::DateTime::fromTm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "tm const &","FIX::DateTime::fromTm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromTm", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromTm((tm const &)*arg1,arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromTm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_tm,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const &","FIX::DateTime::fromTm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "tm const &","FIX::DateTime::fromTm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromTm((tm const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_fromTm__SWIG_2(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  FIX::DateTime result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_tm,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const &","FIX::DateTime::fromTm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "tm const &","FIX::DateTime::fromTm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromTm", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DateTime::fromTm", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::DateTime::fromTm((tm const &)*arg1,arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::DateTime(result)), SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DateTime_fromTm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DateTime_fromTm__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DateTime_fromTm__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DateTime_fromTm__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "DateTime.fromTm", 
    "    FIX::DateTime DateTime.fromTm(tm const &tm, int millis)\n"
    "    FIX::DateTime DateTime.fromTm(tm const &tm)\n"
    "    FIX::DateTime DateTime.fromTm(tm const &tm, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateTime_julianDate(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DateTime::julianDate", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::DateTime::julianDate", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DateTime::julianDate", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)FIX::DateTime::julianDate(arg1,arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>

  call-seq:
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap___gt____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator >", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator >", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator >", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator >", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<=

  call-seq:
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___le____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator <=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator <=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator <=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator <=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <=((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>=

  call-seq:
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___ge____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator >=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator >=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator >=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator >=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >=((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.-

  call-seq:
    -(lhs, rhs) -> int

Subtraction operator.
*/
SWIGINTERN VALUE
_wrap___sub__(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  FIX::DateTime *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator -", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator -", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DateTime const &","FIX::operator -", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","FIX::operator -", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DateTime * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)FIX::operator -((FIX::DateTime const &)*arg1,(FIX::DateTime const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassUtcTimeStamp;

SWIGINTERN VALUE
_wrap_UtcTimeStamp_now(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::UtcTimeStamp::now();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime","UtcTimeStamp", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime","UtcTimeStamp", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< FIX::DateTime * >(argp1));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_4(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3,arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_5(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_6(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_7(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 8, argv[7] ));
  } 
  arg8 = static_cast< int >(val8);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_8(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_9(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_10(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_11(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp((tm const *)arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_12(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcTimeStamp_allocate(VALUE self)
#else
_wrap_UtcTimeStamp_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeStamp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStamp__SWIG_13(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStamp";
  FIX::UtcTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStamp *)new FIX::UtcTimeStamp((tm const *)arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeStamp(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs;
  if (argc > 8) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UtcTimeStamp__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcTimeStamp__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcTimeStamp__SWIG_12(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_new_UtcTimeStamp__SWIG_9(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeStamp__SWIG_11(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeStamp__SWIG_8(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeStamp__SWIG_13(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeStamp__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeStamp__SWIG_10(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_UtcTimeStamp__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_UtcTimeStamp__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_UtcTimeStamp__SWIG_5(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_UtcTimeStamp__SWIG_6(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_UtcTimeStamp__SWIG_7(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 8, "UtcTimeStamp.new", 
    "    UtcTimeStamp.new()\n"
    "    UtcTimeStamp.new(FIX::DateTime dateTime)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second, int millisecond)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second, int fraction, int precision)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second, int date, int month, int year)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second, int millisecond, int date, int month, int year)\n"
    "    UtcTimeStamp.new(int hour, int minute, int second, int fraction, int date, int month, int year, int precision)\n"
    "    UtcTimeStamp.new(time_t time, int millisecond)\n"
    "    UtcTimeStamp.new(time_t time)\n"
    "    UtcTimeStamp.new(time_t time, int fraction, int precision)\n"
    "    UtcTimeStamp.new(tm const *time, int millisecond)\n"
    "    UtcTimeStamp.new(tm const *time)\n"
    "    UtcTimeStamp.new(tm const *time, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeStamp_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = (FIX::UtcTimeStamp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStamp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeStamp(void *self) {
    FIX::UtcTimeStamp *arg1 = (FIX::UtcTimeStamp *)self;
    delete arg1;
}

static swig_class SwigClassLocalTimeStamp;

SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3,arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_4(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_5(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_6(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 8, argv[7] ));
  } 
  arg8 = static_cast< int >(val8);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_7(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_8(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_9(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_10(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp((tm const *)arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_11(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_LocalTimeStamp_allocate(VALUE self)
#else
_wrap_LocalTimeStamp_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LocalTimeStamp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeStamp__SWIG_12(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeStamp";
  FIX::LocalTimeStamp *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeStamp", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeStamp", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeStamp *)new FIX::LocalTimeStamp((tm const *)arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LocalTimeStamp(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs;
  if (argc > 8) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LocalTimeStamp__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalTimeStamp__SWIG_11(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_new_LocalTimeStamp__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalTimeStamp__SWIG_10(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalTimeStamp__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeStamp__SWIG_12(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeStamp__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeStamp__SWIG_9(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_LocalTimeStamp__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_LocalTimeStamp__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_LocalTimeStamp__SWIG_4(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_LocalTimeStamp__SWIG_5(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_LocalTimeStamp__SWIG_6(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 8, "LocalTimeStamp.new", 
    "    LocalTimeStamp.new()\n"
    "    LocalTimeStamp.new(int hour, int minute, int second, int millisecond)\n"
    "    LocalTimeStamp.new(int hour, int minute, int second)\n"
    "    LocalTimeStamp.new(int hour, int minute, int second, int fraction, int precision)\n"
    "    LocalTimeStamp.new(int hour, int minute, int second, int date, int month, int year)\n"
    "    LocalTimeStamp.new(int hour, int minute, int second, int millisecond, int date, int month, int year)\n"
    "    LocalTimeStamp.new(int hour, int minute, int second, int fraction, int date, int month, int year, int precision)\n"
    "    LocalTimeStamp.new(time_t time, int millisecond)\n"
    "    LocalTimeStamp.new(time_t time)\n"
    "    LocalTimeStamp.new(time_t time, int fraction, int precision)\n"
    "    LocalTimeStamp.new(tm const *time, int millisecond)\n"
    "    LocalTimeStamp.new(tm const *time)\n"
    "    LocalTimeStamp.new(tm const *time, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalTimeStamp_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::LocalTimeStamp *arg1 = (FIX::LocalTimeStamp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LocalTimeStamp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LocalTimeStamp *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LocalTimeStamp * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_LocalTimeStamp(void *self) {
    FIX::LocalTimeStamp *arg1 = (FIX::LocalTimeStamp *)self;
    delete arg1;
}

static swig_class SwigClassUtcTimeOnly;

SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","UtcTimeOnly", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","UtcTimeOnly", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly((FIX::DateTime const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1,arg2,arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_4(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1,arg2,arg3,arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_5(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_6(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_7(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_8(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly((tm const *)arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_9(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcTimeOnly_allocate(VALUE self)
#else
_wrap_UtcTimeOnly_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeOnly);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnly__SWIG_10(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnly";
  FIX::UtcTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnly *)new FIX::UtcTimeOnly((tm const *)arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeOnly(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UtcTimeOnly__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcTimeOnly__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcTimeOnly__SWIG_9(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_new_UtcTimeOnly__SWIG_6(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeOnly__SWIG_8(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeOnly__SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeOnly__SWIG_10(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeOnly__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeOnly__SWIG_7(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_UtcTimeOnly__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_UtcTimeOnly__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "UtcTimeOnly.new", 
    "    UtcTimeOnly.new()\n"
    "    UtcTimeOnly.new(FIX::DateTime const &val)\n"
    "    UtcTimeOnly.new(int hour, int minute, int second, int millisecond)\n"
    "    UtcTimeOnly.new(int hour, int minute, int second)\n"
    "    UtcTimeOnly.new(int hour, int minute, int second, int fraction, int precision)\n"
    "    UtcTimeOnly.new(time_t time, int millisecond)\n"
    "    UtcTimeOnly.new(time_t time)\n"
    "    UtcTimeOnly.new(time_t time, int fraction, int precision)\n"
    "    UtcTimeOnly.new(tm const *time, int millisecond)\n"
    "    UtcTimeOnly.new(tm const *time)\n"
    "    UtcTimeOnly.new(tm const *time, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeOnly_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnly *arg1 = (FIX::UtcTimeOnly *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnly, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnly *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnly * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeOnly(void *self) {
    FIX::UtcTimeOnly *arg1 = (FIX::UtcTimeOnly *)self;
    delete arg1;
}

static swig_class SwigClassLocalTimeOnly;

SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","LocalTimeOnly", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","LocalTimeOnly", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly((FIX::DateTime const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1,arg2,arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_4(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 5, argv[4] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1,arg2,arg3,arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_5(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_6(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_7(int argc, VALUE *argv, VALUE self) {
  time_t arg1 ;
  int arg2 ;
  int arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    if (NIL_P(argv[0]))
    arg1 = (time_t)-1;
    else
    arg1 = NUM2LONG(rb_funcall2(argv[0], rb_intern("tv_sec"), 0, 0));
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_8(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly((tm const *)arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_9(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_LocalTimeOnly_allocate(VALUE self)
#else
_wrap_LocalTimeOnly_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LocalTimeOnly);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_LocalTimeOnly__SWIG_10(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalTimeOnly";
  FIX::LocalTimeOnly *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalTimeOnly", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalTimeOnly", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalTimeOnly *)new FIX::LocalTimeOnly((tm const *)arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LocalTimeOnly(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LocalTimeOnly__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalTimeOnly__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalTimeOnly__SWIG_9(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      return _wrap_new_LocalTimeOnly__SWIG_6(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalTimeOnly__SWIG_8(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalTimeOnly__SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeOnly__SWIG_10(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeOnly__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      _v = (NIL_P(argv[0]) || TYPE(rb_funcall(argv[0], rb_intern("respond_to?"), 1, ID2SYM(rb_intern("tv_sec")))) == T_TRUE);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalTimeOnly__SWIG_7(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_LocalTimeOnly__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_LocalTimeOnly__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "LocalTimeOnly.new", 
    "    LocalTimeOnly.new()\n"
    "    LocalTimeOnly.new(FIX::DateTime const &val)\n"
    "    LocalTimeOnly.new(int hour, int minute, int second, int millisecond)\n"
    "    LocalTimeOnly.new(int hour, int minute, int second)\n"
    "    LocalTimeOnly.new(int hour, int minute, int second, int fraction, int precision)\n"
    "    LocalTimeOnly.new(time_t time, int millisecond)\n"
    "    LocalTimeOnly.new(time_t time)\n"
    "    LocalTimeOnly.new(time_t time, int fraction, int precision)\n"
    "    LocalTimeOnly.new(tm const *time, int millisecond)\n"
    "    LocalTimeOnly.new(tm const *time)\n"
    "    LocalTimeOnly.new(tm const *time, int fraction, int precision)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalTimeOnly_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::LocalTimeOnly *arg1 = (FIX::LocalTimeOnly *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LocalTimeOnly, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LocalTimeOnly *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LocalTimeOnly * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_LocalTimeOnly(void *self) {
    FIX::LocalTimeOnly *arg1 = (FIX::LocalTimeOnly *)self;
    delete arg1;
}

static swig_class SwigClassUtcDate;

SWIGINTERN VALUE
_wrap_new_UtcDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::UtcDate";
  FIX::UtcDate *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDate *)new FIX::UtcDate();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDate";
  FIX::UtcDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","UtcDate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","UtcDate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDate *)new FIX::UtcDate((FIX::DateTime const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcDate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDate";
  FIX::UtcDate *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcDate", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcDate", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcDate", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDate *)new FIX::UtcDate(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcDate__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDate";
  FIX::UtcDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcDate", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDate *)new FIX::UtcDate(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcDate_allocate(VALUE self)
#else
_wrap_UtcDate_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcDate);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcDate__SWIG_4(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDate";
  FIX::UtcDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","UtcDate", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDate *)new FIX::UtcDate((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UtcDate__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcDate__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UtcDate__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcDate__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcDate__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UtcDate.new", 
    "    UtcDate.new()\n"
    "    UtcDate.new(FIX::DateTime const &val)\n"
    "    UtcDate.new(int date, int month, int year)\n"
    "    UtcDate.new(int sec)\n"
    "    UtcDate.new(tm const *time)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcDate_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDate *arg1 = (FIX::UtcDate *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDate *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDate * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcDate(void *self) {
    FIX::UtcDate *arg1 = (FIX::UtcDate *)self;
    delete arg1;
}

static swig_class SwigClassLocalDate;

SWIGINTERN VALUE
_wrap_new_LocalDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::LocalDate";
  FIX::LocalDate *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalDate *)new FIX::LocalDate();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DateTime *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalDate";
  FIX::LocalDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DateTime,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DateTime const &","LocalDate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DateTime const &","LocalDate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DateTime * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalDate *)new FIX::LocalDate((FIX::DateTime const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalDate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalDate";
  FIX::LocalDate *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalDate", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","LocalDate", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","LocalDate", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalDate *)new FIX::LocalDate(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalDate__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalDate";
  FIX::LocalDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","LocalDate", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalDate *)new FIX::LocalDate(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_LocalDate_allocate(VALUE self)
#else
_wrap_LocalDate_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LocalDate);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_LocalDate__SWIG_4(int argc, VALUE *argv, VALUE self) {
  tm *arg1 = (tm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LocalDate";
  FIX::LocalDate *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_tm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "tm const *","LocalDate", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< tm * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::LocalDate *)new FIX::LocalDate((tm const *)arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LocalDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LocalDate__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalDate__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_tm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalDate__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_LocalDate__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_LocalDate__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "LocalDate.new", 
    "    LocalDate.new()\n"
    "    LocalDate.new(FIX::DateTime const &val)\n"
    "    LocalDate.new(int date, int month, int year)\n"
    "    LocalDate.new(int sec)\n"
    "    LocalDate.new(tm const *time)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalDate_setCurrent(int argc, VALUE *argv, VALUE self) {
  FIX::LocalDate *arg1 = (FIX::LocalDate *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LocalDate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LocalDate *","setCurrent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LocalDate * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCurrent();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_LocalDate(void *self) {
    FIX::LocalDate *arg1 = (FIX::LocalDate *)self;
    delete arg1;
}

static swig_class SwigClassFieldBase;

SWIGINTERN VALUE
_wrap_new_FieldBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldBase";
  FIX::FieldBase *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FieldBase", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FieldBase", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FieldBase", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldBase *)new FIX::FieldBase(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldBase(void *self) {
    FIX::FieldBase *arg1 = (FIX::FieldBase *)self;
    delete arg1;
}

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FieldBase_allocate(VALUE self)
#else
_wrap_FieldBase_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FieldBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldBase";
  FIX::FieldBase *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FieldBase", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FieldBase", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldBase *)new FIX::FieldBase((FIX::FieldBase const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldBase__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FieldBase__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldBase.new", 
    "    FieldBase.new(int tag, std::string const &string)\n"
    "    FieldBase.new(FIX::FieldBase const &rhs)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_swap(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->swap(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_setTag(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","setTag", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setTag", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setTag(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_setField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_setString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getTag(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getTag", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldBase const *)arg1)->getTag();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldBase const *)arg1)->getField();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::FieldBase const *)arg1)->getString();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getFixString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getFixString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::FieldBase const *)arg1)->getFixString();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getLength(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldBase const *)arg1)->getLength();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getTotal(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldBase const *)arg1)->getTotal();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FieldBase.<

  call-seq:
    <(field) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_FieldBase___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldBase const *)arg1)->operator <((FIX::FieldBase const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase___str__(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX_FieldBase___str__(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream &
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(arg0, arg1) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::ostream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::ostream *) &FIX::operator <<(*arg1,(FIX::FieldBase const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_swap(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase &","FIX::swap", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","FIX::swap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase &","FIX::swap", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","FIX::swap", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      FIX::swap(*arg1,*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassStringField;

SWIGINTERN VALUE
_wrap_new_StringField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::StringField";
  FIX::StringField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","StringField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","StringField", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","StringField", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::StringField *)new FIX::StringField(arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_StringField_allocate(VALUE self)
#else
_wrap_StringField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__StringField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_StringField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::StringField";
  FIX::StringField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","StringField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::StringField *)new FIX::StringField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_StringField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_StringField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_StringField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StringField.new", 
    "    StringField.new(int field, std::string const &data)\n"
    "    StringField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setValue", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setValue", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::StringField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::StringField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::StringField const *)arg1)->operator <((FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::StringField.>

  call-seq:
    >(rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___gt__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::StringField const *)arg1)->operator >((FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::StringField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::StringField const *)arg1)->operator ==((FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::StringField.<=

  call-seq:
    <=(rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___le__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::StringField const *)arg1)->operator <=((FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::StringField.>=

  call-seq:
    >=(rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___ge__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::StringField const *)arg1)->operator >=((FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_StringField(void *self) {
    FIX::StringField *arg1 = (FIX::StringField *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator <", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((FIX::StringField const &)*arg1,(char const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___lt____SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator <", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((char const *)arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>

  call-seq:
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap___gt____SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator >", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >((FIX::StringField const &)*arg1,(char const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___gt____SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator >", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >((char const *)arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator ==", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((FIX::StringField const &)*arg1,(char const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___eq____SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator ==", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((char const *)arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<=

  call-seq:
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___le____SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator <=", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <=((FIX::StringField const &)*arg1,(char const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___le____SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator <=", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <=((char const *)arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>=

  call-seq:
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___ge____SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator >=", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >=((FIX::StringField const &)*arg1,(char const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___ge____SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator >=", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >=((char const *)arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((FIX::StringField const &)*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___lt____SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((std::string const &)*arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>

  call-seq:
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap___gt____SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >((FIX::StringField const &)*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___gt____SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >((std::string const &)*arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___gt__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__gt__", 
    "    bool __gt__(FIX::DateTime const &lhs, FIX::DateTime const &rhs)\n"
    "    bool __gt__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __gt__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __gt__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __gt__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator ==", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator ==", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((FIX::StringField const &)*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___eq____SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator ==", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator ==", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((std::string const &)*arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<=

  call-seq:
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___le____SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <=", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <=", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <=((FIX::StringField const &)*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___le____SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <=", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <=", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <=((std::string const &)*arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___le__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__le__", 
    "    bool __le__(FIX::DateTime const &lhs, FIX::DateTime const &rhs)\n"
    "    bool __le__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __le__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __le__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __le__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>=

  call-seq:
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___ge____SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >=", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >=", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >=((FIX::StringField const &)*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___ge____SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >=", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >=", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator >=((std::string const &)*arg1,(FIX::StringField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___ge__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__ge__", 
    "    bool __ge__(FIX::DateTime const &lhs, FIX::DateTime const &rhs)\n"
    "    bool __ge__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __ge__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __ge__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __ge__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}


static swig_class SwigClassCharField;

SWIGINTERN VALUE
_wrap_new_CharField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CharField";
  FIX::CharField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","CharField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","CharField", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::CharField *)new FIX::CharField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_CharField_allocate(VALUE self)
#else
_wrap_CharField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CharField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_CharField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CharField";
  FIX::CharField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","CharField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::CharField *)new FIX::CharField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CharField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CharField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CharField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CharField.new", 
    "    CharField.new(int field, char data)\n"
    "    CharField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CharField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::CharField *arg1 = (FIX::CharField *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CharField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CharField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CharField * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CharField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::CharField *arg1 = (FIX::CharField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CharField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CharField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CharField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (char)((FIX::CharField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_CharField(void *self) {
    FIX::CharField *arg1 = (FIX::CharField *)self;
    delete arg1;
}

static swig_class SwigClassDoubleField;

SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  double arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  FIX::DoubleField *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","DoubleField", 2, argv[1] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","DoubleField", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DoubleField *)new FIX::DoubleField(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  double arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  FIX::DoubleField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","DoubleField", 2, argv[1] ));
  } 
  arg2 = static_cast< double >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DoubleField *)new FIX::DoubleField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DoubleField_allocate(VALUE self)
#else
_wrap_DoubleField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DoubleField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  FIX::DoubleField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DoubleField *)new FIX::DoubleField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DoubleField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_DoubleField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_DoubleField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_DoubleField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "DoubleField.new", 
    "    DoubleField.new(int field, double data, int padding)\n"
    "    DoubleField.new(int field, double data)\n"
    "    DoubleField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_setValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  double arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setValue", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_setValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DoubleField_setValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DoubleField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DoubleField_setValue__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DoubleField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DoubleField_setValue__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DoubleField.setValue", 
    "    void DoubleField.setValue(double value, int padding)\n"
    "    void DoubleField.setValue(double value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (double)((FIX::DoubleField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_DoubleField(void *self) {
    FIX::DoubleField *arg1 = (FIX::DoubleField *)self;
    delete arg1;
}

static swig_class SwigClassIntField;

SWIGINTERN VALUE
_wrap_new_IntField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntField";
  FIX::IntField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IntField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IntField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IntField *)new FIX::IntField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_IntField_allocate(VALUE self)
#else
_wrap_IntField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IntField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_IntField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntField";
  FIX::IntField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","IntField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::IntField *)new FIX::IntField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IntField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IntField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_IntField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IntField.new", 
    "    IntField.new(int field, int data)\n"
    "    IntField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::IntField *arg1 = (FIX::IntField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IntField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IntField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IntField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::IntField *arg1 = (FIX::IntField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IntField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IntField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IntField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::IntField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IntField(void *self) {
    FIX::IntField *arg1 = (FIX::IntField *)self;
    delete arg1;
}

static swig_class SwigClassBoolField;

SWIGINTERN VALUE
_wrap_new_BoolField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BoolField";
  FIX::BoolField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","BoolField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","BoolField", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::BoolField *)new FIX::BoolField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_BoolField_allocate(VALUE self)
#else
_wrap_BoolField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__BoolField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_BoolField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BoolField";
  FIX::BoolField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","BoolField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::BoolField *)new FIX::BoolField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_BoolField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_BoolField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_BoolField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "BoolField.new", 
    "    BoolField.new(int field, bool data)\n"
    "    BoolField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BoolField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::BoolField *arg1 = (FIX::BoolField *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__BoolField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::BoolField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::BoolField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BoolField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::BoolField *arg1 = (FIX::BoolField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__BoolField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::BoolField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::BoolField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::BoolField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_BoolField(void *self) {
    FIX::BoolField *arg1 = (FIX::BoolField *)self;
    delete arg1;
}

static swig_class SwigClassUtcTimeStampField;

SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  FIX::UtcTimeStampField *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","UtcTimeStampField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","UtcTimeStampField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,(FIX::UtcTimeStamp const &)*arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  FIX::UtcTimeStampField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","UtcTimeStampField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","UtcTimeStampField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,(FIX::UtcTimeStamp const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  FIX::UtcTimeStampField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcTimeStampField_allocate(VALUE self)
#else
_wrap_UtcTimeStampField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeStampField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  FIX::UtcTimeStampField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeStampField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcTimeStampField__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcTimeStampField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeStampField__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeStampField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UtcTimeStampField.new", 
    "    UtcTimeStampField.new(int field, FIX::UtcTimeStamp const &data, int precision)\n"
    "    UtcTimeStampField.new(int field, FIX::UtcTimeStamp const &data)\n"
    "    UtcTimeStampField.new(int field, int precision)\n"
    "    UtcTimeStampField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeStampField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeStampField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::UtcTimeStampField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcTimeStampField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeStampField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  FIX::UtcTimeStampField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStampField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStampField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStampField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcTimeStampField const *)arg1)->operator <((FIX::UtcTimeStampField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcTimeStampField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeStampField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  FIX::UtcTimeStampField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStampField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStampField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStampField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcTimeStampField const *)arg1)->operator ==((FIX::UtcTimeStampField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeStampField(void *self) {
    FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *)self;
    delete arg1;
}

static swig_class SwigClassUtcDateField;

SWIGINTERN VALUE
_wrap_new_UtcDateField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcDate *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDateField";
  FIX::UtcDateField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcDateField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__UtcDate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDate const &","UtcDateField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDate const &","UtcDateField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDate * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDateField *)new FIX::UtcDateField(arg1,(FIX::UtcDate const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcDateField_allocate(VALUE self)
#else
_wrap_UtcDateField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcDateField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcDateField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDateField";
  FIX::UtcDateField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcDateField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcDateField *)new FIX::UtcDateField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcDateField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcDateField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcDate, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcDateField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "UtcDateField.new", 
    "    UtcDateField.new(int field, FIX::UtcDate const &data)\n"
    "    UtcDateField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcDateField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  FIX::UtcDate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcDate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDate const &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDate const &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDate * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue((FIX::UtcDate const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcDateField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcDate result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::UtcDateField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcDate(result)), SWIGTYPE_p_FIX__UtcDate, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcDateField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcDateField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  FIX::UtcDateField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcDateField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDateField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDateField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDateField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcDateField const *)arg1)->operator <((FIX::UtcDateField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcDateField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcDateField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  FIX::UtcDateField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcDateField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDateField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDateField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDateField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcDateField const *)arg1)->operator ==((FIX::UtcDateField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcDateField(void *self) {
    FIX::UtcDateField *arg1 = (FIX::UtcDateField *)self;
    delete arg1;
}

static swig_class SwigClassUtcTimeOnlyField;

SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeOnly *arg2 = 0 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  FIX::UtcTimeOnlyField *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnly const &","UtcTimeOnlyField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnly const &","UtcTimeOnlyField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnly * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,(FIX::UtcTimeOnly const &)*arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeOnly *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  FIX::UtcTimeOnlyField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnly const &","UtcTimeOnlyField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnly const &","UtcTimeOnlyField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnly * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,(FIX::UtcTimeOnly const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  FIX::UtcTimeOnlyField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_UtcTimeOnlyField_allocate(VALUE self)
#else
_wrap_UtcTimeOnlyField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeOnlyField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  FIX::UtcTimeOnlyField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeOnlyField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcTimeOnlyField__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcTimeOnly, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcTimeOnlyField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeOnlyField__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcTimeOnly, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeOnlyField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UtcTimeOnlyField.new", 
    "    UtcTimeOnlyField.new(int field, FIX::UtcTimeOnly const &data, int precision)\n"
    "    UtcTimeOnlyField.new(int field, FIX::UtcTimeOnly const &data)\n"
    "    UtcTimeOnlyField.new(int field, int precision)\n"
    "    UtcTimeOnlyField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeOnlyField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  FIX::UtcTimeOnly *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnly const &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnly const &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnly * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue((FIX::UtcTimeOnly const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeOnlyField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeOnly result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::UtcTimeOnlyField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeOnly(result)), SWIGTYPE_p_FIX__UtcTimeOnly, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcTimeOnlyField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeOnlyField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  FIX::UtcTimeOnlyField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeOnlyField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnlyField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcTimeOnlyField const *)arg1)->operator <((FIX::UtcTimeOnlyField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::UtcTimeOnlyField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeOnlyField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  FIX::UtcTimeOnlyField *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeOnlyField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnlyField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::UtcTimeOnlyField const *)arg1)->operator ==((FIX::UtcTimeOnlyField const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeOnlyField(void *self) {
    FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *)self;
    delete arg1;
}

static swig_class SwigClassCheckSumField;

SWIGINTERN VALUE
_wrap_new_CheckSumField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CheckSumField";
  FIX::CheckSumField *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","CheckSumField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","CheckSumField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::CheckSumField *)new FIX::CheckSumField(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_CheckSumField_allocate(VALUE self)
#else
_wrap_CheckSumField_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CheckSumField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_CheckSumField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CheckSumField";
  FIX::CheckSumField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","CheckSumField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::CheckSumField *)new FIX::CheckSumField(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CheckSumField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CheckSumField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CheckSumField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CheckSumField.new", 
    "    CheckSumField.new(int field, int data)\n"
    "    CheckSumField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CheckSumField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::CheckSumField *arg1 = (FIX::CheckSumField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CheckSumField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CheckSumField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CheckSumField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CheckSumField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::CheckSumField *arg1 = (FIX::CheckSumField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CheckSumField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CheckSumField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CheckSumField * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::CheckSumField const *)arg1)->getValue();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_CheckSumField(void *self) {
    FIX::CheckSumField *arg1 = (FIX::CheckSumField *)self;
    delete arg1;
}

static swig_class SwigClassFieldMap;

SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  FIX::FieldMap *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","FieldMap", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","FieldMap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)new FIX::FieldMap((message_order const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  FIX::FieldMap *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)new FIX::FieldMap();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int *arg1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  FIX::FieldMap *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "int const []","FieldMap", 1, argv[0] )); 
  } 
  arg1 = reinterpret_cast< int * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)new FIX::FieldMap((int const (*))arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  FIX::FieldMap *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const &","FieldMap", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","FieldMap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)new FIX::FieldMap((FIX::FieldMap const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FieldMap_allocate(VALUE self)
#else
_wrap_FieldMap_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::unique_ptr< FIX::FieldMap > rvrdeleter1 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  FIX::FieldMap *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldMap, SWIG_POINTER_RELEASE |  0 );
  if (!SWIG_IsOK(res1)) {
    if (res1 == SWIG_ERROR_RELEASE_NOT_OWNED) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldMap" "', cannot release ownership as memory is not owned for argument " "1"" of type '" "FIX::FieldMap &&""'");
    } else {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap &&","FieldMap", 1, argv[0] )); 
    }
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &&","FieldMap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  rvrdeleter1.reset(arg1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)new FIX::FieldMap((FIX::FieldMap &&)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldMap__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_int, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_5(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FieldMap.new", 
    "    FieldMap.new(message_order const &order)\n"
    "    FieldMap.new()\n"
    "    FieldMap.new(int const order[])\n"
    "    FieldMap.new(FIX::FieldMap const &copy)\n"
    "    FieldMap.new(FIX::FieldMap &&rhs)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldMap(void *self) {
    FIX::FieldMap *arg1 = (FIX::FieldMap *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setField((FIX::FieldBase const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setField((FIX::FieldBase const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","setField", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setField", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setField(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_setField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_setField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_setField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FieldMap_setField__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.setField", 
    "    void FieldMap.setField(FIX::FieldBase const &field, bool overwrite)\n"
    "    void FieldMap.setField(FIX::FieldBase const &field)\n"
    "    void FieldMap.setField(int tag, std::string const &value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getFieldIfSet(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getFieldIfSet", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase &","getFieldIfSet", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","getFieldIfSet", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldMap const *)arg1)->getFieldIfSet(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::FieldBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase &","getField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","getField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldBase *) &((FIX::FieldMap const *)arg1)->getField(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::FieldMap const *)arg1)->getField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_getField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_getField__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_getField__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.getField", 
    "    FIX::FieldBase FieldMap.getField(FIX::FieldBase &field)\n"
    "    std::string const & FieldMap.getField(int tag)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getFieldRef(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  FIX::FieldBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getFieldRef", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldRef", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldBase *) &((FIX::FieldMap const *)arg1)->getFieldRef(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getFieldPtr(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  FIX::FieldBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getFieldPtr", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldPtr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldBase *)((FIX::FieldMap const *)arg1)->getFieldPtr(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isSetField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","isSetField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","isSetField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","isSetField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldMap const *)arg1)->isSetField((FIX::FieldBase const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isSetField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","isSetField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isSetField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldMap const *)arg1)->isSetField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_isSetField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_isSetField__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_isSetField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.isSetField", 
    "    bool FieldMap.isSetField(FIX::FieldBase const &field)\n"
    "    bool FieldMap.isSetField(int tag)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap const &","addGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","addGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","addGroup", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup(arg2,(FIX::FieldMap const &)*arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap const &","addGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","addGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup(arg2,(FIX::FieldMap const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_addGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FieldMap_addGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FieldMap_addGroup__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FieldMap.addGroup", 
    "    void FieldMap.addGroup(int tag, FIX::FieldMap const &group, bool setCount)\n"
    "    void FieldMap.addGroup(int tag, FIX::FieldMap const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroupPtr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = (FIX::FieldMap *) 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroupPtr", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroupPtr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroupPtr", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","addGroupPtr", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroupPtr(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroupPtr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroupPtr", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroupPtr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroupPtr", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroupPtr(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_addGroupPtr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FieldMap_addGroupPtr__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FieldMap_addGroupPtr__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FieldMap.addGroupPtr", 
    "    void FieldMap.addGroupPtr(int tag, FIX::FieldMap *group, bool setCount)\n"
    "    void FieldMap.addGroupPtr(int tag, FIX::FieldMap *group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  FIX::FieldMap *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","replaceGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::FieldMap const &","replaceGroup", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","replaceGroup", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::FieldMap * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->replaceGroup(arg2,arg3,(FIX::FieldMap const &)*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  FIX::FieldMap *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  FIX::FieldMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::FieldMap &","getGroup", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &","getGroup", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::FieldMap * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *) &((FIX::FieldMap const *)arg1)->getGroup(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getGroupRef(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  FIX::FieldMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getGroupRef", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getGroupRef", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroupRef", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *) &((FIX::FieldMap const *)arg1)->getGroupRef(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getGroupPtr(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  FIX::FieldMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getGroupPtr", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getGroupPtr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroupPtr", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap *)((FIX::FieldMap const *)arg1)->getGroupPtr(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_groups(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::FieldMap::Groups *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","groups", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FieldMap::Groups *) &((FIX::FieldMap const *)arg1)->groups();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","removeGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.removeGroup", 
    "    void FieldMap.removeGroup(int num, int tag)\n"
    "    void FieldMap.removeGroup(int tag)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldMap const *)arg1)->hasGroup(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","hasGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::FieldMap const *)arg1)->hasGroup(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.hasGroup", 
    "    bool FieldMap.hasGroup(int tag)\n"
    "    bool FieldMap.hasGroup(int num, int tag)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_groupCount(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","groupCount", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","groupCount", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->groupCount(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FieldMap.clear

  call-seq:
    clear

Clear FieldMap contents.
*/
SWIGINTERN VALUE
_wrap_FieldMap_clear(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isEmpty(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isEmpty();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_totalFields(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","totalFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->totalFields();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::FieldMap const *)arg1)->calculateString(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","calculateLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","calculateLength", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","calculateLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateLength();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_calculateLength(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_calculateLength__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_calculateLength__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_calculateLength__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FieldMap_calculateLength__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FieldMap.calculateLength", 
    "    int FieldMap.calculateLength(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    int FieldMap.calculateLength(int beginStringField, int bodyLengthField)\n"
    "    int FieldMap.calculateLength(int beginStringField)\n"
    "    int FieldMap.calculateLength()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateTotal__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateTotal", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateTotal(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateTotal__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FieldMap const *)arg1)->calculateTotal();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_calculateTotal(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_calculateTotal__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_calculateTotal__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.calculateTotal", 
    "    int FieldMap.calculateTotal(int checkSumField)\n"
    "    int FieldMap.calculateTotal()\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FieldMap.begin

  call-seq:
    begin -> FIX::FieldMap::iterator
    begin -> FIX::FieldMap::const_iterator

Return an iterator to the beginning of the FieldMap.
*/
SWIGINTERN VALUE
_wrap_FieldMap_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::iterator(result)), SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FieldMap.end

  call-seq:
    end -> FIX::FieldMap::iterator
    end -> FIX::FieldMap::const_iterator

Return an iterator to past the end of the FieldMap.
*/
SWIGINTERN VALUE
_wrap_FieldMap_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::iterator(result)), SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FieldMap.begin

  call-seq:
    begin -> FIX::FieldMap::iterator
    begin -> FIX::FieldMap::const_iterator

Return an iterator to the beginning of the FieldMap.
*/
SWIGINTERN VALUE
_wrap_FieldMap_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::const_iterator(result)), SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_begin(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_begin__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_begin__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldMap.begin", 
    "    FIX::FieldMap::iterator FieldMap.begin()\n"
    "    FIX::FieldMap::const_iterator FieldMap.begin()\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FieldMap.end

  call-seq:
    end -> FIX::FieldMap::iterator
    end -> FIX::FieldMap::const_iterator

Return an iterator to past the end of the FieldMap.
*/
SWIGINTERN VALUE
_wrap_FieldMap_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::const_iterator(result)), SWIGTYPE_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_end(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_end__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_end__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldMap.end", 
    "    FIX::FieldMap::iterator FieldMap.end()\n"
    "    FIX::FieldMap::const_iterator FieldMap.end()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","g_begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->g_begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_iterator(result)), SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","g_end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->g_end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_iterator(result)), SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","g_begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->g_begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_const_iterator(result)), SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_g_begin(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_g_begin__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_g_begin__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldMap.g_begin", 
    "    FIX::FieldMap::g_iterator FieldMap.g_begin()\n"
    "    FIX::FieldMap::g_const_iterator FieldMap.g_begin()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","g_end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FieldMap const *)arg1)->g_end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_const_iterator(result)), SWIGTYPE_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_g_end(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_g_end__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_g_end__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldMap.g_end", 
    "    FIX::FieldMap::g_iterator FieldMap.g_end()\n"
    "    FIX::FieldMap::g_const_iterator FieldMap.g_end()\n");
  
  return Qnil;
}


static swig_class SwigClassHeader;

SWIGINTERN VALUE
_wrap_new_Header__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::Header";
  FIX::Header *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Header *)new FIX::Header();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Header_allocate(VALUE self)
#else
_wrap_Header_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Header);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Header__SWIG_1(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Header";
  FIX::Header *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Header", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Header", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Header *)new FIX::Header((message_order const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Header(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Header__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Header__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Header.new", 
    "    Header.new()\n"
    "    Header.new(message_order const &order)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->replaceGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Group *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (Group *) &((FIX::Header const *)arg1)->getGroup(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Header_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Header, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Header_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Header, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Header_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Header.removeGroup", 
    "    void Header.removeGroup(unsigned int num, FIX::Group const &group)\n"
    "    void Header.removeGroup(FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Header const *)arg1)->hasGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Header_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Header *arg1 = (FIX::Header *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Header, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Header const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Header * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Header const *)arg1)->hasGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Header_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Header, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Header_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Header, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Header_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Header.hasGroup", 
    "    bool Header.hasGroup(FIX::Group const &group)\n"
    "    bool Header.hasGroup(unsigned int num, FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Header(void *self) {
    FIX::Header *arg1 = (FIX::Header *)self;
    delete arg1;
}

static swig_class SwigClassTrailer;

SWIGINTERN VALUE
_wrap_new_Trailer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::Trailer";
  FIX::Trailer *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Trailer *)new FIX::Trailer();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Trailer_allocate(VALUE self)
#else
_wrap_Trailer_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Trailer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Trailer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Trailer";
  FIX::Trailer *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Trailer", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Trailer", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Trailer *)new FIX::Trailer((message_order const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Trailer(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Trailer__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trailer__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Trailer.new", 
    "    Trailer.new()\n"
    "    Trailer.new(message_order const &order)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->replaceGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Group *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (Group *) &((FIX::Trailer const *)arg1)->getGroup(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Trailer_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Trailer, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Trailer_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Trailer, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Trailer_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Trailer.removeGroup", 
    "    void Trailer.removeGroup(unsigned int num, FIX::Group const &group)\n"
    "    void Trailer.removeGroup(FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Trailer const *)arg1)->hasGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trailer_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Trailer *arg1 = (FIX::Trailer *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Trailer const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Trailer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Trailer const *)arg1)->hasGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Trailer_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Trailer, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Trailer_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Trailer, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Trailer_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Trailer.hasGroup", 
    "    bool Trailer.hasGroup(FIX::Group const &group)\n"
    "    bool Trailer.hasGroup(unsigned int num, FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Trailer(void *self) {
    FIX::Trailer *arg1 = (FIX::Trailer *)self;
    delete arg1;
}

static swig_class SwigClassMessage;

SWIGINTERN VALUE
_wrap_new_Message__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_1(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  message_order *arg2 = 0 ;
  message_order *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "message_order const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< message_order * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((message_order const &)*arg1,(message_order const &)*arg2,(message_order const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Message", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  bool arg3 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","Message", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_6(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  FIX::DataDictionary *arg3 = 0 ;
  bool arg4 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::DataDictionary * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","Message", 4, argv[3] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2,(FIX::DataDictionary const &)*arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_7(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  FIX::DataDictionary *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::DataDictionary * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2,(FIX::DataDictionary const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_8(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  message_order *arg2 = 0 ;
  message_order *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::DataDictionary *arg5 = 0 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "message_order const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< message_order * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","Message", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  ecode6 = SWIG_AsVal_bool(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "bool","Message", 6, argv[5] ));
  } 
  arg6 = static_cast< bool >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((message_order const &)*arg1,(message_order const &)*arg2,(message_order const &)*arg3,(std::string const &)*arg4,(FIX::DataDictionary const &)*arg5,arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_9(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  message_order *arg2 = 0 ;
  message_order *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::DataDictionary *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "message_order const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< message_order * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","Message", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((message_order const &)*arg1,(message_order const &)*arg2,(message_order const &)*arg3,(std::string const &)*arg4,(FIX::DataDictionary const &)*arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_10(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  message_order *arg2 = 0 ;
  message_order *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::DataDictionary *arg5 = 0 ;
  FIX::DataDictionary *arg6 = 0 ;
  bool arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "message_order const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< message_order * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","Message", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 6, argv[5] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 6, argv[5])); 
  }
  arg6 = reinterpret_cast< FIX::DataDictionary * >(argp6);
  ecode7 = SWIG_AsVal_bool(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "bool","Message", 7, argv[6] ));
  } 
  arg7 = static_cast< bool >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((message_order const &)*arg1,(message_order const &)*arg2,(message_order const &)*arg3,(std::string const &)*arg4,(FIX::DataDictionary const &)*arg5,(FIX::DataDictionary const &)*arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_11(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  message_order *arg2 = 0 ;
  message_order *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::DataDictionary *arg5 = 0 ;
  FIX::DataDictionary *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "message_order const &","Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< message_order * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Message", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Message", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","Message", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Message", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","Message", 6, argv[5] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","Message", 6, argv[5])); 
  }
  arg6 = reinterpret_cast< FIX::DataDictionary * >(argp6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((message_order const &)*arg1,(message_order const &)*arg2,(message_order const &)*arg3,(std::string const &)*arg4,(FIX::DataDictionary const &)*arg5,(FIX::DataDictionary const &)*arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_12(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const &","Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((FIX::Message const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Message_allocate(VALUE self)
#else
_wrap_Message_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Message);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_13(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::unique_ptr< FIX::Message > rvrdeleter1 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  FIX::Message *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message, SWIG_POINTER_RELEASE |  0 );
  if (!SWIG_IsOK(res1)) {
    if (res1 == SWIG_ERROR_RELEASE_NOT_OWNED) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Message" "', cannot release ownership as memory is not owned for argument " "1"" of type '" "FIX::Message &&""'");
    } else {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &&","Message", 1, argv[0] )); 
    }
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &&","Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  rvrdeleter1.reset(arg1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Message *)new FIX::Message((FIX::Message &&)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Message(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs;
  if (argc > 7) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Message__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Message__SWIG_12(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Message__SWIG_13(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Message__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Message__SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Message__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Message__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Message__SWIG_7(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Message__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_Message__SWIG_6(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_Message__SWIG_9(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_new_Message__SWIG_11(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_bool(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_Message__SWIG_8(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_bool(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_Message__SWIG_10(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "Message.new", 
    "    Message.new()\n"
    "    Message.new(message_order const &hdrOrder, message_order const &trlOrder, message_order const &order)\n"
    "    Message.new(std::string const &string, bool validate)\n"
    "    Message.new(std::string const &string)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &dataDictionary, bool validate)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &dataDictionary)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &sessionDataDictionary, FIX::DataDictionary const &applicationDataDictionary, bool validate)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &sessionDataDictionary, FIX::DataDictionary const &applicationDataDictionary)\n"
    "    Message.new(message_order const &headerOrder, message_order const &trailerOrder, message_order const &order, std::string const &string, FIX::DataDictionary const &dataDictionary, bool validate)\n"
    "    Message.new(message_order const &headerOrder, message_order const &trailerOrder, message_order const &order, std::string const &string, FIX::DataDictionary const &dataDictionary)\n"
    "    Message.new(message_order const &headerOrder, message_order const &trailerOrder, message_order const &order, std::string const &string, FIX::DataDictionary const &sessionDataDictionary, FIX::DataDictionary const &applicationDataDictionary, bool validate)\n"
    "    Message.new(message_order const &headerOrder, message_order const &trailerOrder, message_order const &order, std::string const &string, FIX::DataDictionary const &sessionDataDictionary, FIX::DataDictionary const &applicationDataDictionary)\n"
    "    Message.new(FIX::Message const &)\n"
    "    Message.new(FIX::Message &&)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Message(void *self) {
    FIX::Message *arg1 = (FIX::Message *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Message_InitializeXML(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message::InitializeXML", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message::InitializeXML", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::InitializeXML((std::string const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->replaceGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Group *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (Group *) &((FIX::Message const *)arg1)->getGroup(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Message_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Message.removeGroup", 
    "    void Message.removeGroup(unsigned int num, FIX::Group const &group)\n"
    "    void Message.removeGroup(FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Message const *)arg1)->hasGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Message const *)arg1)->hasGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Message_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Message.hasGroup", 
    "    bool Message.hasGroup(FIX::Group const &group)\n"
    "    bool Message.hasGroup(unsigned int num, FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->toString(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->toString(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->toString(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->toString();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","toString", 5, argv[3] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::Message const *)arg1)->toString(*arg2,arg3,arg4,arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::Message const *)arg1)->toString(*arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::Message const *)arg1)->toString(*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_7(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::Message const *)arg1)->toString(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_toString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_toString__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_toString__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_toString__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_toString__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_toString__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_toString__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_toString__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_Message_toString__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "Message.toString", 
    "    std::string Message.toString(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    std::string Message.toString(int beginStringField, int bodyLengthField)\n"
    "    std::string Message.toString(int beginStringField)\n"
    "    std::string Message.toString()\n"
    "    std::string Message.toString(std::string &, int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    std::string Message.toString(std::string &, int beginStringField, int bodyLengthField)\n"
    "    std::string Message.toString(std::string &, int beginStringField)\n"
    "    std::string & Message.toString(std::string &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toXML__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toXML", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->toXML();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toXML__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toXML", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::Message const *)arg1)->toXML(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_toXML(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_toXML__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_toXML__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.toXML", 
    "    std::string Message.toXML()\n"
    "    std::string & Message.toXML(std::string &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_reverseRoute(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Header *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","reverseRoute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Header,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Header const &","reverseRoute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Header const &","reverseRoute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Header * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reverseRoute((FIX::Header const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  FIX::DataDictionary *arg4 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","setString", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< FIX::DataDictionary * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2,arg3,(FIX::DataDictionary const *)arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  FIX::DataDictionary *arg4 = (FIX::DataDictionary *) 0 ;
  FIX::DataDictionary *arg5 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","setString", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< FIX::DataDictionary * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","setString", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2,arg3,(FIX::DataDictionary const *)arg4,(FIX::DataDictionary const *)arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_setString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_setString__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_setString__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Message_setString__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_Message_setString__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "Message.setString", 
    "    void Message.setString(std::string const &string)\n"
    "    void Message.setString(std::string const &string, bool validate)\n"
    "    void Message.setString(std::string const &string, bool validate, FIX::DataDictionary const *pDataDictionary)\n"
    "    void Message.setString(std::string const &string, bool validate, FIX::DataDictionary const *pSessionDataDictionary, FIX::DataDictionary const *pApplicationDataDictionary)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  FIX::FieldBase *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string::size_type *arg5 = 0 ;
  FIX::FieldMap *arg6 = 0 ;
  DataDictionary *arg7 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldBase * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","setGroup", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setGroup", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_std__string__size_type,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string::size_type &","setGroup", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string::size_type &","setGroup", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< std::string::size_type * >(argp5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::FieldMap &","setGroup", 6, argv[4] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &","setGroup", 6, argv[4])); 
  }
  arg6 = reinterpret_cast< FIX::FieldMap * >(argp6);
  res7 = SWIG_ConvertPtr(argv[5], &argp7, SWIGTYPE_p_DataDictionary,  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), Ruby_Format_TypeError( "", "DataDictionary const &","setGroup", 7, argv[5] )); 
  }
  if (!argp7) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionary const &","setGroup", 7, argv[5])); 
  }
  arg7 = reinterpret_cast< DataDictionary * >(argp7);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setGroup((std::string const &)*arg2,(FIX::FieldBase const &)*arg3,(std::string const &)*arg4,*arg5,*arg6,(DataDictionary const &)*arg7);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setStringHeader(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setStringHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setStringHeader", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setStringHeader", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->setStringHeader((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getHeader__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Header *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Header *) &((FIX::Message const *)arg1)->getHeader();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Header, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getHeader__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Header *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Header *) &(arg1)->getHeader();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Header, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getHeader(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getHeader__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getHeader__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.getHeader", 
    "    FIX::Header const Message.getHeader()\n"
    "    FIX::Header & Message.getHeader()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getTrailer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Trailer *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getTrailer", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Trailer *) &((FIX::Message const *)arg1)->getTrailer();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getTrailer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Trailer *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getTrailer", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Trailer *) &(arg1)->getTrailer();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Trailer, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getTrailer(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getTrailer__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getTrailer__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.getTrailer", 
    "    FIX::Trailer const Message.getTrailer()\n"
    "    FIX::Trailer & Message.getTrailer()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasValidStructure(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","hasValidStructure", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = NUM2INT(argv[0]);
    arg2 = &temp2;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Message const *)arg1)->hasValidStructure(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg2)) : Qnil;
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","bodyLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","bodyLength", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->bodyLength(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","bodyLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->bodyLength(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->bodyLength(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->bodyLength();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_bodyLength(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_bodyLength__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_bodyLength__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_bodyLength__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_bodyLength__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "Message.bodyLength", 
    "    int Message.bodyLength(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    int Message.bodyLength(int beginStringField, int bodyLengthField)\n"
    "    int Message.bodyLength(int beginStringField)\n"
    "    int Message.bodyLength()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_checkSum__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","checkSum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","checkSum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->checkSum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_checkSum__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","checkSum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Message const *)arg1)->checkSum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_checkSum(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_checkSum__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_checkSum__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.checkSum", 
    "    int Message.checkSum(int checkSumField)\n"
    "    int Message.checkSum()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","isAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Message const *)arg1)->isAdmin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isApp(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","isApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Message const *)arg1)->isApp();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isEmpty(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isEmpty();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Message.clear

  call-seq:
    clear

Clear Message contents.
*/
SWIGINTERN VALUE
_wrap_Message_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isAdminMsgType(int argc, VALUE *argv, VALUE self) {
  MsgType *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_MsgType,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MsgType const &","FIX::Message::isAdminMsgType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "MsgType const &","FIX::Message::isAdminMsgType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< MsgType * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isAdminMsgType((MsgType const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toApplVerID(int argc, VALUE *argv, VALUE self) {
  BeginString *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ApplVerID result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_BeginString,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "BeginString const &","FIX::Message::toApplVerID", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "BeginString const &","FIX::Message::toApplVerID", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< BeginString * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::Message::toApplVerID((BeginString const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new ApplVerID(result)), SWIGTYPE_p_ApplVerID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toBeginString(int argc, VALUE *argv, VALUE self) {
  ApplVerID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BeginString result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ApplVerID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ApplVerID const &","FIX::Message::toBeginString", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ApplVerID const &","FIX::Message::toBeginString", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< ApplVerID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::Message::toBeginString((ApplVerID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new BeginString(result)), SWIGTYPE_p_BeginString, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isHeaderField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isHeaderField(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isHeaderField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isHeaderField((FIX::FieldBase const &)*arg1,(DataDictionary const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isHeaderField((FIX::FieldBase const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isHeaderField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isHeaderField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isHeaderField(arg1,(DataDictionary const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_isHeaderField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_isHeaderField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_Message_isHeaderField__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isHeaderField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isHeaderField__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.isHeaderField", 
    "    bool Message.isHeaderField(int field)\n"
    "    bool Message.isHeaderField(FIX::FieldBase const &field, DataDictionary const *pD)\n"
    "    bool Message.isHeaderField(FIX::FieldBase const &field)\n"
    "    bool Message.isHeaderField(int field, DataDictionary const *pD)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isTrailerField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isTrailerField(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isTrailerField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isTrailerField((FIX::FieldBase const &)*arg1,(DataDictionary const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isTrailerField((FIX::FieldBase const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isTrailerField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isTrailerField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Message::isTrailerField(arg1,(DataDictionary const *)arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_isTrailerField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_isTrailerField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_Message_isTrailerField__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isTrailerField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isTrailerField__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.isTrailerField", 
    "    bool Message.isTrailerField(int field)\n"
    "    bool Message.isTrailerField(FIX::FieldBase const &field, DataDictionary const *pD)\n"
    "    bool Message.isTrailerField(FIX::FieldBase const &field)\n"
    "    bool Message.isTrailerField(int field, DataDictionary const *pD)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getSessionID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SessionID result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSessionID", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSessionID", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->getSessionID((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new SessionID(result)), SWIGTYPE_p_SessionID, SWIG_POINTER_OWN |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getSessionID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SessionID result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Message const *)arg1)->getSessionID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new SessionID(result)), SWIGTYPE_p_SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getSessionID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getSessionID__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_getSessionID__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.getSessionID", 
    "    SessionID Message.getSessionID(std::string const &qualifier)\n"
    "    SessionID Message.getSessionID()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setSessionID(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SessionID const &","setSessionID", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SessionID const &","setSessionID", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setSessionID((SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message___str__(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX_Message___str__(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream &
    <<(stream, sessionID) -> std::ostream
    <<(arg0, arg1) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::Message *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::ostream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::ostream *) &FIX::operator <<(*arg1,(FIX::Message const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_identifyType(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  MsgType result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::identifyType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::identifyType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::identifyType((std::string const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new MsgType(result)), SWIGTYPE_p_MsgType, SWIG_POINTER_OWN |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


static swig_class SwigClassGroup;

SWIGINTERN VALUE
_wrap_new_Group__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  FIX::Group *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Group *)new FIX::Group(arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Group__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int *arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  FIX::Group *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int const []","Group", 3, argv[2] )); 
  } 
  arg3 = reinterpret_cast< int * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Group *)new FIX::Group(arg1,arg2,(int const (*))arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Group__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  message_order *arg3 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  FIX::Group *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","Group", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","Group", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Group *)new FIX::Group(arg1,arg2,(message_order const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Group_allocate(VALUE self)
#else
_wrap_Group_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Group);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Group__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  FIX::Group *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const &","Group", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","Group", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Group *)new FIX::Group((FIX::Group const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Group(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Group__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Group__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Group__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Group__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Group.new", 
    "    Group.new(int field, int delim)\n"
    "    Group.new(int field, int delim, int const order[])\n"
    "    Group.new(int field, int delim, message_order const &order)\n"
    "    Group.new(FIX::Group const &copy)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_field(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Group const *)arg1)->field();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_delim(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","delim", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Group const *)arg1)->delim();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->replaceGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::Group *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Group *) &((FIX::Group const *)arg1)->getGroup(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->removeGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Group_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Group_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Group_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Group.removeGroup", 
    "    void Group.removeGroup(unsigned int num, FIX::Group const &group)\n"
    "    void Group.removeGroup(FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->hasGroup((FIX::Group const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->hasGroup(arg2,(FIX::Group const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Group_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Group_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Group_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Group.hasGroup", 
    "    bool Group.hasGroup(FIX::Group const &group)\n"
    "    bool Group.hasGroup(unsigned int num, FIX::Group const &group)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Group(void *self) {
    FIX::Group *arg1 = (FIX::Group *)self;
    delete arg1;
}

static swig_class SwigClassBeginString;

SWIGINTERN VALUE
_wrap_new_BeginString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::BeginString";
  FIX::BeginString *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::BeginString *)new FIX::BeginString();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_BeginString_allocate(VALUE self)
#else
_wrap_BeginString_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__BeginString);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_BeginString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::STRING *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::BeginString";
  FIX::BeginString *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::STRING const &","BeginString", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::STRING const &","BeginString", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::BeginString *)new FIX::BeginString((FIX::STRING const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("FIX::STRING const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_BeginString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_BeginString__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_BeginString__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "BeginString.new", 
    "    BeginString.new()\n"
    "    BeginString.new(FIX::STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_BeginString(void *self) {
    FIX::BeginString *arg1 = (FIX::BeginString *)self;
    delete arg1;
}

static swig_class SwigClassSenderCompID;

SWIGINTERN VALUE
_wrap_new_SenderCompID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SenderCompID";
  FIX::SenderCompID *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SenderCompID *)new FIX::SenderCompID();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SenderCompID_allocate(VALUE self)
#else
_wrap_SenderCompID_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SenderCompID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SenderCompID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::STRING *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SenderCompID";
  FIX::SenderCompID *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::STRING const &","SenderCompID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::STRING const &","SenderCompID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SenderCompID *)new FIX::SenderCompID((FIX::STRING const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("FIX::STRING const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SenderCompID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SenderCompID__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SenderCompID__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SenderCompID.new", 
    "    SenderCompID.new()\n"
    "    SenderCompID.new(FIX::STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SenderCompID(void *self) {
    FIX::SenderCompID *arg1 = (FIX::SenderCompID *)self;
    delete arg1;
}

static swig_class SwigClassTargetCompID;

SWIGINTERN VALUE
_wrap_new_TargetCompID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::TargetCompID";
  FIX::TargetCompID *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TargetCompID *)new FIX::TargetCompID();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_TargetCompID_allocate(VALUE self)
#else
_wrap_TargetCompID_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TargetCompID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_TargetCompID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::STRING *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::TargetCompID";
  FIX::TargetCompID *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::STRING const &","TargetCompID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::STRING const &","TargetCompID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TargetCompID *)new FIX::TargetCompID((FIX::STRING const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("FIX::STRING const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TargetCompID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TargetCompID__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TargetCompID__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TargetCompID.new", 
    "    TargetCompID.new()\n"
    "    TargetCompID.new(FIX::STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TargetCompID(void *self) {
    FIX::TargetCompID *arg1 = (FIX::TargetCompID *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_BeginString_FIXT11_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIXT11);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX50_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX50);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX44_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX44);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX43_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX43);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX42_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX42);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX41_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX41);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX40_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX40);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_TAG_NUMBER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INVALID_TAG_NUMBER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_REQUIRED_TAG_MISSING_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_UNDEFINED_TAG_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_UNDEFINED_TAG_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_VALUE_IS_INCORRECT_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_VALUE_IS_INCORRECT_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_DECRYPTION_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_DECRYPTION_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SIGNATURE_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_SIGNATURE_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_COMPID_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_COMPID_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_MSGTYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INVALID_MSGTYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_OTHER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_OTHER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_ID_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNKNOWN_ID_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_SECURITY_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNKNOWN_SECURITY_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_NOT_AUTHORIZED_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_NOT_AUTHORIZED_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Heartbeat_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Heartbeat);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TestRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TestRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ResendRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ResendRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Reject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Reject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SequenceReset_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SequenceReset);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Logout_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Logout);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Logon_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Logon);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_XMLnonFIX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_XMLnonFIX);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_IOI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_IOI);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Advertisement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Advertisement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ExecutionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ExecutionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_News_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_News);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Email_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Email);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderSingle_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderSingle);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Allocation_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Allocation);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListExecute_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListExecute);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstructionAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstructionAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DontKnowTrade_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DontKnowTrade);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Quote_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Quote);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SettlementInstructions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SettlementInstructions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataSnapshotFullRefresh_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataSnapshotFullRefresh);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataIncrementalRefresh_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataIncrementalRefresh);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataRequestReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataRequestReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteCancel_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteCancel);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteAcknowledgement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteAcknowledgement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityDefinition_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityDefinition);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassQuote_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassQuote);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BusinessMessageReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BusinessMessageReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BidRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BidRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BidResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BidResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStrikePrice_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStrikePrice);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassQuoteAcknowledgement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassQuoteAcknowledgement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RegistrationInstructions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RegistrationInstructions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RegistrationInstructionsResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RegistrationInstructionsResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassCancelReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassCancelReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderCross_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderCross);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossOrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossOrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossOrderCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossOrderCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityTypeRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityTypeRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityTypes_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityTypes);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DerivativeSecurityListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DerivativeSecurityListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DerivativeSecurityList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DerivativeSecurityList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderMultileg_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderMultileg);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MultilegOrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MultilegOrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteRequestReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteRequestReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RFQRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RFQRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteStatusReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteStatusReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstruction_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstruction);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MultilegOrderCancelReplace_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MultilegOrderCancelReplace);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Confirmation_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Confirmation);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionMaintenanceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionMaintenanceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionMaintenanceReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionMaintenanceReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RequestForPositions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RequestForPositions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RequestForPositionsAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RequestForPositionsAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ConfirmationAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ConfirmationAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SettlementInstructionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SettlementInstructionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AssignmentReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AssignmentReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralAssignment_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralAssignment);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralInquiry_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralInquiry);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NetworkCounterpartySystemStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NetworkCounterpartySystemStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NetworkCounterpartySystemStatusResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NetworkCounterpartySystemStatusResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_UserRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_UserRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_UserResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_UserResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralInquiryAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralInquiryAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ConfirmationRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ConfirmationRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ContraryIntentionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ContraryIntentionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityDefinitionUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityDefinitionUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityListUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityListUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AdjustedPositionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AdjustedPositionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstructionAlert_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstructionAlert);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ExecutionAcknowledgement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ExecutionAcknowledgement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SettlementObligationReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SettlementObligationReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DerivativeSecurityListUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DerivativeSecurityListUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionListUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionListUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDefinition_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDefinition);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDefinitionUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDefinitionUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_UserNotification_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_UserNotification);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassActionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassActionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassActionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassActionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ApplicationMessageRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ApplicationMessageRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ApplicationMessageRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ApplicationMessageRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ApplicationMessageReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ApplicationMessageReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassQuoteAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassQuoteAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ExecutionAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ExecutionAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_StreamAssignmentRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_StreamAssignmentRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_StreamAssignmentReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_StreamAssignmentReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_StreamAssignmentReportACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_StreamAssignmentReportACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarginRequirementInquiry_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarginRequirementInquiry);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarginRequirementInquiryAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarginRequirementInquiryAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarginRequirementReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarginRequirementReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyDetailsListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyDetailsListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyDetailsListReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyDetailsListReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyDetailsListUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyDetailsListUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityMassStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityMassStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityMassStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityMassStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AccountSummaryReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AccountSummaryReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsDefinitionRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsDefinitionRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyEntitlementsRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyEntitlementsRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyEntitlementsReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyEntitlementsReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyDetailsDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyDetailsDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyDetailsDefinitionRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyDetailsDefinitionRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyEntitlementsUpdateReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyEntitlementsUpdateReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyEntitlementsDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyEntitlementsDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyEntitlementsDefinitionRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyEntitlementsDefinitionRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeMatchReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeMatchReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeMatchReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeMatchReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitsReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitsReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitCheckRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitCheckRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyRiskLimitCheckRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyRiskLimitCheckRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyActionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyActionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PartyActionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PartyActionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassOrder_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassOrder);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassOrderAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassOrderAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionTransferInstruction_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionTransferInstruction);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionTransferInstructionAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionTransferInstructionAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionTransferReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionTransferReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataStatisticsRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataStatisticsRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataStatisticsReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataStatisticsReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstructionAlertRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstructionAlertRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstructionAlertRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstructionAlertRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeAggregationRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeAggregationRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeAggregationReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeAggregationReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PayManagementReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PayManagementReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PayManagementReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PayManagementReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PayManagementRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PayManagementRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PayManagementRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PayManagementRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_PossDupFlag_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PossDupFlag_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PossDupFlag_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PossDupFlag_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PossResend_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PossResend_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PossResend_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PossResend_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_NONE_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_NONE_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PKCS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PKCS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_DES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_DES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PKCSDES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PKCSDES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PGPDES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PGPDES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PGPDESMD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PGPDESMD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PEMDESMD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PEMDESMD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_GapFillFlag_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::GapFillFlag_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_GapFillFlag_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::GapFillFlag_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResetSeqNumFlag_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ResetSeqNumFlag_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResetSeqNumFlag_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ResetSeqNumFlag_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_EUCJP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_EUCJP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_ISO2022_JP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_ISO2022_JP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_SHIFT_JIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_SHIFT_JIS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_UTF8_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_UTF8);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_TAG_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_TAG_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_REQUIRED_TAG_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_UNDEFINED_TAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_UNDEFINED_TAG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_VALUE_IS_INCORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_VALUE_IS_INCORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_DECRYPTION_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_DECRYPTION_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SIGNATURE_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_SIGNATURE_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_COMPID_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_COMPID_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_MSGTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_MSGTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_XML_VALIDATION_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_XML_VALIDATION_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_UNSUPPORTED_APPLICATION_VERSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_UNSUPPORTED_APPLICATION_VERSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SENDING_TIME_ACCURACY_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_SENDING_TIME_ACCURACY_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_MSG_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_MSG_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_COMP_ID_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_COMP_ID_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_NON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_NON));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_NUM_IN_GROUP_COUNT_FOR_REPEATING_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INCORRECT_NUM_IN_GROUP_COUNT_FOR_REPEATING_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TestMessageIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TestMessageIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TestMessageIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TestMessageIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX27_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX27);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX30_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX30);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX40_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX40);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX41_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX41);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX42_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX42);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX43_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX43);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX44_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX44);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX50_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX50);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX50_SP1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX50_SP1);
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplVerID_FIX50_SP2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ApplVerID_FIX50_SP2);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_SESSION_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_SESSION_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_SESSION_PASSWORD_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_SESSION_PASSWORD_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_SESSION_PASSWORD_DUE_TO_EXPIRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_SESSION_PASSWORD_DUE_TO_EXPIRE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_NEW_SESSION_PASSWORD_DOES_NOT_COMPLY_WITH_POLICY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_NEW_SESSION_PASSWORD_DOES_NOT_COMPLY_WITH_POLICY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_SESSION_LOGOUT_COMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_SESSION_LOGOUT_COMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_INVALID_USERNAME_OR_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_INVALID_USERNAME_OR_PASSWORD));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_ACCOUNT_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_ACCOUNT_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_LOGONS_ARE_NOT_ALLOWED_AT_THIS_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_LOGONS_ARE_NOT_ALLOWED_AT_THIS_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionStatus_PASSWORD_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionStatus_PASSWORD_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_NEW);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_REPLACE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_POINTS_PER_BOND_OR_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_POINTS_PER_BOND_OR_CONTRACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_AMOUNT_PER_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_AMOUNT_PER_CONTRACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STAY_ON_OFFER_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STAY_ON_OFFER_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NOT_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_WORK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_WORK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_GO_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_GO_ALONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OVER_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OVER_THE_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PARTICIPATE_DO_NOT_INITIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PARTICIPATE_DO_NOT_INITIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STRICT_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STRICT_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRY_TO_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRY_TO_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STAY_ON_BID_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STAY_ON_BID_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NO_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OK_TO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OK_TO_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CALL_FIRST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CALL_FIRST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PERCENT_OF_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PERCENT_OF_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_DO_NOT_INCREASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_DO_NOT_INCREASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_DO_NOT_REDUCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_DO_NOT_REDUCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_INSTITUTIONS_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_INSTITUTIONS_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_LAST_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_LAST_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_MID_PRICE_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_MID_PRICE_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NON_NEGOTIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NON_NEGOTIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OPENING_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OPENING_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_MARKET_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_MARKET_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PRIMARY_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PRIMARY_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SUSPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CUSTOMER_DISPLAY_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CUSTOMER_DISPLAY_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PEG_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PEG_TO_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRY_TO_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRY_TO_STOP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRADE_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRADE_ALONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_REINSTATE_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_REINSTATE_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_REINSTATE_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_REINSTATE_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_IF_NOT_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_IF_NOT_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRAILING_STOP_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRAILING_STOP_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STRICT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STRICT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_IGNORE_PRICE_VALIDITY_CHECKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_IGNORE_PRICE_VALIDITY_CHECKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PEG_TO_LIMIT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PEG_TO_LIMIT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_WORK_TO_TARGET_STRATEGY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_WORK_TO_TARGET_STRATEGY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_INTERMARKET_SWEEP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_INTERMARKET_SWEEP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_EXTERNAL_ROUTING_ALLOWED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_EXTERNAL_ROUTING_ALLOWED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_EXTERNAL_ROUTING_NOT_ALLOWED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_EXTERNAL_ROUTING_NOT_ALLOWED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_IMBALANCE_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_IMBALANCE_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SINGLE_EXECUTION_REQUESTED_FOR_BLOCK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SINGLE_EXECUTION_REQUESTED_FOR_BLOCK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_BEST_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_BEST_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SUSPEND_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SUSPEND_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SUSPEND_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SUSPEND_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_REINSTATE_ON_CONNECTION_LOSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_REINSTATE_ON_CONNECTION_LOSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_ON_CONNECTION_LOSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_ON_CONNECTION_LOSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SUSPEND_ON_CONNECTION_LOSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SUSPEND_ON_CONNECTION_LOSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_RELEASE_FROM_SUSPENSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_RELEASE_FROM_SUSPENSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_EXECUTE_AS_DELTA_NEUTRAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_EXECUTE_AS_DELTA_NEUTRAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_EXECUTE_AS_DURATION_NEUTRAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_EXECUTE_AS_DURATION_NEUTRAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_EXECUTE_AS_FX_NEUTRAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_EXECUTE_AS_FX_NEUTRAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_MIN_GUARANTEED_FILL_ELIGIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_MIN_GUARANTEED_FILL_ELIGIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_BYPASS_NON_DISPLAY_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_BYPASS_NON_DISPLAY_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_LOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_LOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_IGNORE_NOTIONAL_VALUE_CHECKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_IGNORE_NOTIONAL_VALUE_CHECKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRD_AT_REF_PX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRD_AT_REF_PX));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_ALLOW_FACILITATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_ALLOW_FACILITATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_CORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_CORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_AUTOMATED_EXECUTION_NO_INTERVENTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_AUTOMATED_EXECUTION_NO_INTERVENTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_AUTOMATED_EXECUTION_INTERVENTION_OK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_AUTOMATED_EXECUTION_INTERVENTION_OK));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_MANUAL_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_MANUAL_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_CUSIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_SEDOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_SEDOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_QUIK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_QUIK);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISIN_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISIN_NUMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_RIC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_RIC_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISO_COUNTRY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_EXCHANGE_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_EXCHANGE_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_CONSOLIDATED_TAPE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_CONSOLIDATED_TAPE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIOthSvc_AUTEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIOthSvc_AUTEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIOthSvc_BRIDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIOthSvc_BRIDGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_HIGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_HIGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_LOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_LOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_MEDIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_MEDIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_LARGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_LARGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_MEDIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_MEDIUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_SMALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_SMALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_CROSS_AS_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_CROSS_AS_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_CROSS_AS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_CROSS_AS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PARTIALLY_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PARTIALLY_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_DONE_FOR_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_DONE_FOR_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_REPLACED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_STOPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_ACCEPTED_FOR_BIDDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_ACCEPTED_FOR_BIDDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_WITH_OR_WITHOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_WITH_OR_WITHOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_WITH_OR_WITHOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_WITH_OR_WITHOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_ON_BASIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_ON_BASIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUSLY_QUOTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUSLY_QUOTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUSLY_INDICATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUSLY_INDICATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PEGGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PEGGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_PREVIOUSLY_QUOTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_PREVIOUSLY_QUOTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FUNARI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FUNARI));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_IF_TOUCHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_IF_TOUCHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_WITH_LEFT_OVER_AS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_WITH_LEFT_OVER_AS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUS_FUND_VALUATION_POINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUS_FUND_VALUATION_POINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_NEXT_FUND_VALUATION_POINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_NEXT_FUND_VALUATION_POINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_COUNTER_ORDER_SELECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_COUNTER_ORDER_SELECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_ON_BID_OR_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP_ON_BID_OR_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_LIMIT_ON_BID_OR_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP_LIMIT_ON_BID_OR_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENCY_SINGLE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENCY_SINGLE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROPRIETARY_NON_ALGO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROPRIETARY_NON_ALGO));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_INDIVIDUAL_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_INDIVIDUAL_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROPRIETARY_ALGO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROPRIETARY_ALGO));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENCY_ALGO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENCY_ALGO));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENT_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENT_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENCY_INDEX_ARB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENCY_INDEX_ARB));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENCY_NON_ALGO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENCY_NON_ALGO));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_A_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_A_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_W_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_W_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_I_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_I_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_AFFLIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_AFFLIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROPRIETARY_TRANSACTION_AFFILIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROPRIETARY_TRANSACTION_AFFILIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_TRANSACTION_NON_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_TRANSACTION_NON_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SPECIALIST_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SPECIALIST_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_TRANSACTION_UNAFFILIATED_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_TRANSACTION_UNAFFILIATED_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_NOT_AFFLIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_NOT_AFFLIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_NON_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_NON_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BUY_MINUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BUY_MINUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_UNDISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_UNDISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_AS_DEFINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_AS_DEFINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_OPPOSITE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_OPPOSITE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_REDEEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_REDEEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_LEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_LEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BORROW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BORROW));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_UNDISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_UNDISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_AT_THE_OPENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_AT_THE_OPENING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_IMMEDIATE_OR_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_IMMEDIATE_OR_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_FILL_OR_KILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_FILL_OR_KILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_CROSSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_CROSSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_AT_THE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_AT_THE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_THROUGH_CROSSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_THROUGH_CROSSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_AT_CROSSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_AT_CROSSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_FOR_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_FOR_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_FOR_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_FOR_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_FOR_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_FOR_MONTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_NORMAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_NORMAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_FLASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_FLASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_BACKGROUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_BACKGROUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_NEXT_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS2));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS3));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS4));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_FUTURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_WHEN_AND_IF_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_WHEN_AND_IF_ISSUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_SELLERS_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_SELLERS_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS5));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T1));
  return _val;
}


SWIGINTERN VALUE
_wrap_SymbolSfx_EUCP_WITH_LUMP_SUM_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SymbolSfx_EUCP_WITH_LUMP_SUM_INTEREST);
  return _val;
}


SWIGINTERN VALUE
_wrap_SymbolSfx_WHEN_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SymbolSfx_WHEN_ISSUED);
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_CALCULATED_WITHOUT_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_CALCULATED_WITHOUT_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenClose_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenClose_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenClose_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenClose_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_STEP_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_STEP_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_STEP_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_STEP_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_STEP_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR_STEP_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_STEP_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR_STEP_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_PLAN_SPONSOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_PLAN_SPONSOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_BLOCK_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_BLOCK_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_ACCOUNT_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_ACCOUNT_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_INCOMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_INCOMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_REJECTED_BY_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_REJECTED_BY_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_ALLOCATION_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_ALLOCATION_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_REVERSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_REVERSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_CANCELLED_BY_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_CANCELLED_BY_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_CLAIMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_CLAIMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_REFUSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_REFUSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_PENDING_GIVE_UP_APPROVAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_PENDING_GIVE_UP_APPROVAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_PENDING_TAKE_UP_APPROVAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_PENDING_TAKE_UP_APPROVAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_REVERSAL_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_REVERSAL_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_AVERAGEG_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_AVERAGEG_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_COMMISSION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_COMMISSION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_ORDER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_ORDER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_LIST_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_LIST_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_OTHER_SEE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_OTHER_SEE_TEXT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_ALLOCATED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_ALLOCATED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_CALCULATION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_CALCULATION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_OR_STALE_EXEC_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_OR_STALE_EXEC_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_MISMATCHED_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_MISMATCHED_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_CL_ORD_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_CL_ORD_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_WAREHOUSE_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_WAREHOUSE_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_DUPLICATE_OR_MISSING_INDIVIDUAL_ALLOC_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_DUPLICATE_OR_MISSING_INDIVIDUAL_ALLOC_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_TRADE_NOT_RECOGNIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_TRADE_NOT_RECOGNIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_DUPLICATE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_DUPLICATE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_SETTL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_SETTL_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_OR_MISSING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_OR_MISSING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_NET_MONEY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_NET_MONEY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_OR_MISSING_PROCESS_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_OR_MISSING_PROCESS_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_REPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_REPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_ADMIN_REPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_ADMIN_REPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestination_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestination_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestination_POSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestination_POSIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_TOO_LATE_TO_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_TOO_LATE_TO_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_UNKNOWN_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_UNKNOWN_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_BROKER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_BROKER_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_ORDER_ALREADY_IN_PENDING_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_ORDER_ALREADY_IN_PENDING_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_DUPLICATE_CL_ORD_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_DUPLICATE_CL_ORD_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_ORIG_ORD_MOD_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_ORIG_ORD_MOD_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_INVALID_PRICE_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_INVALID_PRICE_INCREMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_BROKER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_BROKER_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_ORDER_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_ORDER_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_DUPLICATE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_DUPLICATE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_STALE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_STALE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_TRADE_ALONG_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_TRADE_ALONG_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INVALID_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INVALID_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SURVEILLENCE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SURVEILLENCE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INCORRECT_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INCORRECT_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INCORRECT_ALLOCATED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INCORRECT_ALLOCATED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INVALID_PRICE_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INVALID_PRICE_INCREMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SURVEILLANCE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SURVEILLANCE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_REFERENCE_PRICE_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_REFERENCE_PRICE_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_ALGORITHM_RISK_THRESHOLD_BREACHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_ALGORITHM_RISK_THRESHOLD_BREACHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SHORT_SELL_NOT_PERMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SHORT_SELL_NOT_PERMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SHORT_SELL_SECURITY_PRE_BORROW_RESTRICTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SHORT_SELL_SECURITY_PRE_BORROW_RESTRICTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SHORT_SELL_ACCOUNT_PRE_BORROW_RESTRICTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SHORT_SELL_ACCOUNT_PRE_BORROW_RESTRICTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INSUFFICIENT_CREDIT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INSUFFICIENT_CREDIT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCEEDED_CLIP_SIZE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCEEDED_CLIP_SIZE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCEEDED_DV01_PV01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCEEDED_DV01_PV01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCEEDED_CS01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCEEDED_CS01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_IN_TOUCH_WITH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_IN_TOUCH_WITH));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_MORE_BEHIND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_MORE_BEHIND));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_TAKING_A_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_TAKING_A_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_PORTFOLIO_SHOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_PORTFOLIO_SHOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_THROUGH_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_THROUGH_THE_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_VERSUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_VERSUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_CROSSING_OPPORTUNITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_CROSSING_OPPORTUNITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_MIDPOINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_MIDPOINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_READY_TO_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_READY_TO_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_MARKET_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AXE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AXE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AXE_ON_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AXE_ON_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AXE_ON_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AXE_ON_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_CLIENT_NATURAL_WORKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_CLIENT_NATURAL_WORKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_POSITION_WANTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_POSITION_WANTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_MARKET_MAKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_MARKET_MAKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_CLIENT_NATURAL_BLOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_CLIENT_NATURAL_BLOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_UNWIND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_UNWIND));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_QUANTITY_NEGOTIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_QUANTITY_NEGOTIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_ALLOW_LATE_BIDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_ALLOW_LATE_BIDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_IMMEDIATE_OR_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_IMMEDIATE_OR_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AUTO_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AUTO_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AUTOMATIC_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AUTOMATIC_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_PLATFORM_CALCULATED_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_PLATFORM_CALCULATED_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_OUTSIDE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_OUTSIDE_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_DEFERRED_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_DEFERRED_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_NEGOTIATED_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_NEGOTIATED_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReportToExch_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ReportToExch_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReportToExch_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ReportToExch_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_LocateReqd_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LocateReqd_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_LocateReqd_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LocateReqd_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ForexReq_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ForexReq_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ForexReq_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ForexReq_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlType_FULL_REMAINING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlType_FULL_REMAINING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlType_PARTIAL_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlType_PARTIAL_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_WRONG_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_WRONG_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_QUANTITY_EXCEEDS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_QUANTITY_EXCEEDS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_NO_MATCHING_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_NO_MATCHING_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_PRICE_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_PRICE_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_CALCULATION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_CALCULATION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_NO_MATCHING_EXECUTION_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_NO_MATCHING_EXECUTION_REPORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOINaturalFlag_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOINaturalFlag_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOINaturalFlag_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOINaturalFlag_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_REGULATORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_REGULATORY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_LOCAL_COMMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_LOCAL_COMMISSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_EXCHANGE_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_EXCHANGE_FEES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_STAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_STAMP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_LEVY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_LEVY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_MARKUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_MARKUP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_CONSUMPTION_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_CONSUMPTION_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_PER_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_PER_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_CONVERSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_CONVERSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_AGENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TRANSFER_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_TRANSFER_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_SECURITY_LENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_SECURITY_LENDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TRADE_REPORTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_TRADE_REPORTING);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TAX_ON_PRINCIPAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_TAX_ON_PRINCIPAL_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TAX_ON_ACCRUED_INTEREST_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_TAX_ON_ACCRUED_INTEREST_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_NEW_ISSUANCE_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_NEW_ISSUANCE_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_SERVICE_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_SERVICE_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_ODD_LOT_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_ODD_LOT_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_AUCTION_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_AUCTION_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_VALUE_ADDED_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_VALUE_ADDED_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_SALES_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_SALES_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_EXECUTION_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_EXECUTION_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_ORDER_ENTRY_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_ORDER_ENTRY_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_ORDER_MODIFICATION_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_ORDER_MODIFICATION_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_ORDERS_CANCELLATION_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_ORDERS_CANCELLATION_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_MARKET_DATA_ACCESS_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_MARKET_DATA_ACCESS_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_MARKET_DATA_TERMINAL_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_MARKET_DATA_TERMINAL_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_MARKET_DATA_VOLUME_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_MARKET_DATA_VOLUME_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_CLEARING_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_CLEARING_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_SETTLEMENT_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_SETTLEMENT_FEE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_REBATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_REBATES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_DISCOUNTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_DISCOUNTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_PAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_PAYMENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_NON_MONETARY_PAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MiscFeeType_NON_MONETARY_PAYMENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PARTIAL_FILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PARTIAL_FILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_FILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_FILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_DONE_FOR_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_DONE_FOR_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_REPLACED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_STOPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_RESTATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_RESTATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_CORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_CORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_ORDER_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_ORDER_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_IN_A_CLEARING_HOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_IN_A_CLEARING_HOLD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_HAS_BEEN_RELEASED_TO_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_HAS_BEEN_RELEASED_TO_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRIGGERED_OR_ACTIVATED_BY_SYSTEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRIGGERED_OR_ACTIVATED_BY_SYSTEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_RELEASED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_RELEASED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlCurrFxRateCalc_DIVIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlCurrFxRateCalc_DIVIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlCurrFxRateCalc_MULTIPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlCurrFxRateCalc_MULTIPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_OVERRIDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_OVERRIDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_STANDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_STANDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_REQUEST_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_REQUEST_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_RESTATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_RESTATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_BROKER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_BROKER_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_INSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_INSTITUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_CEDEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_CEDEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_DEPOSITORY_TRUST_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_DEPOSITORY_TRUST_COMPANY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_EURO_CLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_EURO_CLEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_FEDERAL_BOOK_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_FEDERAL_BOOK_ENTRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_LOCAL_MARKET_SETTLE_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_LOCAL_MARKET_SETTLE_LOCATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_PHYSICAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_PHYSICAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_PARTICIPANT_TRUST_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_PARTICIPANT_TRUST_COMPANY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANKERS_ACCEPTANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANKERS_ACCEPTANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORPORATE_PRIVATE_PLACEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORPORATE_PRIVATE_PLACEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMON_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMON_STOCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_HOUSING_AUTHORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_HOUSING_AUTHORITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_HOME_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_HOME_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_NATIONAL_MORTGAGE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_NATIONAL_MORTGAGE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FOREIGN_EXCHANGE_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FOREIGN_EXCHANGE_CONTRACT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FUTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_GOVERNMENT_NATIONAL_MORTGAGE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_GOVERNMENT_NATIONAL_MORTGAGE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TREASURIES_AGENCY_DEBENTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TREASURIES_AGENCY_DEBENTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MUTUAL_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MUTUAL_FUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_INTEREST_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_INTEREST_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_PRINCIPAL_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_PRINCIPAL_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_PRIVATE_PLACEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_PRIVATE_PLACEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MISCELLANEOUS_PASS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MISCELLANEOUS_PASS_THROUGH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MUNICIPAL_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MUNICIPAL_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NO_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NO_SECURITY_TYPE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PREFERRED_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PREFERRED_STOCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REPURCHASE_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REPURCHASE_AGREEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVERSE_REPURCHASE_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVERSE_REPURCHASE_AGREEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_STUDENT_LOAN_MARKETING_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_STUDENT_LOAN_MARKETING_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TIME_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TIME_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_BILL_OLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_BILL_OLD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WARRANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WARRANT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CATS_TIGERS_AND_LIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CATS_TIGERS_AND_LIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WILDCARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WILDCARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CONVERTIBLE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CONVERTIBLE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_IOETTE_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_IOETTE_MORTGAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_VARIABLE_RATE_DEMAND_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_VARIABLE_RATE_DEMAND_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PLAZOS_FIJOS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PLAZOS_FIJOS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PROMISSORY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PROMISSORY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OVERNIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OVERNIGHT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MEDIUM_TERM_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MEDIUM_TERM_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_AMENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_AMENDED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BRIDGE_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BRIDGE_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_LETTER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_LETTER_OF_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SWING_LINE_FACILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SWING_LINE_FACILITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEBTOR_IN_POSSESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEBTOR_IN_POSSESSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEFAULTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEFAULTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WITHDRAWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WITHDRAWN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_LIQUIDITY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_LIQUIDITY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MATURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MATURED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEPOSIT_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEPOSIT_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_RETIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_RETIRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANK_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANK_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BILL_OF_EXCHANGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BILL_OF_EXCHANGES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CALL_LOANS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CALL_LOANS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REPLACED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MANDATORY_TENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MANDATORY_TENDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVOLVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVOLVER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SHORT_TERM_LOAN_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SHORT_TERM_LOAN_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TO_BE_ANNOUNCED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TO_BE_ANNOUNCED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OTHER_ANTICIPATION_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OTHER_ANTICIPATION_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_PARTICIPATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_BACKED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_BACKED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVENUE_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVENUE_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_ASSESSMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_ASSESSMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_ALLOCATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_GENERAL_OBLIGATION_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_GENERAL_OBLIGATION_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MULTILEG_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MULTILEG_INSTRUMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_REVENUE_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_REVENUE_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXTENDED_COMM_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXTENDED_COMM_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_AGENCY_POOLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_AGENCY_POOLS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_ASSET_BACKED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_ASSET_BACKED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVENUE_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVENUE_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVOLVER_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVOLVER_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_AGENCY_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_AGENCY_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRIVATE_EXPORT_FUNDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRIVATE_EXPORT_FUNDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DUAL_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DUAL_CURRENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INDEXED_LINKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INDEXED_LINKED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_YANKEE_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_YANKEE_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BRADY_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BRADY_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_NOTE_OLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_NOTE_OLD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TERM_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TERM_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_STRUCTURED_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_STRUCTURED_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_SUPRANATIONAL_COUPONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_SUPRANATIONAL_COUPONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_USD_SUPRANATIONAL_COUPONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_USD_SUPRANATIONAL_COUPONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_SOVEREIGNS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_SOVEREIGNS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_BILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_BILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REPURCHASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REPURCHASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BUY_SELLBACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BUY_SELLBACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURITIES_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURITIES_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURITIES_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURITIES_PLEDGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PFANDBRIEFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PFANDBRIEFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OPTIONS_ON_FUTURES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OPTIONS_ON_FUTURES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OPTIONS_ON_PHYSICAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OPTIONS_ON_PHYSICAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WILDCARD_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WILDCARD_ENTRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CASH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_CORPORATE_FLOATING_RATE_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_CORPORATE_FLOATING_RATE_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_CORPORATE_FLOATING_RATE_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_CORPORATE_FLOATING_RATE_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CREDIT_DEFAULT_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CREDIT_DEFAULT_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INTEREST_RATE_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INTEREST_RATE_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OPTIONS_ON_COMBO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OPTIONS_ON_COMBO);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CANADIAN_TREASURY_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CANADIAN_TREASURY_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CANADIAN_TREASURY_BILLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CANADIAN_TREASURY_BILLS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CANADIAN_PROVINCIAL_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CANADIAN_PROVINCIAL_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TREASURY_BILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TREASURY_BILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANK_DEPOSITORY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANK_DEPOSITORY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CANADIAN_MONEY_MARKETS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CANADIAN_MONEY_MARKETS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURED_LIQUIDITY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURED_LIQUIDITY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TERM_LIQUIDITY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TERM_LIQUIDITY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CANADIAN_MORTGAGE_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CANADIAN_MORTGAGE_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAXABLE_MUNICIPAL_CP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAXABLE_MUNICIPAL_CP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PREFERRED_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PREFERRED_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NON_DELIVERABLE_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NON_DELIVERABLE_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FX_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FX_SPOT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FX_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FX_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FX_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FX_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NON_DELIVERABLE_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NON_DELIVERABLE_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FX_BANK_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FX_BANK_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FOREIGN_CURRENCY_DISCOUNT_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FOREIGN_CURRENCY_DISCOUNT_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COLLAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COLLAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMODITY_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMODITY_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXOTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXOTIC);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FLOOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FLOOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FRA);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DERIVATIVE_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DERIVATIVE_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TOTAL_RETURN_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TOTAL_RETURN_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_LOAN_LEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_LOAN_LEASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPOT_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPOT_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SWAP_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SWAP_OPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TRANSMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TRANSMISSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INDEX);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BOND_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BOND_BASKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CONTRACT_FOR_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CONTRACT_FOR_DIFFERENCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORRELATION_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORRELATION_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DIVIEND_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DIVIEND_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EQUITY_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EQUITY_BASKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EQUITY_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EQUITY_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_RETURN_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_RETURN_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_VARIANCE_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_VARIANCE_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PORTFOLIO_SWAPS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PORTFOLIO_SWAPS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FUTURES_ON_A_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FUTURES_ON_A_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FORWARDS_ON_A_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FORWARDS_ON_A_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FORWARD_FREIGHT_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FORWARD_FREIGHT_AGREEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPREAD_BETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPREAD_BETTING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXCHANGE_TRADED_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXCHANGE_TRADED_COMMODITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEPOSITORY_RECEIPTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEPOSITORY_RECEIPTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DELIVERY_VERSUS_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DELIVERY_VERSUS_PLEDGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COLLATERAL_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COLLATERAL_BASKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_STRUCTURED_FINANCE_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_STRUCTURED_FINANCE_PRODUCT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MARGIN_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MARGIN_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_SOVEREIGN_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_SOVEREIGN_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SOVEREIGN_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SOVEREIGN_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_FLOATING_RATE_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_FLOATING_RATE_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANK_ACCEPTED_BILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANK_ACCEPTED_BILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SHORT_TERM_BANK_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SHORT_TERM_BANK_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CALLABLE_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CALLABLE_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMERCIAL_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMERCIAL_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INTEREST_BEARING_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INTEREST_BEARING_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_MEDIUM_TERM_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_MEDIUM_TERM_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_NEGOTIABLE_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_NEGOTIABLE_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_STRUCTURED_LIQUIDITY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_STRUCTURED_LIQUIDITY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_TIME_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_TIME_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_JUMBO_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_JUMBO_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MONEY_MARKET_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MONEY_MARKET_FUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MASTER_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MASTER_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NEGOTIABLE_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NEGOTIABLE_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NEGOTIABLE_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NEGOTIABLE_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_RETAIL_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_RETAIL_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TERM_DEPOSIT_RECEIPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TERM_DEPOSIT_RECEIPT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PFANDBRIEF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PFANDBRIEF);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MUNICIPAL_INTEREST_BEARING_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MUNICIPAL_INTEREST_BEARING_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAXABLE_MUNICIPAL_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAXABLE_MUNICIPAL_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_VARIABLE_RATE_DEMAND_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_VARIABLE_RATE_DEMAND_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXCHANGE_TRADED_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXCHANGE_TRADED_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURITIZED_DERIVATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURITIZED_DERIVATIVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXCHANGE_TRADED_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXCHANGE_TRADED_FUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DIGITAL_ASSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DIGITAL_ASSET);
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_DTCSID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_DTCSID));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_THOMSON_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_THOMSON_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_A_GLOBAL_CUSTODIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_A_GLOBAL_CUSTODIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_ACCOUNT_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_ACCOUNT_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_FREE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_FREE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_VERSUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_VERSUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_TRI_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_TRI_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_HOLD_IN_CUSTODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_HOLD_IN_CUSTODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocLinkType_FX_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocLinkType_FX_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocLinkType_FX_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocLinkType_FX_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_CHOOSER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_CHOOSER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CoveredOrUncovered_COVERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CoveredOrUncovered_COVERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CoveredOrUncovered_UNCOVERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CoveredOrUncovered_UNCOVERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerOrFirm_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerOrFirm_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerOrFirm_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerOrFirm_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_NotifyBrokerOfCredit_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NotifyBrokerOfCredit_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_NotifyBrokerOfCredit_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NotifyBrokerOfCredit_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_FORWARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_FORWARD_AND_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_FORWARD_AND_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_AUTO_CLAIM_GIVE_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_AUTO_CLAIM_GIVE_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_TARGET_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_TARGET_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_TARGET_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_TARGET_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_BLOCK_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_BLOCK_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_BLOCK_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_BLOCK_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_TARGET_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_TARGET_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_BLOCK_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_BLOCK_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_CURVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_FIVE_YR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_FIVE_YR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_TEN_YR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_TEN_YR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD10_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD10));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_THIRTY_YR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_THIRTY_YR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD30_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD30));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_THREE_MOLIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_THREE_MOLIBOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_SIX_MOLIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_SIX_MOLIBOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_SNAPSHOT_AND_UPDATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_SNAPSHOT_AND_UPDATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateType_FULL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDUpdateType_FULL_REFRESH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateType_INCREMENTAL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDUpdateType_INCREMENTAL_REFRESH));
  return _val;
}


SWIGINTERN VALUE
_wrap_AggregatedBook_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AggregatedBook_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_AggregatedBook_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AggregatedBook_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_INDEX_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_INDEX_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OPENING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OPENING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_CLOSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SETTLEMENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SETTLEMENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_HIGH_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_HIGH_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_LOW_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_LOW_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_VWAP_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_VWAP_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADE_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADE_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OPEN_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OPEN_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_COMPOSITE_UNDERLYING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_COMPOSITE_UNDERLYING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SIMULATED_SELL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SIMULATED_SELL_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SIMULATED_BUY_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SIMULATED_BUY_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_MARGIN_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_MARGIN_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_MID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_MID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_EMPTY_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_EMPTY_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SETTLE_HIGH_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SETTLE_HIGH_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SETTLE_LOW_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SETTLE_LOW_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_PRIOR_SETTLE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_PRIOR_SETTLE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SESSION_HIGH_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SESSION_HIGH_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SESSION_LOW_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SESSION_LOW_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_EARLY_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_EARLY_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_AUCTION_CLEARING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_AUCTION_CLEARING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SWAP_VALUE_FACTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SWAP_VALUE_FACTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_FIXING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_FIXING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_CASH_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_CASH_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_RECOVERY_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_RECOVERY_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_RECOVERY_RATE_FOR_LONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_RECOVERY_RATE_FOR_LONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_RECOVERY_RATE_FOR_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_RECOVERY_RATE_FOR_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_MARKET_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_MARKET_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_MARKET_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_MARKET_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SHORT_SALE_MIN_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SHORT_SALE_MIN_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_PREVIOUS_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_PREVIOUS_CLOSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_THRESHOLD_LIMIT_PRICE_BANDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_THRESHOLD_LIMIT_PRICE_BANDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_DAILY_FINANCING_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_DAILY_FINANCING_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_ACCRUED_FINANCING_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_ACCRUED_FINANCING_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_PLUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_PLUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_ZERO_PLUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_ZERO_PLUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_MINUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_MINUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_ZERO_MINUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_ZERO_MINUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_CLOSED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_EXCHANGE_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_EXCHANGE_BEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CONSOLIDATED_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_CONSOLIDATED_BEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_LOCKED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CROSSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_CROSSED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DEPTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FAST_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FAST_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NON_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_NON_FIRM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_MANUAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OUTRIGHT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OUTRIGHT_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_IMPLIED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_IMPLIED_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DEPTH_ON_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DEPTH_ON_OFFER);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DEPTH_ON_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DEPTH_ON_BID);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CLOSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_CLOSING);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NEWS_DISSEMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_NEWS_DISSEMINATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_TRADING_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_TRADING_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ORDER_INFLUX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ORDER_INFLUX);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DUE_TO_RELATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DUE_TO_RELATED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NEWS_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_NEWS_PENDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ADDITIONAL_INFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ADDITIONAL_INFO);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ADDITIONAL_INFO_DUE_TO_RELATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ADDITIONAL_INFO_DUE_TO_RELATED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_RESUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_RESUME);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_VIEW_OF_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_VIEW_OF_COMMON);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_VOLUME_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_VOLUME_ALERT);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ORDER_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ORDER_IMBALANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_EQUIPMENT_CHANGEOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_EQUIPMENT_CHANGEOVER);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NO_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_NO_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_REGULAR_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_REGULAR_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_AUTOMATIC_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_AUTOMATIC_EXECUTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_AUTOMATIC_EXECUTION_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_AUTOMATIC_EXECUTION_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FAST_MARKET_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FAST_MARKET_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_INACTIVE_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_INACTIVE_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ROTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ROTATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_ROTATION_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_ROTATION_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_HALT);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_HALT_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_HALT_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DUE_TO_NEWS_DISSEMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DUE_TO_NEWS_DISSEMINATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DUE_TO_NEWS_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_DUE_TO_NEWS_PENDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_TRADING_RESUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_TRADING_RESUME);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OUT_OF_SEQUENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OUT_OF_SEQUENCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_BID_SPECIALIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_BID_SPECIALIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OFFER_SPECIALIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OFFER_SPECIALIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_BID_OFFER_SPECIALIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_BID_OFFER_SPECIALIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_END_OF_DAY_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_END_OF_DAY_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FORBIDDEN_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FORBIDDEN_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FROZEN_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FROZEN_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_PRE_OPENING_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_PRE_OPENING_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OPENING_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OPENING_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OPEN_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_OPEN_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_SURVEILLANCE_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_SURVEILLANCE_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_SUSPENDED_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_SUSPENDED_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_RESERVED_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_RESERVED_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NO_ACTIVE_SAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_NO_ACTIVE_SAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_RESTRICTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_RESTRICTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_REST_OF_BOOK_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_REST_OF_BOOK_VWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_BETTER_PRICES_IN_CONDITIONAL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_BETTER_PRICES_IN_CONDITIONAL_ORDERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_MEDIAN_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_MEDIAN_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FULL_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FULL_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FLAT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::QuoteCondition_FLAT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CASH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_AVERAGE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_AVERAGE_PRICE_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CASH_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CASH_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_NEXT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OPENING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_INTRADAY_TRADE_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_INTRADAY_TRADE_DETAIL);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_RULE127_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_RULE127_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_RULE155_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_RULE155_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SOLD_LAST);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_NEXT_DAY_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_NEXT_DAY_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OPENED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SELLER);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SOLD);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STOPPED_STOCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_IMBALANCE_MORE_BUYERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_IMBALANCE_MORE_BUYERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_IMBALANCE_MORE_SELLERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_IMBALANCE_MORE_SELLERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OPENING_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BARGAIN_CONDITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BARGAIN_CONDITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CONVERTED_PRICE_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CONVERTED_PRICE_INDICATOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_EXCHANGE_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_EXCHANGE_LAST);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_FINAL_PRICE_OF_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_FINAL_PRICE_OF_SESSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_EX_PIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_EX_PIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CROSSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CROSSED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_TRADES_RESULTING_FROM_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_TRADES_RESULTING_FROM_MANUAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_TRADES_RESULTING_FROM_INTERMARKET_SWEEP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_TRADES_RESULTING_FROM_INTERMARKET_SWEEP);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_VOLUME_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_VOLUME_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_DIRECT_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_DIRECT_PLUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_ACQUISITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_ACQUISITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BUNCHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BUNCHED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_DISTRIBUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_DISTRIBUTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BUNCHED_SALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BUNCHED_SALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SPLIT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SPLIT_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_STOPPED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_STOPPED_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_STOPPED_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OUT_OF_SEQUENCE_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OUT_OF_SEQUENCE_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_LAST_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_LAST_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_LAST_SALE_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SOLD_LAST_SALE_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_LAST);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_LAST_SALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SOLD_LAST_SALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_OPEN_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_OPEN_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENED_SALE_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OPENED_SALE_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_ONLY_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL_ONLY_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_LATE_OPEN_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_LATE_OPEN_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_AUTO_EXECUTION_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_AUTO_EXECUTION_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_REOPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_REOPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_REOPEN_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_REOPEN_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_ADJUSTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_ADJUSTED_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_ADJUSTED_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SPREAD);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SPREAD_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SPREAD_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STRADDLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STRADDLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STRADDLE_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STRADDLE_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STOPPED);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STOPPED_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_REGULAR_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_REGULAR_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_COMBO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_COMBO);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_COMBO_ETH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_COMBO_ETH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OFFICIAL_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OFFICIAL_CLOSING_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_PRIOR_REFERENCE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_PRIOR_REFERENCE_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_SOLD_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STOPPED_SOLD_LAST);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_OUT_OF_SEQUENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_STOPPED_OUT_OF_SEQUENCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OFFICAL_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OFFICAL_CLOSING_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CROSSED_OLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_CROSSED_OLD);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_FAST_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_FAST_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_AUTOMATIC_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_AUTOMATIC_EXECUTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_FORM_T_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_FORM_T);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BASKET_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BASKET_INDEX);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BURST_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BURST_BASKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OUTSIDE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OUTSIDE_SPREAD);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_IMPLIED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_IMPLIED_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_MARKETPLACE_ENTERED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_MARKETPLACE_ENTERED_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_MULT_ASSET_CLASS_MULTILEG_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_MULT_ASSET_CLASS_MULTILEG_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_MULTILEG_TO_MULTILEG_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_MULTILEG_TO_MULTILEG_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OFFICIAL_CLOSING_PRICE_DUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_OFFICIAL_CLOSING_PRICE_DUP);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_TRADE_THROUGH_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_TRADE_THROUGH_EXEMPT);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_QUOTE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_QUOTE_SPREAD);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_LAST_AUCTION_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_LAST_AUCTION_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_HIGH_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_HIGH_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_LOW_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_LOW_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SYSTEMATIC_INTERNALISER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SYSTEMATIC_INTERNALISER);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_AWAY_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_AWAY_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_MIDPOINT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_MIDPOINT_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_TRADED_BEFORE_ISSUE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_TRADED_BEFORE_ISSUE_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_PREVIOUS_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_PREVIOUS_CLOSING_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_NATIONAL_BEST_BID_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_NATIONAL_BEST_BID_OFFER);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_MULTI_ASSET_CLASS_MULTILEG_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_MULTI_ASSET_CLASS_MULTILEG_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SHORT_SALE_MIN_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_SHORT_SALE_MIN_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_BENCHMARK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradeCondition_BENCHMARK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_DELETE_THRU_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_DELETE_THRU));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_DELETE_FROM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_DELETE_FROM));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_OVERLAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_OVERLAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_DUPLICATE_MD_REQ_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_DUPLICATE_MD_REQ_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_INSUFFICIENT_BANDWIDTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_INSUFFICIENT_BANDWIDTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_INSUFFICIENT_PERMISSIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_INSUFFICIENT_PERMISSIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_SUBSCRIPTION_REQUEST_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_SUBSCRIPTION_REQUEST_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MARKET_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MARKET_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MD_UPDATE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MD_UPDATE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_AGGREGATED_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_AGGREGATED_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MD_ENTRY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MD_ENTRY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MD_IMPLICIT_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MD_IMPLICIT_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_OPEN_CLOSE_SETTLE_FLAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_OPEN_CLOSE_SETTLE_FLAG));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_TRADING_SESSION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_TRADING_SESSION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_INSUFFICIENT_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_INSUFFICIENT_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeleteReason_CANCELLATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DeleteReason_CANCELLATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeleteReason_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DeleteReason_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_DAILY_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_DAILY_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_SESSION_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_SESSION_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_DELIVERY_SETTLEMENT_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_DELIVERY_SETTLEMENT_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_EXPECTED_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_EXPECTED_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_FinancialStatus_BANKRUPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FinancialStatus_BANKRUPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_FinancialStatus_PENDING_DELISTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FinancialStatus_PENDING_DELISTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_FinancialStatus_RESTRICTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FinancialStatus_RESTRICTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_DISTRIBUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_DISTRIBUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_CASH_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_CASH_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_STOCK_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_STOCK_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_NON_INTEGER_STOCK_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_NON_INTEGER_STOCK_SPLIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_REVERSE_STOCK_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_REVERSE_STOCK_SPLIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_STANDARD_INTEGER_STOCK_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_STANDARD_INTEGER_STOCK_SPLIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_POSITION_CONSOLIDATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_POSITION_CONSOLIDATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_LIQUIDATION_REORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_LIQUIDATION_REORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_MERGER_REORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_MERGER_REORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_RIGHTS_OFFERING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_RIGHTS_OFFERING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_SHAREHOLDER_MEETING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_SHAREHOLDER_MEETING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_SPINOFF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_SPINOFF));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_TENDER_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_TENDER_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_WARRANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_WARRANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_SPECIAL_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_SPECIAL_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_SYMBOL_CONVERSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_SYMBOL_CONVERSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_CUSIP));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_LEAP_ROLLOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_LEAP_ROLLOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_SUCCESSION_EVENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_SUCCESSION_EVENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_CANCEL_FOR_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_CANCEL_FOR_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_CANCELED_FOR_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_CANCELED_FOR_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_CANCELED_FOR_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_CANCELED_FOR_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_CANCELED_ALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_CANCELED_ALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAckStatus_RECEIVED_NOT_YET_PROCESSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAckStatus_RECEIVED_NOT_YET_PROCESSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_ONE_OR_MORE_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_ONE_OR_MORE_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_ALL_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_ALL_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_QUOTE_SPECIFIED_IN_QUOTE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_QUOTE_SPECIFIED_IN_QUOTE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_SPECIFIED_SINGLE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_SPECIFIED_SINGLE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_BY_TYPE_OF_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_BY_TYPE_OF_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_UNKNOWN_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_UNKNOWN_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_DUPLICATE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_DUPLICATE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_QUOTE_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_QUOTE_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_DEPR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_DEPR));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_REFERENCE_PRICE_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_REFERENCE_PRICE_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INSUFFICIENT_CREDIT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INSUFFICIENT_CREDIT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCEEDED_CLIP_SIZE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCEEDED_CLIP_SIZE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCEEDED_DV01_PV01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCEEDED_DV01_PV01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCEEDED_CS01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCEEDED_CS01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_NO_ACKNOWLEDGEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_NO_ACKNOWLEDGEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_SUMMARY_ACKNOWLEDGEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_SUMMARY_ACKNOWLEDGEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestType_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestType_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestType_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestType_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestType_CONFIRM_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestType_CONFIRM_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_SPECIFICATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_SPECIFICATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_LIST_SECURITY_TYPES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_LIST_SECURITY_TYPES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_LIST_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_LIST_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_SECURITY_TYPE_AND_OR_CFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_SECURITY_TYPE_AND_OR_CFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_TRADING_SESSION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_TRADING_SESSION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_ALL_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_ALL_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_MARKET_ID_OR_MARKET_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_MARKET_ID_OR_MARKET_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_ACCEPT_AS_IS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_ACCEPT_AS_IS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_ACCEPT_WITH_REVISIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_ACCEPT_WITH_REVISIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_REJECT_SECURITY_PROPOSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_REJECT_SECURITY_PROPOSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_CANNOT_MATCH_SELECTION_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_CANNOT_MATCH_SELECTION_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnsolicitedIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::UnsolicitedIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnsolicitedIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::UnsolicitedIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_OPENING_DELAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_OPENING_DELAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_MARKET_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_MARKET_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_ITS_PRE_OPENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_ITS_PRE_OPENING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NEW_PRICE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NEW_PRICE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADE_DISSEMINATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADE_DISSEMINATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_READY_TO_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_READY_TO_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_UNKNOWN_OR_INVALID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_UNKNOWN_OR_INVALID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_RESUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_RESUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_PRICE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_PRICE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADING_RANGE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADING_RANGE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_IMBALANCE_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_IMBALANCE_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_IMBALANCE_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_IMBALANCE_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_OPENING_ROTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_OPENING_ROTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_FAST_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_FAST_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_PRE_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_PRE_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_POST_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_POST_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_NEWS_DISSEMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_NEWS_DISSEMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_ORDER_INFLUX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_ORDER_INFLUX));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_ORDER_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_ORDER_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_ADDITIONAL_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_ADDITIONAL_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_NEWS_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_NEWS_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_EQUIPMENT_CHANGEOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_EQUIPMENT_CHANGEOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonChar_NEW_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReasonChar_NEW_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_InViewOfCommon_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::InViewOfCommon_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_InViewOfCommon_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::InViewOfCommon_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DueToRelated_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DueToRelated_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_DueToRelated_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DueToRelated_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_CORRECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_CORRECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_HALF_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_HALF_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_MORNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_MORNING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_AFTERNOON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_AFTERNOON);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_EVENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_EVENING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_AFTER_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_AFTER_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionID_HOLIDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionID_HOLIDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_OPEN_OUTCRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_OPEN_OUTCRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_TWO_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_TWO_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_VOICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_VOICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_TESTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_TESTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_SIMULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_SIMULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_PRODUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_PRODUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_HALTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_HALTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_PRE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_PRE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_UNKNOWN_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_UNKNOWN_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_DUPLICATE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_DUPLICATE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidRequestTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidRequestTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidRequestTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidRequestTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_SolicitedFlag_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SolicitedFlag_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_SolicitedFlag_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SolicitedFlag_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_GT_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_GT_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_GT_RENEWAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_GT_RENEWAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_VERBAL_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_VERBAL_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_REPRICING_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_REPRICING_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_BROKER_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_BROKER_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_PARTIAL_DECLINE_OF_ORDER_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_PARTIAL_DECLINE_OF_ORDER_QTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_WAREHOUSE_RECAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_WAREHOUSE_RECAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_PEG_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_PEG_REFRESH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_CONNECTION_LOSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_CONNECTION_LOSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_LOGOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_LOGOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_ASSIGN_TIME_PRIORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_ASSIGN_TIME_PRIORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCELLED_FOR_TRADE_PRICE_VIOLATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCELLED_FOR_TRADE_PRICE_VIOLATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCELLED_FOR_CROSS_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCELLED_FOR_CROSS_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CXLD_SMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CXLD_SMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CXLD_SMP_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CXLD_SMP_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CXLD_SMP_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CXLD_SMP_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CXLD_SMP_AGGRESSIVE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CXLD_SMP_AGGRESSIVE_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNKNOWN_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNKNOWN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_APPLICATION_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_INVALID_PRICE_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_INVALID_PRICE_INCREMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_SESSION_DISCONNECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_SESSION_DISCONNECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_THROTTLED_MESSAGES_REJECTED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_THROTTLED_MESSAGES_REJECTED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgDirection_RECEIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MsgDirection_RECEIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgDirection_SEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MsgDirection_SEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_DISPLAYED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_DISPLAYED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_MARKET_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_MARKET_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_PRIMARY_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_PRIMARY_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_MIDPOINT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_MIDPOINT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_LAST_TRADE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_LAST_TRADE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_AVERAGE_PRICE_GUARANTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_AVERAGE_PRICE_GUARANTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_NON_DISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_NON_DISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_DISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_DISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_NO_BIDDING_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_NO_BIDDING_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_SECTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_SECTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideValueInd_SIDE_VALUE1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideValueInd_SIDE_VALUE1));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideValueInd_SIDE_VALUE2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideValueInd_SIDE_VALUE2));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_FIVE_DAY_MOVING_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_FIVE_DAY_MOVING_AVERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_TWENTY_DAY_MOVING_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_TWENTY_DAY_MOVING_AVERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_NORMAL_MARKET_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_NORMAL_MARKET_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExchangeForPhysical_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExchangeForPhysical_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExchangeForPhysical_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExchangeForPhysical_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_BUY_SIDE_REQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_BUY_SIDE_REQUESTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_SELL_SIDE_SENDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_SELL_SIDE_SENDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_REAL_TIME_EXECUTION_REPORTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_REAL_TIME_EXECUTION_REPORTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IncTaxInd_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IncTaxInd_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_IncTaxInd_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IncTaxInd_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeType_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeType_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeType_VWAP_GUARANTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeType_VWAP_GUARANTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeType_GUARANTEED_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeType_GUARANTEED_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeType_RISK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeType_RISK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CLOSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CURRENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CURRENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_SQ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_SQ));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_MORNING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_STRIKE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_STRIKE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_OTHERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_OTHERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_TED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_TED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_TED_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_TED_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PREMIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PREMIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_FIXED_CABINET_TRADE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_FIXED_CABINET_TRADE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_VARIABLE_CABINET_TRADE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_VARIABLE_CABINET_TRADE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_HALFS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_HALFS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_FOURTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_FOURTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_EIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_EIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_SIXTEENTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_SIXTEENTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_SIXTY_FORTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_SIXTY_FORTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRICE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRICE_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_HALVES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_HALVES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_EIGHTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_EIGHTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_NORMAL_RATE_REPRESENTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_NORMAL_RATE_REPRESENTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_INVERSE_RATE_REPRESENTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_INVERSE_RATE_REPRESENTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_UPFRONT_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_UPFRONT_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_INTEREST_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_INTEREST_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PERCENTAGE_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PERCENTAGE_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLLY_NOTIFIED_OTHERWISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_ACCUMULATE_UNTIL_VERBALLLY_NOTIFIED_OTHERWISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_EXEC_STARTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_EXEC_STARTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_TIMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_TIMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_RESPONSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ALL_DONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ALL_DONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetGrossInd_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetGrossInd_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetGrossInd_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetGrossInd_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_CANCELLING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_CANCELLING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_EXECUTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_EXECUTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_ALL_DONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_ALL_DONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_RECEIVED_FOR_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_RECEIVED_FOR_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_IN_BIDDING_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_IN_BIDDING_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_IMMEDIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_IMMEDIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_WAIT_FOR_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_WAIT_FOR_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_BUY_DRIVEN_CASH_WITHDRAW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_BUY_DRIVEN_CASH_WITHDRAW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_BUY_DRIVEN_CASH_TOP_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_BUY_DRIVEN_CASH_TOP_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_SELL_DRIVEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_SELL_DRIVEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejResponseTo_ORDER_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlRejResponseTo_ORDER_CANCEL_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejResponseTo_ORDER_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlRejResponseTo_ORDER_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_SINGLE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_SINGLE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_SICOVAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_SICOVAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_SEDOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_SEDOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CUSIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_QUIK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_QUIK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_BELGIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_BELGIAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_VALOREN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_VALOREN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_DUTCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_DUTCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_WERTPAPIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_WERTPAPIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_BLOOMBERG_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_BLOOMBERG_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_EXCHANGE_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_EXCHANGE_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISO_COUNTRY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_RIC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_RIC_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISIN_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISIN_NUMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_COMMON);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CLEARING_HOUSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CLEARING_HOUSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISDA_FP_ML_SPECIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISDA_FP_ML_SPECIFICATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_OPTION_PRICE_REPORTING_AUTHORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_OPTION_PRICE_REPORTING_AUTHORITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISDA_FP_MLURL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISDA_FP_MLURL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_LETTER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_LETTER_OF_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_MARKETPLACE_ASSIGNED_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_MARKETPLACE_ASSIGNED_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_MARKIT_RED_ENTITY_CLIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_MARKIT_RED_ENTITY_CLIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_MARKIT_RED_PAIR_CLIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_MARKIT_RED_PAIR_CLIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CFTC_COMMODITY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CFTC_COMMODITY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISDA_COMMODITY_REFERENCE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISDA_COMMODITY_REFERENCE_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_LEGAL_ENTITY_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_LEGAL_ENTITY_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_SYNTHETIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_SYNTHETIC);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_FIDESSA_INSTRUMENT_MNEMONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_FIDESSA_INSTRUMENT_MNEMONIC);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_INDEX_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_INDEX_NAME);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_UNIFORM_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_UNIFORM_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_DIGITAL_TOKEN_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_DIGITAL_TOKEN_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQty_LARGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIQty_LARGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQty_MEDIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIQty_MEDIUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQty_SMALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIQty_SMALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQty_UNDISCLOSED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIQty_UNDISCLOSED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_FIFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_FIFO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_ROLLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_ROLLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_CLOSE_BUT_NOTIFY_ON_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_CLOSE_BUT_NOTIFY_ON_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_LIBID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_LIBID);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TREASURY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TREASURY);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EURIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EURIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_PFANDBRIEFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_PFANDBRIEFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_FUTURE_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_FUTURE_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_MUNI_AAA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_MUNI_AAA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_LIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_LIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EUREPO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EUREPO);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_FED_FUND_RATE_EFFECTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_FED_FUND_RATE_EFFECTIVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_FED_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_FED_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_AUBSW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_AUBSW);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_BUBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_BUBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_CDOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_CDOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_CIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_CIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EONIASWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EONIASWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_ESTR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_ESTR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EURODOLLAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EURODOLLAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EUROSWISS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EUROSWISS);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_GCFREPO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_GCFREPO);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_ISDAFIX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_ISDAFIX);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_JIBAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_JIBAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_MOSPRIM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_MOSPRIM);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_NIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_NIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_PRIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_PRIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SOFR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SOFR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_STIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_STIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TELBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TELBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_WIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_WIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_AONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_AONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_AONIAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_AONIAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_BKBM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_BKBM);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_CD19_D_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_CD19_D);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_CORRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_CORRA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_DIRRTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_DIRRTN);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_FIXING_REPO_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_FIXING_REPO_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_HIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_HIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_IBR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_IBR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_KLIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_KLIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_MIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_MIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_NZONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_NZONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_PHIREF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_PHIREF);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_REIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_REIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SAIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SAIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SARON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SARON);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SORA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SORA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TLREF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TLREF);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TIIE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TIIE);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_THBFIX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_THBFIX);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TONAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TONAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ABSOLUTE_PREPAYMENT_SPEED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ABSOLUTE_PREPAYMENT_SPEED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_LOAN_AGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_LOAN_AGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SINGLE_MONTHLY_MORTALITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SINGLE_MONTHLY_MORTALITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MONTHLY_PREPAYMENT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MONTHLY_PREPAYMENT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_PENALTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_PENALTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_LOT_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_LOT_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISSUE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISSUE_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MATURITY_YEAR_AND_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MATURITY_YEAR_AND_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_NUMBER_OF_PIECES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_NUMBER_OF_PIECES);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_MAXIMUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_MAXIMUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_MILLION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_MILLION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_LOT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRODUCTION_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRODUCTION_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TRADE_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TRADE_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_GEOGRAPHICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_GEOGRAPHICS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ALTERNATIVE_MINIMUM_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ALTERNATIVE_MINIMUM_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AUTO_REINVESTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AUTO_REINVESTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BANK_QUALIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BANK_QUALIFIED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BARGAIN_CONDITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BARGAIN_CONDITIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_COUPON_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_COUPON_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CUSTOM_START_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CUSTOM_START);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_VALUATION_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_VALUATION_DISCOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_INSURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_INSURED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISSUER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISSUE_SIZE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISSUE_SIZE_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_LOOKBACK_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_LOOKBACK_DAYS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_EXPLICIT_LOT_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_EXPLICIT_LOT_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MATURITY_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MATURITY_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MAXIMUM_SUBSTITUTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MAXIMUM_SUBSTITUTIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_INCREMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_DENOMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_DENOMINATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PAYMENT_FREQUENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PAYMENT_FREQUENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRICE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRICE_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRICING_FREQUENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRICING_FREQUENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CALL_PROTECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CALL_PROTECTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PURPOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PURPOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BENCHMARK_PRICE_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BENCHMARK_PRICE_SOURCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_RATING_SOURCE_AND_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_RATING_SOURCE_AND_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TYPE_OF_REDEMPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TYPE_OF_REDEMPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_RESTRICTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_RESTRICTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MARKET_SECTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MARKET_SECTOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SECURITY_TYPE_INCLUDED_OR_EXCLUDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SECURITY_TYPE_INCLUDED_OR_EXCLUDED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_STRUCTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_STRUCTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SUBSTITUTIONS_FREQUENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SUBSTITUTIONS_FREQUENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SUBSTITUTIONS_LEFT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SUBSTITUTIONS_LEFT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_FREEFORM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_FREEFORM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WHOLE_POOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WHOLE_POOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_YIELD_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_YIELD_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AVERAGE_FICO_SCORE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AVERAGE_FICO_SCORE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AVERAGE_LOAN_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AVERAGE_LOAN_SIZE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MAXIMUM_LOAN_BALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MAXIMUM_LOAN_BALANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOL_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TYPE_OF_ROLL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TYPE_OF_ROLL_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_REFERENCE_TO_ROLLING_OR_CLOSING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_REFERENCE_TO_ROLLING_OR_CLOSING_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRINCIPAL_OF_ROLLING_OR_CLOSING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRINCIPAL_OF_ROLLING_OR_CLOSING_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_INTEREST_OF_ROLLING_OR_CLOSING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_INTEREST_OF_ROLLING_OR_CLOSING_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AVAILABLE_OFFER_QUANTITY_TO_BE_SHOWN_TO_THE_STREET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AVAILABLE_OFFER_QUANTITY_TO_BE_SHOWN_TO_THE_STREET);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BROKER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BROKER_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_OFFER_PRICE_TO_BE_SHOWN_TO_INTERNAL_BROKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_OFFER_PRICE_TO_BE_SHOWN_TO_INTERNAL_BROKERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_OFFER_QUANTITY_TO_BE_SHOWN_TO_INTERNAL_BROKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_OFFER_QUANTITY_TO_BE_SHOWN_TO_INTERNAL_BROKERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_THE_MINIMUM_RESIDUAL_OFFER_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_THE_MINIMUM_RESIDUAL_OFFER_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MAXIMUM_ORDER_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MAXIMUM_ORDER_SIZE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ORDER_QUANTITY_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ORDER_QUANTITY_INCREMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRIMARY_OR_SECONDARY_MARKET_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRIMARY_OR_SECONDARY_MARKET_INDICATOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BROKER_SALES_CREDIT_OVERRIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BROKER_SALES_CREDIT_OVERRIDE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TRADER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TRADER_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_DISCOUNT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_DISCOUNT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_YIELD_TO_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_YIELD_TO_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ORIGINAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ORIGINAL_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOL_EFFECTIVE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOL_EFFECTIVE_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOL_INITIAL_FACTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOL_INITIAL_FACTOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TRANCHE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TRANCHE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SUBSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SUBSTITUTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MULTEXCHFLLBCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MULTEXCHFLLBCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_COMPSECFLLBCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_COMPSECFLLBCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_LOCLJRSDCTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_LOCLJRSDCTN);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_RELVJRSDCTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_RELVJRSDCTN);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_INCURRED_RECOVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_INCURRED_RECOVERY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ADDITIONAL_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ADDITIONAL_TERM);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MODIFIED_EQUITY_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MODIFIED_EQUITY_DELIVERY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_NO_REFERENCE_OBLICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_NO_REFERENCE_OBLICATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_UNKNOWN_REFERENCE_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_UNKNOWN_REFERENCE_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ALL_GUARANTEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ALL_GUARANTEES);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_REFERENCE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_REFERENCE_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_REFERENCE_POLICY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_REFERENCE_POLICY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SECURED_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SECURED_LIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_INTEREST_PAYOFF_OF_ROLLING_OR_AMENDING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_INTEREST_PAYOFF_OF_ROLLING_OR_AMENDING_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TRUE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TRUE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_PREVIOUS_CLOSE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_PREVIOUS_CLOSE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_LONGEST_AVERAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_MARK_TO_MARKET_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_MARK_TO_MARKET_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_OPEN_AVERAGE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_OPEN_AVERAGE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_PUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_PROCEEDS_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_PROCEEDS_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_SEMI_ANNUAL_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_SEMI_ANNUAL_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_SHORTEST_AVERAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_SIMPLE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_SIMPLE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_TENDER_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_TENDER_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_VALUE_OF32NDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_VALUE_OF32NDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_WORST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_WORST);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TAX_EQUIVALENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TAX_EQUIVALENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_ANNUAL_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_ANNUAL_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_REFUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_REFUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_AFTER_TAX_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_AFTER_TAX_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_AT_ISSUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_AT_ISSUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_AVERAGE_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_AVERAGE_LIFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_AVERAGE_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_AVERAGE_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_BOOK_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_BOOK_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_CALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_CHANGE_SINCE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_CHANGE_SINCE_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_COMPOUND_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_COMPOUND_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CURRENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CURRENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TRUE_GROSS_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TRUE_GROSS_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_GVNT_EQUIVALENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_GVNT_EQUIVALENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_WITH_INFLATION_ASSUMPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_WITH_INFLATION_ASSUMPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_INVERSE_FLOATER_BOND_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_INVERSE_FLOATER_BOND_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_MOST_RECENT_CLOSING_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_MOST_RECENT_CLOSING_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_VALUE_OF132_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_VALUE_OF132);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradedFlatSwitch_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradedFlatSwitch_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradedFlatSwitch_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradedFlatSwitch_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_REMOVED_FROM_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_REMOVED_FROM_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCEL_FOR_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCEL_FOR_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_QUOTE_NOT_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_QUOTE_NOT_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_QUERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_QUERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_ALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_ALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_FOR_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_FOR_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_FOR_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_FOR_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_PASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_PASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_LOCKED_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_LOCKED_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CROSS_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CROSS_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_UNSOLICITED_QUOTE_REPLENISHMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_UNSOLICITED_QUOTE_REPLENISHMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_PENDING_END_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_PENDING_END_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_TOO_LATE_TO_END_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_TOO_LATE_TO_END));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_TRADED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_TRADED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_TRADED_AND_REMOVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_TRADED_AND_REMOVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CONTRACT_TERMINATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CONTRACT_TERMINATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_CHINESE_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_CHINESE_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_US_EMPLOYER_OR_TAX_ID_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_US_EMPLOYER_OR_TAX_ID_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_ISO_COUNTRY_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_US_SOCIAL_SECURITY_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_US_SOCIAL_SECURITY_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_PROPRIETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_SETTLEMENT_ENTITY_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_SETTLEMENT_ENTITY_LOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_KOREAN_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_KOREAN_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_TAIWANESE_FOREIGN_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_TAIWANESE_FOREIGN_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_TAIWANESE_TRADING_ACCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_TAIWANESE_TRADING_ACCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_GENERAL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_GENERAL_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_MIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_MIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_CSD_PARTICIPANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_CSD_PARTICIPANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_ISITC_ACRONYM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_ISITC_ACRONYM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_TAX_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_TAX_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_COMPANY_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_COMPANY_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_REGISTERED_BODY_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_REGISTERED_BODY_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_CFTC_REPORTING_FIRM_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_CFTC_REPORTING_FIRM_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_LEGAL_ENTITY_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_LEGAL_ENTITY_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_INTERIM_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_INTERIM_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_SHORT_CODE_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_SHORT_CODE_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_NATIONAL_ID_NATURAL_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_NATIONAL_ID_NATURAL_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_INDIA_PERMANENT_ACCOUNT_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_INDIA_PERMANENT_ACCOUNT_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_FDID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_FDID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_SPSAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_SPSAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_MASTER_SPSAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_MASTER_SPSAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CORRESPONDANT_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CORRESPONDANT_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLIENT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLIENT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_UNDERLYING_CONTRA_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_UNDERLYING_CONTRA_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SPONSORING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SPONSORING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTING_SYSTEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTING_SYSTEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ENTERING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ENTERING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BROKER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BROKER_OF_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTRODUCING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTRODUCING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_GIVEUP_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_GIVEUP_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LOCATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LOCATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_FUND_MANAGER_CLIENT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_FUND_MANAGER_CLIENT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SETTLEMENT_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SETTLEMENT_LOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ORDER_ORIGINATION_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ORDER_ORIGINATION_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTING_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTING_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ORDER_ORIGINATION_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ORDER_ORIGINATION_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLEARING_ORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLEARING_ORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CUSTOMER_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CUSTOMER_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CORRESPONDENT_CLEARING_ORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CORRESPONDENT_CLEARING_ORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CORRESPONDENT_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CORRESPONDENT_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CUSTODIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CUSTODIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SUB_CUSTODIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SUB_CUSTODIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BENEFICIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BENEFICIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTERESTED_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTERESTED_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REGULATORY_BODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REGULATORY_BODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LIQUIDITY_PROVIDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LIQUIDITY_PROVIDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ENTERING_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ENTERING_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_POSITION_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_POSITION_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_TRANSFER_TO_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_TRANSFER_TO_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_POSITION_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_POSITION_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTERNAL_CARRY_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTERNAL_CARRY_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ORDER_ENTRY_OPERATOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ORDER_ENTRY_OPERATOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SECONDARY_ACCOUNT_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SECONDARY_ACCOUNT_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_FOREIGN_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_FOREIGN_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_THIRD_PARTY_ALLOCATION_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_THIRD_PARTY_ALLOCATION_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLAIMING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLAIMING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ASSET_MANAGER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ASSET_MANAGER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_PLEDGOR_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_PLEDGOR_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_PLEDGEE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_PLEDGEE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LARGE_TRADER_REPORTABLE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LARGE_TRADER_REPORTABLE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_TRADER_MNEMONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_TRADER_MNEMONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SENDER_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SENDER_LOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SESSION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SESSION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ACCEPTABLE_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ACCEPTABLE_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_UNACCEPTABLE_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_UNACCEPTABLE_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ENTERING_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ENTERING_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTING_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTING_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTRODUCING_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTRODUCING_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_QUOTE_ORIGINATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_QUOTE_ORIGINATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REPORT_ORIGINATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REPORT_ORIGINATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SYSTEMATIC_INTERNALISER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SYSTEMATIC_INTERNALISER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_MULTILATERAL_TRADING_FACILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_MULTILATERAL_TRADING_FACILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REGULATED_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REGULATED_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INVESTMENT_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INVESTMENT_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_HOST_COMPETENT_AUTHORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_HOST_COMPETENT_AUTHORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_HOME_COMPETENT_AUTHORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_HOME_COMPETENT_AUTHORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_COMPETENT_AUTHORITY_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_COMPETENT_AUTHORITY_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_COMPETENT_AUTHORITY_TRANSACTION_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_COMPETENT_AUTHORITY_TRANSACTION_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REPORTING_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REPORTING_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTION_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTION_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_MARKET_DATA_ENTRY_ORIGINATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_MARKET_DATA_ENTRY_ORIGINATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LOCATION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LOCATION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_DESK_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_DESK_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_MARKET_DATA_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_MARKET_DATA_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ALLOCATION_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ALLOCATION_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_PRIME_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_PRIME_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_STEP_OUT_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_STEP_OUT_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BROKER_CLEARING_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BROKER_CLEARING_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_GIVEUP_CLEARING_FIRM_DEPR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_GIVEUP_CLEARING_FIRM_DEPR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CENTRAL_REGISTRATION_DEPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CENTRAL_REGISTRATION_DEPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLEARING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLEARING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ACCEPTABLE_SETTLING_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ACCEPTABLE_SETTLING_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_UNACCEPTABLE_SETTLING_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_UNACCEPTABLE_SETTLING_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLS_MEMBER_BANK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLS_MEMBER_BANK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_IN_CONCERT_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_IN_CONCERT_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_IN_CONCERT_CONTROLLING_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_IN_CONCERT_CONTROLLING_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LARGE_POSITIONS_REPORTING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LARGE_POSITIONS_REPORTING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SETTLEMENT_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SETTLEMENT_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SETTLEMENT_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SETTLEMENT_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REPORTING_MARKET_CENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REPORTING_MARKET_CENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_RELATED_REPORTING_MARKET_CENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_RELATED_REPORTING_MARKET_CENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_AWAY_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_AWAY_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_GIVEUP_TRADING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_GIVEUP_TRADING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_TAKEUP_TRADING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_TAKEUP_TRADING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_TAKEUP_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_TAKEUP_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ORIGINATING_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ORIGINATING_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_MARGIN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_MARGIN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_COLLATERAL_ASSET_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_COLLATERAL_ASSET_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_DATA_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_DATA_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CALCULATION_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CALCULATION_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXERCISE_NOTICE_SENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXERCISE_NOTICE_SENDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXERCISE_NOTICE_RECEIVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXERCISE_NOTICE_RECEIVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_RATE_REFERENCE_BANK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_RATE_REFERENCE_BANK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CORRESPONDENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CORRESPONDENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BENEFICIARY_BANK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BENEFICIARY_BANK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BORROWER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BORROWER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_PRIMARY_OBLIGATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_PRIMARY_OBLIGATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_GUARANTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_GUARANTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXCLUDED_REFERENCE_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXCLUDED_REFERENCE_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_DETERMINING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_DETERMINING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_HEDGING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_HEDGING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_REPORTING_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_REPORTING_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_SALES_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_SALES_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_OPERATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_OPERATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CSD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CSD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ICSD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ICSD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_TRADING_SUB_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_TRADING_SUB_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INVESTMENT_DECISION_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INVESTMENT_DECISION_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_PUBLISHING_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_PUBLISHING_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CSD_PARTICIPANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CSD_PARTICIPANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_CUSTOMER_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_CUSTOMER_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CONTRA_INVESTMENT_DECISION_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CONTRA_INVESTMENT_DECISION_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MUNICIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MUNICIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_CORPORATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_CORPORATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_COMMODITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_GOVERNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_GOVERNMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MORTGAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MONEYMARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MONEYMARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_EQUITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_EQUITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_FINANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_FINANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CONTRACTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CONTRACTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_ORIGINALFACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_ORIGINALFACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CURRENTFACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CURRENTFACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_BONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_SHARES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_SHARES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_PAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_TO_NEAREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_TO_NEAREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_NSCC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_NSCC));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_EUROCLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_EUROCLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CLEARSTREAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CLEARSTREAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CHEQUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CHEQUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_TELEGRAPHIC_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_TELEGRAPHIC_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_FED_WIRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_FED_WIRE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_DIRECT_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_DIRECT_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_ACH_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_ACH_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_BPAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_BPAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_HVACS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_HVACS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_REINVEST_IN_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_REINVEST_IN_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_WAIVER_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_WAIVER_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_EXECUTION_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_EXECUTION_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_INSTITUTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_INSTITUTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_AUTHORISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_AUTHORISED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_MONEY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_MONEY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_BELOW_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_BELOW_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_PASSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_PASSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_NOT_CHECKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_NOT_CHECKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_SINGLE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_SINGLE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_BID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_BID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_CANCEL_DUE_TO_BACK_OUT_OF_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_CANCEL_DUE_TO_BACK_OUT_OF_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_BPAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_BPAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_ACH_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_ACH_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_ACH_DEBIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_ACH_DEBIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CREDIT_CARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CREDIT_CARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_DIRECT_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_DIRECT_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_DIRECT_DEBIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_DIRECT_DEBIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_DEBIT_CARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_DEBIT_CARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_FED_WIRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_FED_WIRE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_HIGH_VALUE_CLEARING_SYSTEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_EUROCLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_EUROCLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_TELEGRAPHIC_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_TELEGRAPHIC_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CLEARSTREAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CLEARSTREAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_NSCC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_NSCC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CHEQUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CHEQUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CHIPS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CHIPS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_SWIFT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_SWIFT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CHAPS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CHAPS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_SIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_SIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_EURO_SIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_EURO_SIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_PROFIT_SHARING_PLAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_PROFIT_SHARING_PLAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EMPLOYER_PRIOR_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EMPLOYER_PRIOR_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EMPLOYER_CURRENT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EMPLOYER_CURRENT_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_NON_FUND_PROTOTYPE_IRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_NON_FUND_PROTOTYPE_IRA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_NON_FUND_QUALIFIED_PLAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_NON_FUND_QUALIFIED_PLAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_DEFINED_CONTRIBUTION_PLAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_DEFINED_CONTRIBUTION_PLAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EMPLOYEE_CURRENT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EMPLOYEE_CURRENT_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_IRA_ROLLOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_IRA_ROLLOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_INSURANCE_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_INSURANCE_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_IRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_IRA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EMPLOYEE_PRIOR_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EMPLOYEE_PRIOR_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ASSET_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ASSET_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_SELF_DIRECTED_IRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_SELF_DIRECTED_IRA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_CURRENT_YEAR_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_CURRENT_YEAR_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_US401_K_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_US401_K));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_CASH_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_CASH_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_TESSA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_TESSA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MAXI_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MAXI_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_PRIOR_YEAR_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_PRIOR_YEAR_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_US457_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_US457));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ROTH_IRA_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ROTH_IRA_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ROTH_IRA_NON_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ROTH_IRA_NON_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ROTH_CONVERSION_IRA_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ROTH_CONVERSION_IRA_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ROTH_CONVERSION_IRA_NON_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ROTH_CONVERSION_IRA_NON_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EDUCATION_IRA_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EDUCATION_IRA_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EDUCATION_IRA_NON_PROTOTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EDUCATION_IRA_NON_PROTOTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_KEOGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_KEOGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_US403B_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_US403B));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundRenewWaiv_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FundRenewWaiv_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundRenewWaiv_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FundRenewWaiv_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_REMINDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_REMINDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_DISTRIB_INSTNS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_DISTRIB_INSTNS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_AGENT_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_AGENT_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_ACCOUNT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_ACCOUNT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_NO_REG_DETAILS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_NO_REG_DETAILS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_PAYMENT_METHOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_PAYMENT_METHOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_OWNERSHIP_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_OWNERSHIP_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_TAX_EXEMPT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_TAX_EXEMPT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_DATE_OF_BIRTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_DATE_OF_BIRTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_INVESTOR_ID_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_INVESTOR_ID_SOURCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_MAILING_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_MAILING_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_MAILING_DETAILS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_MAILING_DETAILS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_REG_SEQ_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_REG_SEQ_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_ACCOUNT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_ACCOUNT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_ACCOUNT_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_ACCOUNT_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_REG_DETAILS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_REG_DETAILS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_JOINT_INVESTORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_JOINT_INVESTORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_TENANTS_IN_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_TENANTS_IN_COMMON));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_JOINT_TRUSTEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_JOINT_TRUSTEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_NET_SETTLEMENT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_NET_SETTLEMENT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_COMMISSION_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_COMMISSION_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_COMMISSION_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_COMMISSION_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_INITIAL_CHARGE_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_INITIAL_CHARGE_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_INITIAL_CHARGE_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_INITIAL_CHARGE_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DISCOUNT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DISCOUNT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DISCOUNT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DISCOUNT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DILUTION_LEVY_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DILUTION_LEVY_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DILUTION_LEVY_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DILUTION_LEVY_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_EXIT_CHARGE_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_EXIT_CHARGE_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_EXIT_CHARGE_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_EXIT_CHARGE_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_FUND_BASED_RENEWAL_COMMISSION_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_PROJECTED_FUND_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_PROJECTED_FUND_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_COMPANY_TRUSTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_COMPANY_TRUSTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_NOMINEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_NOMINEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_CORPORATE_BODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_CORPORATE_BODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_NON_PROFIT_ORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_NON_PROFIT_ORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_NETWORKING_SUB_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_NETWORKING_SUB_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_FIDUCIARIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_FIDUCIARIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_TRUSTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_TRUSTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PENSION_PLAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PENSION_PLAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_INDIVIDUAL_TRUSTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_INDIVIDUAL_TRUSTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PUBLIC_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PUBLIC_COMPANY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PRIVATE_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PRIVATE_COMPANY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_INDIVIDUAL_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_INDIVIDUAL_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_INSTITUTIONAL_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_INSTITUTIONAL_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_COMBINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_COMBINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_MEMBER_FIRM_EMPLOYEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_MEMBER_FIRM_EMPLOYEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_MARKET_MAKING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_MARKET_MAKING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PROPRIETARY_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PROPRIETARY_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_NONBROKER_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_NONBROKER_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_UNKNOWN_BENEFICIAL_OWNER_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_UNKNOWN_BENEFICIAL_OWNER_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_FIRMS_ERROR_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_FIRMS_ERROR_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_FIRM_AGENCY_AVERAGE_PRICE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_FIRM_AGENCY_AVERAGE_PRICE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_INDIVIDUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_INDIVIDUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_AGENT_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_AGENT_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_PROPRIETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_MIXED_CAPACITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_MIXED_CAPACITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_FOREIGN_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_FOREIGN_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_RISKLESS_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_RISKLESS_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_PROGRAM_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_PROGRAM_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_NON_INDEX_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_NON_INDEX_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_INDEX_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_INDEX_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_COMPETING_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_COMPETING_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ISSUER_HOLDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ISSUER_HOLDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ISSUE_PRICE_STABILIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ISSUE_PRICE_STABILIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_NON_ALGORITHMIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_NON_ALGORITHMIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ALGORITHMIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ALGORITHMIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_INSIDER_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_INSIDER_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_SIGNIFICANT_SHAREHOLDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_SIGNIFICANT_SHAREHOLDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_NORMAL_COURSE_ISSUER_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_NORMAL_COURSE_ISSUER_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_ACFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_ACFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_ACFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_ACFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITIES_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITIES_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKOWN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKOWN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_CFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_CFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKOWN_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKOWN_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_INDICATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_INDICATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_RESTRICTED_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_RESTRICTED_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_INITIALLY_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_INITIALLY_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_MARGIN_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_MARGIN_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_MARGIN_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_MARGIN_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_LOCAL_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_LOCAL_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDImplicitDelete_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDImplicitDelete_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDImplicitDelete_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDImplicitDelete_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_AON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_AON));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_IOC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_IOC));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_ONE_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_ONE_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_SAME_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_SAME_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_BASIS_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_BASIS_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CONTINGENT_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CONTINGENT_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_VWAP_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_VWAP_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_STS_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_STS_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CUSTOMER_TO_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CUSTOMER_TO_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_SELL_SIDE_IS_PRIORITIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_SELL_SIDE_IS_PRIORITIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_BUY_SIDE_IS_PRIORITIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_BUY_SIDE_IS_PRIORITIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_NoSides_ONE_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NoSides_ONE_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NoSides_BOTH_SIDES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NoSides_BOTH_SIDES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_SECURITY_TYPE_AND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_SECURITY_TYPE_AND));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_TRADING_SESSION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_TRADING_SESSION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_ALL_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_ALL_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_MARKET_ID_OR_MARKET_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_MARKET_ID_OR_MARKET_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_VALID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_VALID_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_NO_INSTRUMENTS_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_NO_INSTRUMENTS_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_INSTRUMENT_LEGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_INSTRUMENT_LEGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADING_SESSION_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADING_SESSION_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatusRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatusRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_ALL_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_ALL_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreviouslyReported_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreviouslyReported_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreviouslyReported_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreviouslyReported_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_COMPARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_COMPARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_UNCOMPARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_UNCOMPARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_ADVISORY_OR_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_ADVISORY_OR_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_MISMATCHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_MISMATCHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_A5_EXACT_MATCH_SUMMARIZED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_A5_EXACT_MATCH_SUMMARIZED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_MINUS_BADGES_TIMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_MINUS_BADGES_TIMES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ACTM6_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ACTM6_MATCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ACT_DEFAULT_AFTER_M2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ACT_DEFAULT_AFTER_M2);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ACT_ACCEPTED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ACT_ACCEPTED_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_A2_EXACT_MATCH_SUMMARIZED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_A2_EXACT_MATCH_SUMMARIZED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_A3_EXACT_MATCH_SUMMARIZED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_A3_EXACT_MATCH_SUMMARIZED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_A4_EXACT_MATCH_SUMMARIZED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_A4_EXACT_MATCH_SUMMARIZED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_SUMMARIZED_MATCH_MINUS_BADGES_TIMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_SUMMARIZED_MATCH_MINUS_BADGES_TIMES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_PLUS4_BADGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_PLUS4_BADGES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_PLUS2_BADGES_EXEC_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_PLUS2_BADGES_EXEC_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_PLUS2_BADGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_PLUS2_BADGES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_OCS_LOCKED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_OCS_LOCKED_IN);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ACT_DEFAULT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ACT_DEFAULT_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_PLUS4_BADGES_EXEC_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_PLUS4_BADGES_EXEC_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_A1_EXACT_MATCH_SUMMARIZED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_A1_EXACT_MATCH_SUMMARIZED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_EXACT_MATCH_PLUS_EXEC_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_EXACT_MATCH_PLUS_EXEC_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ONE_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ONE_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_TWO_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_TWO_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_CONTINUOUS_AUTO_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_CONTINUOUS_AUTO_MATCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_CROSS_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_CROSS_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_COUNTER_ORDER_SELECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_COUNTER_ORDER_SELECTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_CALL_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_CALL_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ONE_PARTY_TRADE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ONE_PARTY_TRADE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_TWO_PARTY_TRADE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_TWO_PARTY_TRADE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_CONFIRMED_TRADE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_CONFIRMED_TRADE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_AUTO_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_AUTO_MATCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_ISSUING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_ISSUING);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_SYSTEMATIC_INTERNALISER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_SYSTEMATIC_INTERNALISER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_AUTO_MATCH_LAST_LOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_AUTO_MATCH_LAST_LOOK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchType_CROSS_AUCTION_LAST_LOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MatchType_CROSS_AUCTION_LAST_LOOK);
  return _val;
}


SWIGINTERN VALUE
_wrap_OddLot_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OddLot_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_OddLot_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OddLot_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_MANUAL_MODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_MANUAL_MODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_MULTILATERAL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_MULTILATERAL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_AUTOMATIC_POSTING_MODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_AUTOMATIC_POSTING_MODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_BILATERAL_NETTING_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_BILATERAL_NETTING_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_AUTOMATIC_GIVE_UP_MODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_AUTOMATIC_GIVE_UP_MODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_SPECIAL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_SPECIAL_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EX_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EX_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_PROCESS_NORMALLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_PROCESS_NORMALLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EXCLUDE_FROM_ALL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EXCLUDE_FROM_ALL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_QUALIFIED_SERVICE_REPRESENTATIVE_QSR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_QUALIFIED_SERVICE_REPRESENTATIVE_QSR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_CUSTOMER_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_CUSTOMER_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_SELF_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_SELF_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_BUY_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_BUY_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_HOUSE_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_HOUSE_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_HOUSE_TRADER_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_HOUSE_TRADER_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_FLOOR_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_FLOOR_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_CARRIED_NON_CUSTOMER_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_CARRIED_NON_CUSTOMER_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_CARRIED_CUSTOMER_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_CARRIED_CUSTOMER_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_JOINT_BACK_OFFICE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_JOINT_BACK_OFFICE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_EQUITIES_SPECIALIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_EQUITIES_SPECIALIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_OPTIONS_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_OPTIONS_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_OPTIONS_FIRM_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_OPTIONS_FIRM_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_CUSTOMER_NON_CUSTOMER_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_CUSTOMER_NON_CUSTOMER_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_ORDERS_MULTIPLE_CUSTOMERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_ORDERS_MULTIPLE_CUSTOMERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_ALL_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_ALL_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_RETAIL_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_RETAIL_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_ACFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_ACFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTY_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTY_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_AUTO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_AUTO));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_ACCUMULATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_ACCUMULATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreallocMethod_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreallocMethod_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreallocMethod_DO_NOT_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreallocMethod_DO_NOT_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_PRE_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_PRE_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_OPENING_OR_OPENING_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_OPENING_OR_OPENING_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_CONTINUOUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_CONTINUOUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_CLOSING_OR_CLOSING_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_CLOSING_OR_CLOSING_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_POST_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_POST_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_INTRADAY_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_INTRADAY_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_QUIESCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_QUIESCENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_SCHEDULED_INTRADAY_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_SCHEDULED_INTRADAY_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_ANY_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_ANY_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_UNSCHEDULED_INTRADAY_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_UNSCHEDULED_INTRADAY_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_OUT_OF_MAIN_SESSION_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_OUT_OF_MAIN_SESSION_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_PRIVATE_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_PRIVATE_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_PUBLIC_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_PUBLIC_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingSessionSubID_GROUP_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TradingSessionSubID_GROUP_AUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_BUYSIDE_READY_TO_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_BUYSIDE_READY_TO_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_SELLSIDE_CALCULATED_USING_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_READY_TO_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_READY_TO_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_WAREHOUSE_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_WAREHOUSE_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REQUEST_TO_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REQUEST_TO_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_ACCEPT_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_ACCEPT_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_INCOMPLETE_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_INCOMPLETE_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_COMPLETE_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_COMPLETE_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REVERSAL_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REVERSAL_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REOPEN_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REOPEN_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_CANCEL_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_CANCEL_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_GIVEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_GIVEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_TAKEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_TAKEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REFUSE_TAKEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REFUSE_TAKEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_INITIATE_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_INITIATE_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REFUSE_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REFUSE_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_SUB_ALLOCATION_GIVEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_SUB_ALLOCATION_GIVEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_APPROVE_GIVEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_APPROVE_GIVEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_APPROVE_TAKEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_APPROVE_TAKEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_NOTIONAL_VALUE_AVERAGE_PX_GROUP_ALLOC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_NOTIONAL_VALUE_AVERAGE_PX_GROUP_ALLOC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FIRMS106_H_AND106_J_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FIRMS106_H_AND106_J);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FIFTH_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FIFTH_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FOURTH_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FOURTH_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_THIRD_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_THIRD_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_SECOND_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_SECOND_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FIRST_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FIRST_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_GIM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_GIM);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_SIXTH_YEAR_DELEGATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_SIXTH_YEAR_DELEGATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_CBOE_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_CBOE_MEMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_LESSEE106_F_EMPLOYEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_LESSEE106_F_EMPLOYEES);
  return _val;
}


SWIGINTERN VALUE
_wrap_WorkingIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::WorkingIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_WorkingIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::WorkingIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriorityIndicator_PRIORITY_UNCHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriorityIndicator_PRIORITY_UNCHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegalConfirm_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LegalConfirm_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegalConfirm_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LegalConfirm_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_INVENTORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_INVENTORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_PASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_PASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_INSUFFICIENT_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_INSUFFICIENT_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCEEDED_CLIP_SIZE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCEEDED_CLIP_SIZE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCEEDED_DV01_PV01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCEEDED_DV01_PV01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCEEDED_CS01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCEEDED_CS01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_REGULAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_CASH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_NEXT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_T_PLUS2);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_T_PLUS3);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_T_PLUS4);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_FUTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_WHEN_AND_IF_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_WHEN_AND_IF_ISSUED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_SELLERS_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_SELLERS_OPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_T_PLUS5);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_BROKEN_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_BROKEN_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_FX_SPOT_NEXT_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlType_FX_SPOT_NEXT_SETTLEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_DAILY_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_DAILY_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_SESSION_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_SESSION_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_EXPECTED_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_EXPECTED_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_RISK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_RISK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_VWAP_GUARANTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_VWAP_GUARANTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_GUARANTEED_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_GUARANTEED_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_SID_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_SID_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_TFM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_TFM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_OMGEO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_OMGEO));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_DTCC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_DTCC_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_SPSAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_SPSAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_MISMATCHED_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_MISMATCHED_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_CONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_CONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryForm_BOOK_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryForm_BOOK_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryForm_BEARER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryForm_BEARER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_PAR_FOR_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_PAR_FOR_PAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_MODIFIED_DURATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_MODIFIED_DURATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_RISK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_RISK));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_PROCEEDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_PROCEEDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PER_SHARE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PER_SHARE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PREMIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PREMIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_TED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_TED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_TED_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_TED_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_YIELD_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_YIELD_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRICE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRICE_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_HALVES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_HALVES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_FOURTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_FOURTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_EIGHTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_EIGHTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_SIXTEENTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_SIXTEENTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_NORMAL_RATE_REPRESENTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_NORMAL_RATE_REPRESENTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_INVERSE_RATE_REPRESENTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_INVERSE_RATE_REPRESENTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_UP_FRONT_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_UP_FRONT_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_INTEREST_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_INTEREST_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PERCENTAGE_OF_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PERCENTAGE_OF_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_HIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_HIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_COVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_COVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_DONE_AWAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_DONE_AWAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_PASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_PASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_END_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_END_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_TIMED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_TIMED_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_TIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_TIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_TIED_COVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_TIED_COVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_TERMINATE_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_TERMINATE_CONTRACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTRA_SPREAD_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTRA_SPREAD_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTER_SPREAD_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTER_SPREAD_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_END_OF_DAY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_END_OF_DAY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_START_OF_DAY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_START_OF_DAY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_OPTION_EXERCISE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_OPTION_EXERCISE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_OPTION_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_OPTION_ASSIGNMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_FROM_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_FROM_EXERCISE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_FROM_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_FROM_ASSIGNMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_PIT_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_PIT_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSFER_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSFER_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ELECTRONIC_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ELECTRONIC_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ALLOCATION_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ALLOCATION_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ADJUSTMENT_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ADJUSTMENT_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_AS_OF_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_AS_OF_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_DELIVERY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_DELIVERY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TOTAL_TRANSACTION_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TOTAL_TRANSACTION_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_CROSS_MARGIN_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_CROSS_MARGIN_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTEGRAL_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTEGRAL_SPLIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_RECEIVE_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_RECEIVE_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_CORPORATE_ACTION_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_CORPORATE_ACTION_ADJUSTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_DELIVERY_NOTICE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_DELIVERY_NOTICE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_EXCHANGE_FOR_PHYSICAL_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_EXCHANGE_FOR_PHYSICAL_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_PRIVATELY_NEGOTIATED_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_PRIVATELY_NEGOTIATED_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_NET_DELTA_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_NET_DELTA_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_CREDIT_EVENT_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_CREDIT_EVENT_ADJUSTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_SUCCESSION_EVENT_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_SUCCESSION_EVENT_ADJUSTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_NET_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_NET_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_GROSS_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_GROSS_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTRADAY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTRADAY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_GROSS_LONG_NON_DELTA_ADJUSTED_SWAPTION_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_GROSS_LONG_NON_DELTA_ADJUSTED_SWAPTION_POSITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_LONG_DELTA_ADJUSTED_PAIRED_SWAPTION_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_LONG_DELTA_ADJUSTED_PAIRED_SWAPTION_POSITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_EXPIRING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_EXPIRING_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_QUANTITY_NOT_EXERCISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_QUANTITY_NOT_EXERCISED);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_REQUESTED_EXERCISE_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_REQUESTED_EXERCISE_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_CASH_FUTURES_EQUIVALENT_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_CASH_FUTURES_EQUIVALENT_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_LOAN_OR_BORROWED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_LOAN_OR_BORROWED_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_SUBMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_SUBMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_TRADE_VARIATION_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_TRADE_VARIATION_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_PREMIUM_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_PREMIUM_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_CASH_RESIDUAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_CASH_RESIDUAL_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_CASH_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_CASH_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_VALUE_ADJUSTED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_VALUE_ADJUSTED_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_SETTLEMENT_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_SETTLEMENT_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_INITIAL_TRADE_COUPON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_INITIAL_TRADE_COUPON_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_ACCRUED_COUPON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_ACCRUED_COUPON_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_COUPON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_COUPON_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_INCREMENTAL_ACCRUED_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_INCREMENTAL_ACCRUED_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_COLLATERALIZED_MARK_TO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_COLLATERALIZED_MARK_TO_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_INCREMENTAL_COLLATERALIZED_MARK_TO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_INCREMENTAL_COLLATERALIZED_MARK_TO_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_COMPENSATION_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_COMPENSATION_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_TOTAL_BANKED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_TOTAL_BANKED_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_TOTAL_COLLATERALIZED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_TOTAL_COLLATERALIZED_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_LONG_PAIRED_SWAP_NOTIONAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_LONG_PAIRED_SWAP_NOTIONAL_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_SHORT_PAIRED_SWAP_NOTIONAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_SHORT_PAIRED_SWAP_NOTIONAL_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_START_OF_DAY_ACCRUED_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_START_OF_DAY_ACCRUED_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_NET_PRESENT_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_NET_PRESENT_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_START_OF_DAY_NET_PRESENT_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_START_OF_DAY_NET_PRESENT_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_NET_CASH_FLOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_NET_CASH_FLOW);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_PRESENT_VALUE_OF_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_PRESENT_VALUE_OF_FEES);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_PRESENT_VALUE_ONE_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_PRESENT_VALUE_ONE_BASIS_POINTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_FIVE_YEAR_EQUIVALENT_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_FIVE_YEAR_EQUIVALENT_NOTIONAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_UNDISCOUNTED_MARK_TO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_UNDISCOUNTED_MARK_TO_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_MARK_TO_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_MARK_TO_MODEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_MARK_TO_MARKET_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_MARK_TO_MARKET_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_MARK_TO_MODEL_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_MARK_TO_MODEL_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_UPFRONT_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_UPFRONT_PAYMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_END_VALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_END_VALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_OUTSTANDING_MARGIN_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_OUTSTANDING_MARGIN_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_LOAN_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_LOAN_VALUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_DO_NOT_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_DO_NOT_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_POSITION_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_POSITION_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_POSITION_CHANGE_SUBMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_POSITION_CHANGE_SUBMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_PLEDGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_LARGE_TRADER_SUBMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_LARGE_TRADER_SUBMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_LARGE_POSITIONS_REPORTING_SUBMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_LARGE_POSITIONS_REPORTING_SUBMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_LONG_HOLDINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_LONG_HOLDINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_INTERNAL_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_INTERNAL_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_TRANSFER_OF_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_TRANSFER_OF_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_EXTERNAL_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_EXTERNAL_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_NOTIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_NOTIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_POSITION_CREATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_POSITION_CREATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_CLOSEOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_CLOSEOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_REOPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_REOPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSessID_INTRADAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlSessID_INTRADAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSessID_REGULAR_TRADING_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlSessID_REGULAR_TRADING_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSessID_ELECTRONIC_TRADING_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlSessID_ELECTRONIC_TRADING_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSessID_END_OF_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlSessID_END_OF_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_DELTA_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_DELTA_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_DELTA_MINUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_DELTA_MINUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_CUSTOMER_SPECIFIC_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_CUSTOMER_SPECIFIC_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_ACCEPTED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_ACCEPTED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintResult_SUCCESSFUL_COMPLETION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintResult_SUCCESSFUL_COMPLETION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintResult_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintResult_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_EXERCISES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_EXERCISES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_ASSIGNMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_ASSIGNMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_SETTLEMENT_ACTIVITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_SETTLEMENT_ACTIVITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_BACKOUT_MESSAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_BACKOUT_MESSAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_DELTA_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_DELTA_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_NET_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_NET_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_LARGE_POSITIONS_REPORTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_LARGE_POSITIONS_REPORTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_EXERCISE_POSITION_REPORTING_SUBMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_EXERCISE_POSITION_REPORTING_SUBMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_POSITION_LIMIT_REPORTING_SUBMISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_POSITION_LIMIT_REPORTING_SUBMISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResponseTransportType_INBAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ResponseTransportType_INBAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResponseTransportType_OUT_OF_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ResponseTransportType_OUT_OF_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_VALID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_VALID_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlPriceType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlPriceType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlPriceType_THEORETICAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlPriceType_THEORETICAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssignmentMethod_RANDOM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AssignmentMethod_RANDOM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssignmentMethod_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AssignmentMethod_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseMethod_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExerciseMethod_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseMethod_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExerciseMethod_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_DESTINATION_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_DESTINATION_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_TRADE_REQUEST_TYPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_TRADE_REQUEST_TYPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_INVALID_PARTY_ONFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_INVALID_PARTY_ONFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_INVALID_TRADE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_INVALID_TRADE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_INVALID_PARTY_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_INVALID_PARTY_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_REFERENCE_PRICE_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_REFERENCE_PRICE_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_SINGLE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_SINGLE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTILEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTILEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_MULTILEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_MULTILEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_EXECUTION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_EXECUTION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TIME_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TIME_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TIME_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TIME_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_BROKER_RECEIPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_BROKER_RECEIPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_BROKER_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_BROKER_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_DESK_RECEIPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_DESK_RECEIPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_SUBMISSION_TO_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_SUBMISSION_TO_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TIME_PRIORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TIME_PRIORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ORDERBOOK_ENTRY_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ORDERBOOK_ENTRY_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ORDER_SUBMISSION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ORDER_SUBMISSION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_PUBLICLY_REPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_PUBLICLY_REPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_PUBLIC_REPORT_UPDATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_PUBLIC_REPORT_UPDATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_NON_PUBLICLY_REPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_NON_PUBLICLY_REPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_NON_PUBLIC_REPORT_UPDATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_NON_PUBLIC_REPORT_UPDATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_SUBMITTED_FOR_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_SUBMITTED_FOR_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_UPDATED_FOR_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_UPDATED_FOR_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_CONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_CONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_UPDATED_FOR_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_UPDATED_FOR_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_CLEARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_CLEARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ALLOCATIONS_SUBMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ALLOCATIONS_SUBMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ALLOCATIONS_UPDATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ALLOCATIONS_UPDATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ALLOCATIONS_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ALLOCATIONS_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_SUBMITTED_TO_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_SUBMITTED_TO_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_POST_TRD_CONTNTN_EVNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_POST_TRD_CONTNTN_EVNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_POST_TRADE_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_POST_TRADE_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_PREVIOUS_TIME_PRIORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_PREVIOUS_TIME_PRIORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_IDENTIFIER_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_IDENTIFIER_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_PREVIOUS_IDENTIFIER_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_PREVIOUS_IDENTIFIER_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ORDER_CANCELLATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ORDER_CANCELLATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ORDER_MODIFICATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ORDER_MODIFICATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_ORDER_ROUTING_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_ORDER_ROUTING_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TRADE_CANCELLATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TRADE_CANCELLATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TRADE_MODIFICATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TRADE_MODIFICATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_REFERENCE_TIME_FOR_NBBO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_REFERENCE_TIME_FOR_NBBO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_CONFIRMATION_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_CONFIRMATION_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_MISMATCHED_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_MISMATCHED_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_UNKNOWN_OR_MISSING_INDIVIDUAL_ALLOC_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_UNKNOWN_OR_MISSING_INDIVIDUAL_ALLOC_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_TRANSACTION_NOT_RECOGNIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_TRANSACTION_NOT_RECOGNIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_DUPLICATE_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_DUPLICATE_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_COMMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_COMMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_NET_MONEY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_NET_MONEY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_CAPACITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_INCORRECT_OR_MISSING_CAPACITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_REGULAR_BOOKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_REGULAR_BOOKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_CFD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_CFD));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_TOTAL_RETURN_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_TOTAL_RETURN_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_FULL_DETAILS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_FULL_DETAILS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_SSIDBI_DS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_SSIDBI_DS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_PHONE_FOR_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_PHONE_FOR_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DlvyInstType_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DlvyInstType_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DlvyInstType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DlvyInstType_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_OVERNIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_OVERNIGHT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_TERM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_FLEXIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_FLEXIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_WAREHOUSE_RECAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_WAREHOUSE_RECAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_REQUEST_TO_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_REQUEST_TO_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_PRELIMINARY_REQUEST_TO_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_PRELIMINARY_REQUEST_TO_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_ACCEPT_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_ACCEPT_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_COMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_COMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_REVERSE_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_REVERSE_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_GIVEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_GIVEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_TAKEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_TAKEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_ALLEGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_ALLEGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_SUB_ALLOCATION_GIVEUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_SUB_ALLOCATION_GIVEUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_CANCELLED_BY_GIVEUP_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_CANCELLED_BY_GIVEUP_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_CARRIED_CUSTOMER_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_CARRIED_CUSTOMER_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_CARRIED_NON_CUSTOMER_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_HOUSE_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_HOUSE_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_FLOOR_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_FLOOR_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_HOUSE_TRADER_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_HOUSE_TRADER_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_JOINT_BACK_OFFICE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_JOINT_BACK_OFFICE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SYSTEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SYSTEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_APPLICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_APPLICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FULL_LEGAL_NAME_OF_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FULL_LEGAL_NAME_OF_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_POSTAL_ADDRESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_POSTAL_ADDRESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PHONE_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PHONE_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_EMAIL_ADDRESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_EMAIL_ADDRESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CONTACT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CONTACT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SECURITIES_ACCOUNT_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SECURITIES_ACCOUNT_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REGISTRATION_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REGISTRATION_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REGISTERED_ADDRESS_FOR_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REGISTERED_ADDRESS_FOR_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REGULATORY_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REGULATORY_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REGISTRATION_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REGISTRATION_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CASH_ACCOUNT_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CASH_ACCOUNT_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CSD_PARTICIPANT_MEMBER_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CSD_PARTICIPANT_MEMBER_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REGISTERED_ADDRESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REGISTERED_ADDRESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FUND_ACCOUNT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FUND_ACCOUNT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_TELEX_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_TELEX_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FAX_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FAX_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SECURITIES_ACCOUNT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SECURITIES_ACCOUNT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CASH_ACCOUNT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CASH_ACCOUNT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DEPARTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DEPARTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_LOCATION_DESK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_LOCATION_DESK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_POSITION_ACCOUNT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_POSITION_ACCOUNT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SECURITY_LOCATE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SECURITY_LOCATE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ELIGIBLE_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ELIGIBLE_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PROFESSIONAL_CLIENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PROFESSIONAL_CLIENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_LOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_EXECUTION_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_EXECUTION_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CURRENCY_DELIVERY_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CURRENCY_DELIVERY_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ADDRESS_CITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ADDRESS_CITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ADDRESS_STATE_OR_PROVINCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ADDRESS_STATE_OR_PROVINCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ADDRESS_POSTAL_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ADDRESS_POSTAL_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ADDRESS_STREET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ADDRESS_STREET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ADDRESS_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ADDRESS_ISO_COUNTRY_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ISO_COUNTRY_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CUSTOMER_ACCOUNT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CUSTOMER_ACCOUNT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_OMNIBUS_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_OMNIBUS_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FUNDS_SEGREGATION_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FUNDS_SEGREGATION_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_GUARANTEE_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_GUARANTEE_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SWAP_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SWAP_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_MAJOR_PARTICIPANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_MAJOR_PARTICIPANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FINANCIAL_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FINANCIAL_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_US_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_US_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REPORTING_ENTITY_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REPORTING_ENTITY_INDICATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ELECTED_CLEARING_REQUIREMENT_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ELECTED_CLEARING_REQUIREMENT_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_BUSINESS_CENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_BUSINESS_CENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_REFERENCE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_REFERENCE_TEXT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SHORT_MARKING_EXEMPT_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SHORT_MARKING_EXEMPT_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PARENT_FIRM_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PARENT_FIRM_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PARENT_FIRM_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PARENT_FIRM_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DEAL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DEAL_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SYSTEM_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SYSTEM_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SYSTEM_TRADE_SUB_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SYSTEM_TRADE_SUB_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FCM_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FCM_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DLVRY_TRML_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DLVRY_TRML_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_VOLNTY_RPT_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_VOLNTY_RPT_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_RPT_OBLIG_JURSDCTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_RPT_OBLIG_JURSDCTN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_VOLNTY_RPT_JURSDCTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_VOLNTY_RPT_JURSDCTN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_COMPANY_ACTIVITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_COMPANY_ACTIVITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_EE_AREA_DOMICILED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_EE_AREA_DOMICILED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CONTRACT_LINKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CONTRACT_LINKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_CONTRACT_ABOVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_CONTRACT_ABOVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_VOLNTY_RPT_PTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_VOLNTY_RPT_PTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_END_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_END_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_LOCATION_OR_JURISDICTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_LOCATION_OR_JURISDICTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DERIVATIVES_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DERIVATIVES_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DOMICILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DOMICILE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_EXEMPT_FROM_RECOGNITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_EXEMPT_FROM_RECOGNITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PAYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PAYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_RECEIVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_RECEIVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SYSTEMATIC_INTERNALISER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SYSTEMATIC_INTERNALISER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PUBLISHING_ENTITY_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PUBLISHING_ENTITY_INDICATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_FIRST_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_FIRST_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SURNAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SURNAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_DATE_OF_BIRTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_DATE_OF_BIRTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ORDER_TRANSMITTING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ORDER_TRANSMITTING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ORDER_TRANSMITTING_FIRM_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ORDER_TRANSMITTING_FIRM_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_ORDER_TRANSMITTER_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_ORDER_TRANSMITTER_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_LEGAL_ENTITY_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_LEGAL_ENTITY_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_SUB_SECTOR_CLASSIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_SUB_SECTOR_CLASSIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_PARTY_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_PARTY_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartySubIDType_LEGAL_REGISTRATION_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartySubIDType_LEGAL_REGISTRATION_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_BLOCK_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_BLOCK_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_ACCOUNT_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_ACCOUNT_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_NO_ACTION_TAKEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_NO_ACTION_TAKEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_QUEUE_FLUSHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_QUEUE_FLUSHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_OVERLAY_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_OVERLAY_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_END_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_END_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_NO_ACTION_TAKEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_NO_ACTION_TAKEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_QUEUE_FLUSHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_QUEUE_FLUSHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_OVERLAY_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_OVERLAY_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_END_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_END_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_NO_AVERAGE_PRICING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_NO_AVERAGE_PRICING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_LAST_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_LAST_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_NOTIONAL_VALUE_AVERAGE_PX_GROUP_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_NOTIONAL_VALUE_AVERAGE_PX_GROUP_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_AVERAGE_PRICED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_AVERAGE_PRICED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_NOT_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_NOT_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_GIVE_UP_EXECUTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_GIVE_UP_EXECUTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_FROM_EXECUTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_FROM_EXECUTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_TO_CLAIM_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_TO_CLAIM_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_TRADE_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_TRADE_SPLIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationCycle_SPECIFIED_EXPIRATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationCycle_SPECIFIED_EXPIRATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_REGULAR_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_REGULAR_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BLOCK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BLOCK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EFP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EFP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_LATE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_LATE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_T_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_T_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_WEIGHTED_AVERAGE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_WEIGHTED_AVERAGE_PRICE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BUNCHED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BUNCHED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_LATE_BUNCHED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_LATE_BUNCHED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PRIOR_REFERENCE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PRIOR_REFERENCE_PRICE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_AFTER_HOURS_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_AFTER_HOURS_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_FOR_RISK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_FOR_RISK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_FOR_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_FOR_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_OF_FUTURES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_OF_FUTURES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_OF_OPTIONS_FOR_OPTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_OF_OPTIONS_FOR_OPTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_TRADING_AT_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_TRADING_AT_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_FUTURES_LARGE_ORDER_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_FUTURES_LARGE_ORDER_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_OF_FUTURES_FOR_FUTURES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_OF_FUTURES_FOR_FUTURES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_OPTION_INTERIM_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_OPTION_INTERIM_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_OPTION_CABINET_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_OPTION_CABINET_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PRIVATELY_NEGOTIATED_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PRIVATELY_NEGOTIATED_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SUBSTITUTION_OF_FUTURES_FOR_FORWARDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SUBSTITUTION_OF_FUTURES_FOR_FORWARDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_ERROR_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_ERROR_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_CUM_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_CUM_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_EX_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_EX_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_CUM_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_CUM_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_EX_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_EX_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_CASH_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_CASH_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_GUARANTEED_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_GUARANTEED_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_CUM_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_CUM_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_EX_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_EX_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_CUM_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_CUM_CAPITAL_REPAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_EX_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_EX_CAPITAL_REPAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_CUM_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_CUM_BONUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SPECIAL_EX_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SPECIAL_EX_BONUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_LARGE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_LARGE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_WORKED_PRINCIPAL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_WORKED_PRINCIPAL_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BLOCK_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BLOCK_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_NAME_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_NAME_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PORTFOLIO_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PORTFOLIO_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PROROGATION_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PROROGATION_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PROROGATION_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PROROGATION_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_OPTION_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_OPTION_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_DELTA_NEUTRAL_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_DELTA_NEUTRAL_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_FINANCING_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_FINANCING_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_NON_STANDARD_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_NON_STANDARD_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_DERIVATIVE_RELATED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_DERIVATIVE_RELATED_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PORTFOLIO_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PORTFOLIO_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_VOLUME_WEIGHTED_AVERAGE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_VOLUME_WEIGHTED_AVERAGE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_GRANTED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_GRANTED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_REPURCHASE_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_REPURCHASE_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_OTC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_OTC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EXCHANGE_BASIS_FACILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EXCHANGE_BASIS_FACILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_OPENING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_OPENING_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_NETTED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_NETTED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BLOCK_SWAP_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BLOCK_SWAP_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_CREDIT_EVENT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_CREDIT_EVENT_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_SUCCESSION_EVENT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_SUCCESSION_EVENT_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_GIVE_UP_GIVE_IN_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_GIVE_UP_GIVE_IN_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_DARK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_DARK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_TECHNICAL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_TECHNICAL_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BENCHMARK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BENCHMARK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PACKAGE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PACKAGE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_ROLL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_ROLL_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_CMTA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_CMTA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_INTERNAL_TRANSFER_OR_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_INTERNAL_TRANSFER_OR_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_EXTERNAL_TRANSFER_OR_TRANSFER_OF_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_EXTERNAL_TRANSFER_OR_TRANSFER_OF_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_REJECT_FOR_SUBMITTING_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_REJECT_FOR_SUBMITTING_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_ADVISORY_FOR_CONTRA_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_ADVISORY_FOR_CONTRA_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_OFFSET_DUE_TO_AN_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_OFFSET_DUE_TO_AN_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_ONSET_DUE_TO_AN_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_ONSET_DUE_TO_AN_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_DIFFERENTIAL_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_DIFFERENTIAL_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_IMPLIED_SPREAD_LEG_EXECUTED_AGAINST_AN_OUTRIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_IMPLIED_SPREAD_LEG_EXECUTED_AGAINST_AN_OUTRIGHT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRANSACTION_FROM_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRANSACTION_FROM_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRANSACTION_FROM_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRANSACTION_FROM_ASSIGNMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_ACATS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_ACATS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_AI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_AI));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_B_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_B));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_K_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_K));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_LC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_LC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_M_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_M));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_N_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_N));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_NM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_NM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_NR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_NR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_P_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_P));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_PA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_PA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_PC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_PC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_PN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_PN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_R_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_R));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_RO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_RO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_RT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_RT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_SW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_SW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_T_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_T));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_WN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_WN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_WT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_WT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_OFF_HOURS_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_OFF_HOURS_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_ON_HOURS_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_ON_HOURS_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_OTC_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_OTC_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_CONVERTED_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_CONVERTED_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_CROSSED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_CROSSED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_INTERIM_PROTECTED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_INTERIM_PROTECTED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_WASH_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_WASH_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRADE_AT_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRADE_AT_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_AUCTION_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_AUCTION_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRADE_AT_MARKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRADE_AT_MARKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_CREDIT_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_CREDIT_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_CREDIT_RESTRUCTURING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_CREDIT_RESTRUCTURING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_MERGER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_MERGER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_SPIN_OFF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_SPIN_OFF));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_MULTILATERAL_COMPRESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_MULTILATERAL_COMPRESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_BALANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_BALANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_BASIS_TRADE_INDEX_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_BASIS_TRADE_INDEX_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRADE_AT_CASH_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRADE_AT_CASH_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_TRD_SUBMIT_VENUE_CLR_SETTL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_TRD_SUBMIT_VENUE_CLR_SETTL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdSubType_BILATERAL_COMPRESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdSubType_BILATERAL_COMPRESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegMoveType_FLOATING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegMoveType_FLOATING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegMoveType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegMoveType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_TICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_TICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_PRICE_TIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_PRICE_TIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_STRICT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_STRICT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_OR_WORSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_OR_WORSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegRoundDirection_MORE_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegRoundDirection_MORE_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegRoundDirection_MORE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegRoundDirection_MORE_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_NATIONAL_EXCLUDING_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_NATIONAL_EXCLUDING_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionMoveType_FLOATING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionMoveType_FLOATING));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionMoveType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionMoveType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_TICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_TICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_PRICE_TIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_PRICE_TIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_STRICT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_STRICT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_OR_WORSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_OR_WORSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionRoundDirection_MORE_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionRoundDirection_MORE_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionRoundDirection_MORE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionRoundDirection_MORE_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_NATIONAL_EXCLUDING_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_NATIONAL_EXCLUDING_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TargetStrategy_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TargetStrategy_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TargetStrategy_PARTICIPATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TargetStrategy_PARTICIPATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TargetStrategy_MININIZE_MARKET_IMPACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TargetStrategy_MININIZE_MARKET_IMPACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_ADDED_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_ADDED_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_REMOVED_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_LIQUIDITY_ROUTED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_LIQUIDITY_ROUTED_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_NEITHER_ADDED_NOR_REMOVED_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_NEITHER_ADDED_NOR_REMOVED_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_TRIGGERED_STOP_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_TRIGGERED_STOP_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_TRIGGERED_CONTINGENCY_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_TRIGGERED_CONTINGENCY_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_TRIGGERED_MARKET_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_TRIGGERED_MARKET_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_AFTER_FIRM_ORDER_COMMITMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_REMOVED_LIQUIDITY_AFTER_FIRM_ORDER_COMMITMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_AUCTION_EXECUTION_AFTER_FIRM_ORDER_COMMITMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_AUCTION_EXECUTION_AFTER_FIRM_ORDER_COMMITMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PublishTrdIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PublishTrdIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PublishTrdIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PublishTrdIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_DEALER_SOLD_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_DEALER_SOLD_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_QUALIFIED_SERVICE_REPRESENTATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_QUALIFIED_SERVICE_REPRESENTATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QtyType_UNITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QtyType_UNITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QtyType_CONTRACTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QtyType_CONTRACTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QtyType_UNITS_OF_MEASURE_PER_TIME_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QtyType_UNITS_OF_MEASURE_PER_TIME_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_SUBMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_SUBMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_DECLINE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_DECLINE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ADDENDUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ADDENDUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_TRADE_REPORT_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_TRADE_REPORT_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_LOCKED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_LOCKED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_DEFAULTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_DEFAULTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_INVALID_CMTA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_INVALID_CMTA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_PENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_PENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_ADDENDUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED_ADDENDUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_TRADE_REPORT_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED_TRADE_REPORT_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_TRADE_BREAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED_TRADE_BREAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_VERIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_VERIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_DISPUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_DISPUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_NON_MATERIAL_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_NON_MATERIAL_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocNoOrdersType_NOT_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocNoOrdersType_NOT_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocNoOrdersType_EXPLICIT_LIST_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocNoOrdersType_EXPLICIT_LIST_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_TENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_TENDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SINKING_FUND_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SINKING_FUND_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_ACTIVATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_ACTIVATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_INACTIVIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_INACTIVIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_LAST_ELIGIBLE_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_LAST_ELIGIBLE_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SWAP_START_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SWAP_START_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SWAP_END_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SWAP_END_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SWAP_ROLL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SWAP_ROLL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SWAP_NEXT_START_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SWAP_NEXT_START_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SWAP_NEXT_ROLL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SWAP_NEXT_ROLL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_FIRST_DELIVERY_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_FIRST_DELIVERY_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_LAST_DELIVERY_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_LAST_DELIVERY_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_INITIAL_INVENTORY_DUE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_INITIAL_INVENTORY_DUE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_FINAL_INVENTORY_DUE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_FINAL_INVENTORY_DUE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_FIRST_INTENT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_FIRST_INTENT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_LAST_INTENT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_LAST_INTENT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_POSITION_REMOVAL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_POSITION_REMOVAL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_MINIMUM_NOTICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_MINIMUM_NOTICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_DELIVERY_START_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_DELIVERY_START_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_DELIVERY_END_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_DELIVERY_END_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_FIRST_NOTICE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_FIRST_NOTICE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_LAST_NOTICE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_LAST_NOTICE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_FIRST_EXERCISE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_FIRST_EXERCISE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_REDEMPTION_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_REDEMPTION_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_TRD_CNTNTN_EFCTV_DT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_TRD_CNTNTN_EFCTV_DT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_FLAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_FLAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ZERO_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ZERO_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INTEREST_BEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INTEREST_BEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_NO_PERIODIC_PAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_NO_PERIODIC_PAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_VARIABLE_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_VARIABLE_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_LESS_FEE_FOR_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_LESS_FEE_FOR_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_STEPPED_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_STEPPED_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_COUPON_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_COUPON_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_WHEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_WHEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ORIGINAL_ISSUE_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_CALLABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_CALLABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ESCROWED_TO_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ESCROWED_TO_MATURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ESCROWED_TO_REDEMPTION_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ESCROWED_TO_REDEMPTION_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_PRE_REFUNDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_PRE_REFUNDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_IN_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_IN_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_UNRATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_UNRATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TAXABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TAXABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INDEXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INDEXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_CALLABLE_BELOW_MATURITY_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_CALLABLE_BELOW_MATURITY_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_CALLABLE_WITHOUT_NOTICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_CALLABLE_WITHOUT_NOTICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TEXT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_PRICE_TICK_RULES_FOR_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_PRICE_TICK_RULES_FOR_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TRADE_TYPE_ELIGIBILITY_DETAILS_FOR_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TRADE_TYPE_ELIGIBILITY_DETAILS_FOR_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INSTRUMENT_DENOMINATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INSTRUMENT_DENOMINATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INSTRUMENT_NUMERATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INSTRUMENT_NUMERATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INSTRUMENT_PRICE_PRECISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INSTRUMENT_PRICE_PRECISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INSTRUMENT_STRIKE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INSTRUMENT_STRIKE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TRADEABLE_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TRADEABLE_INDICATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INSTRUMENT_ELIGIBLE_ANON_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INSTRUMENT_ELIGIBLE_ANON_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_MIN_GUARANTEED_FILL_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_MIN_GUARANTEED_FILL_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_MIN_GUARANTEED_FILL_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_MIN_GUARANTEED_FILL_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TRADE_AT_SETTLEMENT_ELIGIBILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TRADE_AT_SETTLEMENT_ELIGIBILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_TEST_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_TEST_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_DUMMY_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_DUMMY_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_NEGATIVE_SETTLEMENT_PRICE_ELIGIBILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_NEGATIVE_SETTLEMENT_PRICE_ELIGIBILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_NEGATIVE_STRIKE_PRICE_ELIGIBILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_NEGATIVE_STRIKE_PRICE_ELIGIBILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_US_STD_CONTRACT_IND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_US_STD_CONTRACT_IND));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ADMITTED_TO_TRADING_ON_TRADING_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ADMITTED_TO_TRADING_ON_TRADING_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_AVERAGE_DAILY_NOTIONAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_AVERAGE_DAILY_NOTIONAL_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_AVERAGE_DAILY_NUMBER_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_AVERAGE_DAILY_NUMBER_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A3));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM42_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM42));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A2));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A3_AND3C7_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A3_AND3C7));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A4));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A5));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3A7_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3A7));
  return _val;
}


SWIGINTERN VALUE
_wrap_CPProgram_PROGRAM3C7_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CPProgram_PROGRAM3C7));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastFragment_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastFragment_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastFragment_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastFragment_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_SCHEDULED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_SCHEDULED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_TIME_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_TIME_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_MARGIN_DEFICIENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_MARGIN_DEFICIENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_MARGIN_EXCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_MARGIN_EXCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_FORWARD_COLLATERAL_DEMAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_FORWARD_COLLATERAL_DEMAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_EVENT_OF_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_EVENT_OF_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_ADVERSE_TAX_EVENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_ADVERSE_TAX_EVENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_TRANSFER_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_TRANSFER_DEPOSIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_TRANSFER_WITHDRAWAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_TRANSFER_WITHDRAWAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_PLEDGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_GC_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_GC_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_COLLATERAL_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_COLLATERAL_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_SUBSTITUTION_ELIGIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_SUBSTITUTION_ELIGIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_NOT_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_NOT_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_PARTIALLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_PARTIALLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_FULLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_FULLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_OUTSTANDING_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_OUTSTANDING_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_DECLINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_DECLINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_TRANSACTION_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_TRANSACTION_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_TRANSACTION_COMPLETED_WITH_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_TRANSACTION_COMPLETED_WITH_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNKNOWN_DEAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNKNOWN_DEAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_INSUFFICIENT_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_INSUFFICIENT_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_UNASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_UNASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_PARTIALLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_PARTIALLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_ASSIGNMENT_PROPOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_ASSIGNMENT_PROPOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_CHALLENGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_CHALLENGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_REUSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_REUSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastRptRequested_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastRptRequested_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastRptRequested_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastRptRequested_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_VERSUS_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_VERSUS_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_FREE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_FREE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_TRI_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_TRI_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_HOLD_IN_CUSTODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_HOLD_IN_CUSTODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_DELIVER_BY_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_DELIVER_BY_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_LOG_ON_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_LOG_ON_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_LOG_OFF_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_LOG_OFF_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_CHANGE_PASSWORD_FOR_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_CHANGE_PASSWORD_FOR_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_REQUEST_THROTTLE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_REQUEST_THROTTLE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_LOGGED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_LOGGED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_NOT_LOGGED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_NOT_LOGGED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_USER_NOT_RECOGNISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_USER_NOT_RECOGNISED));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_PASSWORD_INCORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_PASSWORD_INCORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_PASSWORD_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_PASSWORD_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_FORCED_USER_LOGOUT_BY_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_FORCED_USER_LOGOUT_BY_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_SESSION_SHUTDOWN_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_SESSION_SHUTDOWN_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_THROTTLE_PARAMETERS_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_THROTTLE_PARAMETERS_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_CONNECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_CONNECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_NOT_CONNECTED_UNEXPECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_NOT_CONNECTED_UNEXPECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_NOT_CONNECTED_EXPECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_NOT_CONNECTED_EXPECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_IN_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_IN_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_SUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_SUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_STOP_SUBSCRIBING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_STOP_SUBSCRIBING));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_LEVEL_OF_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_LEVEL_OF_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkStatusResponseType_FULL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkStatusResponseType_FULL));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkStatusResponseType_INCREMENTAL_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkStatusResponseType_INCREMENTAL_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_ACCEPTED_WITH_ERRORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_ACCEPTED_WITH_ERRORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_PENDING_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_PENDING_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_PENDING_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_PENDING_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_PENDING_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_PENDING_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_TERMINATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_TERMINATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_PENDING_VERIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_PENDING_VERIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_DEEMED_VERIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_DEEMED_VERIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_VERIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_VERIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_DISPUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_DISPUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_CONFIRM_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_CONFIRM_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_AFFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_AFFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_RETAIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_RETAIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_REMOVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_REMOVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_ACCEPTED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_ACCEPTED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_DESTINATION_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_DESTINATION_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_INT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_INT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_LENGTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_LENGTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_NUM_IN_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_NUM_IN_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_SEQ_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_SEQ_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_TAG_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_TAG_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_FLOAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_FLOAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_QTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_PRICE_OFFSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_PRICE_OFFSET));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_CHAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_CHAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_BOOLEAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_BOOLEAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_STRING));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_MULTIPLE_CHAR_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_MULTIPLE_CHAR_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_MONTH_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_MONTH_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_UTC_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_UTC_TIMESTAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_UTC_TIME_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_UTC_TIME_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_LOCAL_MKT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_LOCAL_MKT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_UTC_DATE_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_UTC_DATE_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_MULTIPLE_STRING_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_MULTIPLE_STRING_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_LANGUAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_LANGUAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_TZ_TIME_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_TZ_TIME_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_TZ_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_TZ_TIMESTAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyParameterType_TENOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrategyParameterType_TENOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_ACTIVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_INACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_INACTIVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_ACTIVE_CLOSING_ORDERS_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_ACTIVE_CLOSING_ORDERS_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_EXPIRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_DELISTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_DELISTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_KNOCKED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_KNOCKED_OUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_KNOCK_OUT_REVOKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_KNOCK_OUT_REVOKED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_PENDING_EXPIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_PENDING_EXPIRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_SUSPENDED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_PUBLISHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_PUBLISHED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityStatus_PENDING_DELETION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityStatus_PENDING_DELETION);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingCashType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingCashType_FIXED);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingCashType_DIFF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingCashType_DIFF);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingSettlementType_T_PLUS1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingSettlementType_T_PLUS1));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingSettlementType_T_PLUS3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingSettlementType_T_PLUS3));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingSettlementType_T_PLUS4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingSettlementType_T_PLUS4));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityUpdateAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SecurityUpdateAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityUpdateAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SecurityUpdateAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityUpdateAction_MODIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SecurityUpdateAction_MODIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpType_AUTO_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpType_AUTO_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpType_NON_AUTO_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpType_NON_AUTO_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpType_FINAL_WILL_BE_EXERCISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpType_FINAL_WILL_BE_EXERCISED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpType_CONTRARY_INTENTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpType_CONTRARY_INTENTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpType_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpType_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IndividualAllocType_SUB_ALLOCATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IndividualAllocType_SUB_ALLOCATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IndividualAllocType_THIRD_PARTY_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IndividualAllocType_THIRD_PARTY_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_BARRELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_BARRELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_BILLION_CUBIC_FEET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_BILLION_CUBIC_FEET);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_BUSHELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_BUSHELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_POUNDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_POUNDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_GALLONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_GALLONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_MILLION_BARRELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_MILLION_BARRELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_ONE_MILLION_BTU_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_ONE_MILLION_BTU);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_MEGAWATT_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_MEGAWATT_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_TROY_OUNCES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_TROY_OUNCES);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_METRIC_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_METRIC_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitofMeasure_US_DOLLARS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitofMeasure_US_DOLLARS);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_HOUR);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_MINUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_MINUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_SECOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_SECOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeUnit_QUARTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TimeUnit_QUARTER);
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocMethod_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocMethod_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocMethod_GUARANTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocMethod_GUARANTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocMethod_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocMethod_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocMethod_BROKER_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocMethod_BROKER_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AsOfIndicator_FALSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AsOfIndicator_FALSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AsOfIndicator_TRUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AsOfIndicator_TRUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDBookType_TOP_OF_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDBookType_TOP_OF_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDBookType_PRICE_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDBookType_PRICE_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDBookType_ORDER_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDBookType_ORDER_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_OFF_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_OFF_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_QUOTE_DRIVEN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_QUOTE_DRIVEN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_DARK_ORDER_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_DARK_ORDER_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_AUCTION_DRIVEN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_AUCTION_DRIVEN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_QUOTE_NEGOTIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_QUOTE_NEGOTIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_VOICE_NEGOTIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_VOICE_NEGOTIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDOriginType_HYBRID_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDOriginType_HYBRID_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_ADD_ON_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_ADD_ON_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_ALL_OR_NONE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CASH_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CASH_NOT_HELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DIRECTED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DIRECTED_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_FILL_OR_KILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_FILL_OR_KILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_IMBALANCE_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_IMBALANCE_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_IMMEDIATE_OR_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_IMMEDIATE_OR_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_LIMIT_ON_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_LIMIT_ON_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_LIMIT_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_LIMIT_ON_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_AT_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_AT_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_AT_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_AT_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_ON_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_ON_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_ON_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MINIMUM_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MINIMUM_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_NOT_HELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_OVER_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_OVER_THE_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PEGGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PEGGED);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_RESERVE_SIZE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_RESERVE_SIZE_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_STOP_STOCK_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_STOP_STOCK_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_SCALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_TIME_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_TIME_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_TRAILING_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_TRAILING_STOP);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_WORK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_WORK);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PHONE_SIMPLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PHONE_SIMPLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PHONE_COMPLEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PHONE_COMPLEX);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_FCM_PROVIDED_SCREEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_FCM_PROVIDED_SCREEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_OTHER_PROVIDED_SCREEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_OTHER_PROVIDED_SCREEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_CONTROLLED_BY_FCM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_CONTROLLED_BY_FCM);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_DIRECT_TO_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_DIRECT_TO_EXCHANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_ALGO_ENGINE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_ALGO_ENGINE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PRICE_AT_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PRICE_AT_EXECUTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DESK_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DESK_ELECTRONIC);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DESK_PIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DESK_PIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CLIENT_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CLIENT_ELECTRONIC);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CLIENT_PIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CLIENT_PIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CONDITIONAL_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CONDITIONAL_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_CASH);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DISCRETIONARY_LIMIT_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DISCRETIONARY_LIMIT_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_INTRA_DAY_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_INTRA_DAY_CROSS);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_INTERMARKET_SWEEP_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_INTERMARKET_SWEEP_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MERGER_RELATED_TRANSFER_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MERGER_RELATED_TRANSFER_POSITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_TO_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_TO_LIMIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_NEXT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_OPTIONS_RELATED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_OPTIONS_RELATED_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_SELLERS_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_SELLERS_OPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_STAY_ON_OFFERSIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_STAY_ON_OFFERSIDE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_GO_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_GO_ALONG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PARTICIPATE_DO_NOT_INITIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PARTICIPATE_DO_NOT_INITIATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_STRICT_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_STRICT_SCALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_TRY_TO_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_TRY_TO_SCALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_STAY_ON_BIDSIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_STAY_ON_BIDSIDE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_NO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_NO_CROSS);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_OK_TO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_OK_TO_CROSS);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CALL_FIRST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CALL_FIRST);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PERCENT_OF_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PERCENT_OF_VOLUME);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_REINSTATE_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_REINSTATE_ON_SYSTEM_FAILURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_INSTITUTION_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_INSTITUTION_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_REINSTATE_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_REINSTATE_ON_TRADING_HALT);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CANCEL_ON_TRADING_HALF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CANCEL_ON_TRADING_HALF);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_LAST_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_LAST_PEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MID_PRICE_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MID_PRICE_PEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_NON_NEGOTIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_NON_NEGOTIABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_OPENING_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_OPENING_PEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_MARKET_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_MARKET_PEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CANCEL_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CANCEL_ON_SYSTEM_FAILURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PRIMARY_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PRIMARY_PEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_SUSPEND);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_FIXED_PEG_TO_LOCAL_BBO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_FIXED_PEG_TO_LOCAL_BBO);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PEG_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PEG_TO_VWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_TRADE_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_TRADE_ALONG);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_TRY_TO_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_TRY_TO_STOP);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_CANCEL_IF_NOT_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_CANCEL_IF_NOT_BEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_STRICT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_STRICT_LIMIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_IGNORE_PRICE_VALIDITY_CHECKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_IGNORE_PRICE_VALIDITY_CHECKS);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_PEG_TO_LIMIT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_PEG_TO_LIMIT_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_WORK_TO_TARGET_STRATEGY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_WORK_TO_TARGET_STRATEGY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderHandlingInst_G_ORDER_AND_FCMAP_IOR_FIX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CustOrderHandlingInst_G_ORDER_AND_FCMAP_IOR_FIX);
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderHandlingInstSource_NASDOATS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderHandlingInstSource_NASDOATS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderHandlingInstSource_FINRAOATS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderHandlingInstSource_FINRAOATS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderHandlingInstSource_FIA_EXECUTION_SOURCE_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderHandlingInstSource_FIA_EXECUTION_SOURCE_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_AGENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_ARBITRAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_DERIVATIVES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_DERIVATIVES);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_INTERNATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_INTERNATIONAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_INSTITUTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_INSTITUTIONAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_PREFERRED_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_PREFERRED_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_PROPRIETARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_PROGRAM_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_PROGRAM_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_SALES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_SALES);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_BLOCK_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_BLOCK_TRADING);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_CONVERTIBLE_DESK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_CONVERTIBLE_DESK);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_CENTRAL_RISK_BOOKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_CENTRAL_RISK_BOOKS);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_EQUITY_CAPITAL_MARKETS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_EQUITY_CAPITAL_MARKETS);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_SWAPS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_SWAPS);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_TRADING_DESK_SYSTEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_TRADING_DESK_SYSTEM);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_TREASURY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_TREASURY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskType_FLOOR_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskType_FLOOR_BROKER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskTypeSource_NASDOATS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeskTypeSource_NASDOATS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskTypeSource_FINRAOATS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeskTypeSource_FINRAOATS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_ADD_ON_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_ADD_ON_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_ALL_OR_NONE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_CASH_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_CASH_NOT_HELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_DIRECTED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_DIRECTED_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_FILL_OR_KILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_FILL_OR_KILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_IMBALANCE_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_IMBALANCE_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_IMMEDIATE_OR_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_IMMEDIATE_OR_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_LIMIT_ON_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_LIMIT_ON_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_LIMIT_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_LIMIT_ON_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_MARKET_AT_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_MARKET_AT_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_MARKET_AT_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_MARKET_AT_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_MARKET_ON_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_MARKET_ON_OPEN);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_MARKET_ON_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_MINIMUM_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_MINIMUM_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_NOT_HELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_OVER_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_OVER_THE_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_PEGGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_PEGGED);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_RESERVE_SIZE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_RESERVE_SIZE_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_STOP_STOCK_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_STOP_STOCK_TRANSACTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_SCALE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_TIME_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_TIME_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_TRAILING_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_TRAILING_STOP);
  return _val;
}


SWIGINTERN VALUE
_wrap_DeskOrderHandlingInst_WORK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DeskOrderHandlingInst_WORK);
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecAckStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecAckStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecAckStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecAckStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecAckStatus_DON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecAckStatus_DON));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecAckStatus_DONT_KNOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecAckStatus_DONT_KNOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollApplType_SPECIFIC_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollApplType_SPECIFIC_DEPOSIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollApplType_GENERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollApplType_GENERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingFXRateCalc_DIVIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::UnderlyingFXRateCalc_DIVIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingFXRateCalc_MULTIPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::UnderlyingFXRateCalc_MULTIPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocPositionEffect_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocPositionEffect_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocPositionEffect_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocPositionEffect_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocPositionEffect_ROLLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocPositionEffect_ROLLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocPositionEffect_FIFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocPositionEffect_FIFO));
  return _val;
}


SWIGINTERN VALUE
_wrap_DealingCapacity_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DealingCapacity_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DealingCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DealingCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DealingCapacity_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DealingCapacity_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrmtAssignmentMethod_RANDOM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::InstrmtAssignmentMethod_RANDOM));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrmtAssignmentMethod_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::InstrmtAssignmentMethod_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_AggressorIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AggressorIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_AggressorIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AggressorIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDQuoteType_INDICATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDQuoteType_INDICATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDQuoteType_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDQuoteType_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDQuoteType_RESTRICTED_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDQuoteType_RESTRICTED_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDQuoteType_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDQuoteType_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDQuoteType_INDICATIVE_AND_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDQuoteType_INDICATIVE_AND_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_SECONDARY_ORDER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_SECONDARY_ORDER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_ORDER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_ORDER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_MD_ENTRY_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_MD_ENTRY_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_QUOTE_ENTRY_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_QUOTE_ENTRY_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_ORIGINAL_ORDER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_ORIGINAL_ORDER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_QUOTE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_QUOTE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_QUOTE_REQ_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_QUOTE_REQ_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_PREVIOUS_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_PREVIOUS_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_PREVIOUS_QUOTE_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_PREVIOUS_QUOTE_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_PARENT_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_PARENT_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrderIDSource_MANUAL_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RefOrderIDSource_MANUAL_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayWhen_IMMEDIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayWhen_IMMEDIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayWhen_EXHAUST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayWhen_EXHAUST));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayMethod_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayMethod_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayMethod_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayMethod_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayMethod_RANDOM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayMethod_RANDOM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisplayMethod_UNDISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DisplayMethod_UNDISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceProtectionScope_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PriceProtectionScope_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceProtectionScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PriceProtectionScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceProtectionScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PriceProtectionScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceProtectionScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PriceProtectionScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_LotType_ODD_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LotType_ODD_LOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LotType_ROUND_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LotType_ROUND_LOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LotType_BLOCK_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LotType_BLOCK_LOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LotType_ROUND_LOT_BASED_UPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LotType_ROUND_LOT_BASED_UPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_LAST_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_LAST_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_MID_PRICE_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_MID_PRICE_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_OPENING_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_OPENING_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_MARKET_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_MARKET_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_PRIMARY_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_PRIMARY_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_PEG_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_PEG_TO_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_TRAILING_STOP_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_TRAILING_STOP_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_PEG_TO_LIMIT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_PEG_TO_LIMIT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegPriceType_SHORT_SALE_MIN_PRICE_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegPriceType_SHORT_SALE_MIN_PRICE_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerType_PARTIAL_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerType_PARTIAL_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerType_SPECIFIED_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerType_SPECIFIED_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerType_NEXT_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerType_NEXT_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerType_PRICE_MOVEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerType_PRICE_MOVEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerType_ON_ORDER_ENTRY_OR_MODIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerType_ON_ORDER_ENTRY_OR_MODIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerAction_ACTIVATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerAction_ACTIVATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerAction_MODIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerAction_MODIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerAction_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerAction_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_BEST_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_BEST_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_LAST_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_LAST_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_BEST_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_BEST_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_BEST_BID_OR_LAST_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_BEST_BID_OR_LAST_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_BEST_OFFER_OR_LAST_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_BEST_OFFER_OR_LAST_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceType_BEST_MID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceType_BEST_MID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceTypeScope_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceTypeScope_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceTypeScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceTypeScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceTypeScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceTypeScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceTypeScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceTypeScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceDirection_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceDirection_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerPriceDirection_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerPriceDirection_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerOrderType_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerOrderType_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerOrderType_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TriggerOrderType_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_PRIVATELY_NEGOTIATED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_PRIVATELY_NEGOTIATED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_MULTILEG_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_MULTILEG_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_LINKED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_LINKED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_QUOTE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_QUOTE_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_IMPLIED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_IMPLIED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_CROSS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_CROSS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_STREAMING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_STREAMING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCategory_INTERNAL_CROSS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCategory_INTERNAL_CROSS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_TRADE_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_TRADE_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_TWO_PARTY_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_TWO_PARTY_REPORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_FOR_MATCHING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_ONE_PARTY_REPORT_FOR_MATCHING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_FOR_PASS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_ONE_PARTY_REPORT_FOR_PASS_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_AUTOMATED_FLOOR_ORDER_ROUTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_AUTOMATED_FLOOR_ORDER_ROUTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_TWO_PARTY_REPORT_FOR_CLAIM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_TWO_PARTY_REPORT_FOR_CLAIM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_ONE_PARTY_REPORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_THIRD_PTY_RPT_FOR_PASS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_THIRD_PTY_RPT_FOR_PASS_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_AUTO_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeHandlingInstr_ONE_PARTY_REPORT_AUTO_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationIDSource_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestinationIDSource_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationIDSource_GENERAL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestinationIDSource_GENERAL_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationIDSource_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestinationIDSource_PROPRIETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationIDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestinationIDSource_ISO_COUNTRY_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationIDSource_MIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExDestinationIDSource_MIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationQtyType_AUTO_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationQtyType_AUTO_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationQtyType_NON_AUTO_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationQtyType_NON_AUTO_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationQtyType_FINAL_WILL_BE_EXERCISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationQtyType_FINAL_WILL_BE_EXERCISED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationQtyType_CONTRARY_INTENTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationQtyType_CONTRARY_INTENTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationQtyType_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationQtyType_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_BILLION_CUBIC_FEET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_BILLION_CUBIC_FEET);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MILLION_BARRELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MILLION_BARRELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ONE_MILLION_BTU_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ONE_MILLION_BTU);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_BARRELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_BARRELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_BUSHELS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_BUSHELS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_POUNDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_POUNDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GALLONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GALLONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_TROY_OUNCES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_TROY_OUNCES);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_METRIC_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_METRIC_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_US_DOLLARS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_US_DOLLARS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CUBIC_METERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CUBIC_METERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GIGAJOULES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GIGAJOULES);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_HEAT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_HEAT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_HOURS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGA_HEAT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGA_HEAT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_THERMS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_THERMS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_TONS_OF_CARBON_DIOXIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_TONS_OF_CARBON_DIOXIDE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ALLOWANCES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ALLOWANCES);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_BOARD_FEET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_BOARD_FEET);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CURRENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_COOLING_DEGREE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_COOLING_DEGREE_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CERTIFIED_EMISSIONS_REDUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CERTIFIED_EMISSIONS_REDUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CRITICAL_PRECIP_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CRITICAL_PRECIP_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CLIMATE_RESERVE_TONNES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CLIMATE_RESERVE_TONNES);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_HUNDREDWEIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_HUNDREDWEIGHT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_DRY_METRIC_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_DRY_METRIC_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ENV_ALLWNC_CERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ENV_ALLWNC_CERT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ENVIRONMENTAL_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ENVIRONMENTAL_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ENVIRONMENTAL_OFFSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ENVIRONMENTAL_OFFSET);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GRAMS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GRAMS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GROSS_TONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GROSS_TONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_HEATING_DEGREE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_HEATING_DEGREE_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_INDEX_POINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_INDEX_POINT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOGRAMS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOGRAMS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOLITERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOLITERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_HOUR);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOWATT_MINUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOWATT_MINUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_LITERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_LITERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_HOUR);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MEGAWATT_MINUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MEGAWATT_MINUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_PRINCIPAL_WITH_RELATION_TO_DEBT_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_PRINCIPAL_WITH_RELATION_TO_DEBT_INSTRUMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ARE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ARE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_ACRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_ACRE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CENTILITER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CENTILITER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_CENTIMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_CENTIMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_DIESEL_GALLON_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_DIESEL_GALLON_EQUIVALENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_FOOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_FOOT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GB_GALLON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GB_GALLON);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GASOLINE_GALLON_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GASOLINE_GALLON_EQUIVALENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_HECTARE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_HECTARE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_INCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_INCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_KILOMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_KILOMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_METER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_METER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MILLILITER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MILLILITER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_MILLIMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_MILLIMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_US_OUNCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_US_OUNCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_PIECE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_PIECE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_US_PINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_US_PINT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GB_PINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GB_PINT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_US_QUART_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_US_QUART);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_GB_QUART_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_GB_QUART);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_CENTIMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_CENTIMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_FOOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_FOOT);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_INCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_INCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_KILOMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_KILOMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_METER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_METER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_MILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_MILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_MILLIMETER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_MILLIMETER);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_SQUARE_YARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_SQUARE_YARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnitOfMeasure_YARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnitOfMeasure_YARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_ImpliedMarketIndicator_NOT_IMPLIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ImpliedMarketIndicator_NOT_IMPLIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ImpliedMarketIndicator_IMPLIED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ImpliedMarketIndicator_IMPLIED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ImpliedMarketIndicator_IMPLIED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ImpliedMarketIndicator_IMPLIED_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ImpliedMarketIndicator_BOTH_IMPLIED_IN_AND_IMPLIED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ImpliedMarketIndicator_BOTH_IMPLIED_IN_AND_IMPLIED_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligMode_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlObligMode_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligMode_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlObligMode_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligTransType_RESTATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligTransType_RESTATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligSource_INSTRUCTIONS_OF_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligSource_INSTRUCTIONS_OF_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligSource_INSTRUCTIONS_FOR_INSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligSource_INSTRUCTIONS_FOR_INSTITUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligSource_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligSource_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligSource_BUYERS_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligSource_BUYERS_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlObligSource_SELLERS_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlObligSource_SELLERS_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_REMOVED_FROM_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_REMOVED_FROM_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_LOCKED_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_LOCKED_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_CROSS_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_CROSS_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_CANCELED_DUE_TO_LOCK_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_CANCELED_DUE_TO_LOCK_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_CANCELED_DUE_TO_CROSS_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_CANCELED_DUE_TO_CROSS_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryStatus_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PrivateQuote_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PrivateQuote_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PrivateQuote_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PrivateQuote_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_RespondentType_ALL_MARKET_PARTICIPANTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RespondentType_ALL_MARKET_PARTICIPANTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RespondentType_SPECIFIED_MARKET_PARTICIPANTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RespondentType_SPECIFIED_MARKET_PARTICIPANTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RespondentType_ALL_MARKET_MAKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RespondentType_ALL_MARKET_MAKERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RespondentType_PRIMARY_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RespondentType_PRIMARY_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_ORDER_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_ORDER_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_TRADING_RESUMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_TRADING_RESUMES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_PRICE_VOLATILITY_INTERRUPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_PRICE_VOLATILITY_INTERRUPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CHANGE_OF_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CHANGE_OF_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CHANGE_OF_TRADING_SUBSESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CHANGE_OF_TRADING_SUBSESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CHANGE_OF_SECURITY_TRADING_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CHANGE_OF_SECURITY_TRADING_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CHANGE_OF_BOOK_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CHANGE_OF_BOOK_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CHANGE_OF_MARKET_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CHANGE_OF_MARKET_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingEvent_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingEvent_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatsType_EXCHANGE_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatsType_EXCHANGE_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatsType_HIGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatsType_HIGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatsType_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatsType_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatsType_TURNOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatsType_TURNOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDSecSizeType_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDSecSizeType_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDSecSizeType_CUSTOMER_PROFESSIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDSecSizeType_CUSTOMER_PROFESSIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDSecSizeType_DO_NOT_TRADE_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDSecSizeType_DO_NOT_TRADE_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlMethod_CASH_SETTLEMENT_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlMethod_CASH_SETTLEMENT_REQUIRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlMethod_PHYSICAL_SETTLEMENT_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlMethod_PHYSICAL_SETTLEMENT_REQUIRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlMethod_ELECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlMethod_ELECTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseStyle_EUROPEAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseStyle_EUROPEAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseStyle_AMERICAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseStyle_AMERICAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseStyle_BERMUDA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseStyle_BERMUDA));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseStyle_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseStyle_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQuoteMethod_STANDARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PriceQuoteMethod_STANDARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQuoteMethod_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PriceQuoteMethod_INDEX);
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQuoteMethod_INTEREST_RATE_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PriceQuoteMethod_INTEREST_RATE_INDEX);
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQuoteMethod_PERCENT_OF_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PriceQuoteMethod_PERCENT_OF_PAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_FuturesValuationMethod_PREMIUM_STYLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FuturesValuationMethod_PREMIUM_STYLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_FuturesValuationMethod_FUTURES_STYLE_MARK_TO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FuturesValuationMethod_FUTURES_STYLE_MARK_TO_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_FuturesValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FuturesValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ListMethod_PRE_LISTED_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListMethod_PRE_LISTED_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListMethod_USER_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListMethod_USER_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_VARIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_VARIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_TRADED_AS_A_SPREAD_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_TRADED_AS_A_SPREAD_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_SETTLED_AS_A_SPREAD_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_SETTLED_AS_A_SPREAD_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_REGULAR_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_REGULAR_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_VARIABLE_CABINET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_VARIABLE_CABINET));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_FIXED_CABINET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_FIXED_CABINET));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickRuleType_TRADED_AS_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TickRuleType_TRADED_AS_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearIncrementUnits_MONTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearIncrementUnits_MONTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearIncrementUnits_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearIncrementUnits_DAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearIncrementUnits_WEEKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearIncrementUnits_WEEKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearIncrementUnits_YEARS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearIncrementUnits_YEARS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearFormat_YEAR_MONTH_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearFormat_YEAR_MONTH_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearFormat_YEAR_MONTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearFormat_YEAR_MONTH_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MaturityMonthYearFormat_YEAR_MONTH_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MaturityMonthYearFormat_YEAR_MONTH_WEEK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceLimitType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceLimitType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceLimitType_TICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceLimitType_TICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceLimitType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceLimitType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListUpdateAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListUpdateAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListUpdateAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListUpdateAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListUpdateAction_MODIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListUpdateAction_MODIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListUpdateAction_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListUpdateAction_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketUpdateAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MarketUpdateAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketUpdateAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MarketUpdateAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketUpdateAction_MODIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MarketUpdateAction_MODIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesEvent_TRADING_RESUMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesEvent_TRADING_RESUMES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesEvent_CHANGE_OF_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesEvent_CHANGE_OF_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesEvent_CHANGE_OF_TRADING_SUBSESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesEvent_CHANGE_OF_TRADING_SUBSESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesEvent_CHANGE_OF_TRADING_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesEvent_CHANGE_OF_TRADING_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionType_SUSPEND_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionType_SUSPEND_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionType_RELEASE_ORDERS_FROM_SUSPENSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionType_RELEASE_ORDERS_FROM_SUSPENSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionType_CANCEL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionType_CANCEL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_ACFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_ACFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_ALL_ORDERS_FOR_A_SECURITY_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_CANCEL_FOR_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_CANCEL_FOR_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionScope_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionScope_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionResponse_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionResponse_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionResponse_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionResponse_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionResponse_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionResponse_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_MASS_ACTION_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_MASS_ACTION_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_CFI_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_CFI_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegModel_PREDEFINED_MULTILEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegModel_PREDEFINED_MULTILEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegModel_USER_DEFINED_MULTILEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegModel_USER_DEFINED_MULTILEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegModel_USER_DEFINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegModel_USER_DEFINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_NET_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_NET_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_REVERSED_NET_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_REVERSED_NET_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_YIELD_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_YIELD_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_INDIVIDUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_INDIVIDUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_CONTRACT_WEIGHTED_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_CONTRACT_WEIGHTED_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultilegPriceMethod_MULTIPLIED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultilegPriceMethod_MULTIPLIED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_ONE_CANCELS_THE_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_ONE_CANCELS_THE_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_ONE_TRIGGERS_THE_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_ONE_TRIGGERS_THE_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_ONE_UPDATES_THE_OTHER_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_ONE_UPDATES_THE_OTHER_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_ONE_UPDATES_THE_OTHER_PROPORTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_ONE_UPDATES_THE_OTHER_PROPORTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_BID_AND_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_BID_AND_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContingencyType_BID_AND_OFFER_OCO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContingencyType_BID_AND_OFFER_OCO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_BROKER_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_BROKER_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_UNKNOWN_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_UNKNOWN_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_DUPLICATE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_DUPLICATE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_UNSUPPORTED_ORDER_CHARACTERISTIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePublishIndicator_DO_NOT_PUBLISH_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePublishIndicator_DO_NOT_PUBLISH_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePublishIndicator_PUBLISH_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePublishIndicator_PUBLISH_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePublishIndicator_DEFERRED_PUBLICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePublishIndicator_DEFERRED_PUBLICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePublishIndicator_PUBLISHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePublishIndicator_PUBLISHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_RETRANSMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_RETRANSMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_SUBSCRIPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_SUBSCRIPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_REQUEST_LAST_SEQ_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_REQUEST_LAST_SEQ_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_REQUEST_APPLICATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_REQUEST_APPLICATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_UNSUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_UNSUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_CANCEL_RETRANSMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_CANCEL_RETRANSMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReqType_CANCEL_RETRANSMISSION_UNSUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReqType_CANCEL_RETRANSMISSION_UNSUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseType_REQUEST_SUCCESSFULLY_PROCESSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseType_REQUEST_SUCCESSFULLY_PROCESSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseType_APPLICATION_DOES_NOT_EXIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseType_APPLICATION_DOES_NOT_EXIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseType_MESSAGES_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseType_MESSAGES_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseError_APPLICATION_DOES_NOT_EXIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseError_APPLICATION_DOES_NOT_EXIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseError_MESSAGES_REQUESTED_ARE_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseError_MESSAGES_REQUESTED_ARE_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplResponseError_USER_NOT_AUTHORIZED_FOR_APPLICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplResponseError_USER_NOT_AUTHORIZED_FOR_APPLICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReportType_APPL_SEQ_NUM_RESET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReportType_APPL_SEQ_NUM_RESET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReportType_LAST_MESSAGE_SENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReportType_LAST_MESSAGE_SENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReportType_APPLICATION_ALIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReportType_APPLICATION_ALIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplReportType_RESEND_COMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplReportType_RESEND_COMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_NEWS_DISSEMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_NEWS_DISSEMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_ORDER_INFLUX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_ORDER_INFLUX));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_ORDER_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_ORDER_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_ADDITIONAL_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_ADDITIONAL_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_NEWS_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_NEWS_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReasonInt_EQUIPMENT_CHANGEOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::HaltReasonInt_EQUIPMENT_CHANGEOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValuationMethod_PREMIUM_STYLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ValuationMethod_PREMIUM_STYLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ValuationMethod_FUTURES_STYLE_MARK_TO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ValuationMethod_FUTURES_STYLE_MARK_TO_MARKET);
  return _val;
}


SWIGINTERN VALUE
_wrap_ValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ValuationMethod_CDS_STYLE_COLLATERALIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ValuationMethod_CDS_STYLE_COLLATERALIZATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_ValuationMethod_CDS_IN_DELIVERY_USE_RECOVERY_RATE_TO_CALCULATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ValuationMethod_CDS_IN_DELIVERY_USE_RECOVERY_RATE_TO_CALCULATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_SECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_SECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_TENTHS_OF_A_SECOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_TENTHS_OF_A_SECOND));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_HUNDREDTHS_OF_A_SECOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_HUNDREDTHS_OF_A_SECOND));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_MILLISECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_MILLISECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_MICROSECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_MICROSECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_NANOSECONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_NANOSECONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_MINUTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_MINUTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_HOURS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_DAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_WEEKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_WEEKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_MONTHS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_MONTHS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderDelayUnit_YEARS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderDelayUnit_YEARS));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_PIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_PIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_EX_PIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_EX_PIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_CLEARING_HOUSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_CLEARING_HOUSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_REGISTERED_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_REGISTERED_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_OFF_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_OFF_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_CENTRAL_LIMIT_ORDER_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_CENTRAL_LIMIT_ORDER_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_QUOTE_DRIVEN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_QUOTE_DRIVEN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_DARK_ORDER_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_DARK_ORDER_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_AUCTION_DRIVEN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_AUCTION_DRIVEN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_QUOTE_NEGOTIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_QUOTE_NEGOTIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_VOICE_NEGOTIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_VOICE_NEGOTIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_HYBRID_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_HYBRID_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_VenueType_OTHER_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::VenueType_OTHER_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrdIDReason_GTC_FROM_PREVIOUS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefOrdIDReason_GTC_FROM_PREVIOUS_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrdIDReason_PARTIAL_FILL_REMAINING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefOrdIDReason_PARTIAL_FILL_REMAINING));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefOrdIDReason_ORDER_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefOrdIDReason_ORDER_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrigCustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrigCustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrigCustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrigCustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrigCustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrigCustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrigCustOrderCapacity_ALL_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrigCustOrderCapacity_ALL_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ModelType_UTILITY_PROVIDED_STANDARD_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ModelType_UTILITY_PROVIDED_STANDARD_MODEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ModelType_PROPRIETARY_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ModelType_PROPRIETARY_MODEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractMultiplierUnit_SHARES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractMultiplierUnit_SHARES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractMultiplierUnit_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractMultiplierUnit_HOURS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractMultiplierUnit_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractMultiplierUnit_DAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_NERC_EASTERN_OFF_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_NERC_EASTERN_OFF_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_NERC_WESTERN_OFF_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_NERC_WESTERN_OFF_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_NERC_CALENDAR_ALL_DAYS_IN_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_NERC_CALENDAR_ALL_DAYS_IN_MONTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_NERC_EASTERN_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_NERC_EASTERN_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_NERC_WESTERN_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_NERC_WESTERN_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_ALL_TIMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_ALL_TIMES));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_ON_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_ON_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_OFF_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_OFF_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_BASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_BASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_BLOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_BLOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_FlowScheduleType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FlowScheduleType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSource_BLOOMBERG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSource_BLOOMBERG));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSource_REUTERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSource_REUTERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSource_TELERATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSource_TELERATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSource_ISDA_RATE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSource_ISDA_RATE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSource_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSource_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSourceType_PRIMARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSourceType_PRIMARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RateSourceType_SECONDARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RateSourceType_SECONDARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RestructuringType_FULL_RESTRUCTURING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RestructuringType_FULL_RESTRUCTURING);
  return _val;
}


SWIGINTERN VALUE
_wrap_RestructuringType_MODIFIED_RESTRUCTURING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RestructuringType_MODIFIED_RESTRUCTURING);
  return _val;
}


SWIGINTERN VALUE
_wrap_RestructuringType_MODIFIED_MOD_RESTRUCTURING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RestructuringType_MODIFIED_MOD_RESTRUCTURING);
  return _val;
}


SWIGINTERN VALUE
_wrap_RestructuringType_NO_RESTRUCTURING_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RestructuringType_NO_RESTRUCTURING_SPECIFIED);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_SENIOR_SECURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_SENIOR_SECURED);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_SENIOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_SENIOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_SUBORDINATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_SUBORDINATED);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_JUNIOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_JUNIOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_MEZZANINE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_MEZZANINE);
  return _val;
}


SWIGINTERN VALUE
_wrap_Seniority_SENIOR_NON_PREFERRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::Seniority_SENIOR_NON_PREFERRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListType_INDUSTRY_CLASSIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListType_INDUSTRY_CLASSIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListType_TRADING_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListType_TRADING_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListType_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListType_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListType_NEWSPAPER_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListType_NEWSPAPER_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListTypeSource_ICB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListTypeSource_ICB));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListTypeSource_NAICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListTypeSource_NAICS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListTypeSource_GICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListTypeSource_GICS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsCategory_COMPANY_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsCategory_COMPANY_NEWS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsCategory_MARKETPLACE_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsCategory_MARKETPLACE_NEWS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsCategory_FINANCIAL_MARKET_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsCategory_FINANCIAL_MARKET_NEWS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsCategory_TECHNICAL_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsCategory_TECHNICAL_NEWS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsCategory_OTHER_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsCategory_OTHER_NEWS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsRefType_REPLACEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsRefType_REPLACEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsRefType_OTHER_LANGUAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsRefType_OTHER_LANGUAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsRefType_COMPLIMENTARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsRefType_COMPLIMENTARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_NewsRefType_WITHDRAWAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NewsRefType_WITHDRAWAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceDeterminationMethod_FIXED_STRIKE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceDeterminationMethod_FIXED_STRIKE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceDeterminationMethod_STRIKE_SET_AT_EXPIRATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceDeterminationMethod_STRIKE_SET_AT_EXPIRATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceDeterminationMethod_STRIKE_SET_TO_AVERAGE_ACROSS_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceDeterminationMethod_STRIKE_SET_TO_AVERAGE_ACROSS_LIFE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceDeterminationMethod_STRIKE_SET_TO_OPTIMAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceDeterminationMethod_STRIKE_SET_TO_OPTIMAL_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceBoundaryMethod_LESS_THAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceBoundaryMethod_LESS_THAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceBoundaryMethod_LESS_THAN_OR_EQUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceBoundaryMethod_LESS_THAN_OR_EQUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceBoundaryMethod_EQUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceBoundaryMethod_EQUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceBoundaryMethod_GREATER_THAN_OR_EQUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceBoundaryMethod_GREATER_THAN_OR_EQUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikePriceBoundaryMethod_GREATER_THAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikePriceBoundaryMethod_GREATER_THAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingPriceDeterminationMethod_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingPriceDeterminationMethod_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingPriceDeterminationMethod_SPECIAL_REFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingPriceDeterminationMethod_SPECIAL_REFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingPriceDeterminationMethod_OPTIMAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingPriceDeterminationMethod_OPTIMAL_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingPriceDeterminationMethod_AVERAGE_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingPriceDeterminationMethod_AVERAGE_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_VANILLA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_VANILLA));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_CAPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_CAPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_BINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_BINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_ASIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_ASIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_BARRIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_BARRIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_DIGITAL_BARRIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_DIGITAL_BARRIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_LOOKBACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_LOOKBACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_OTHER_PATH_DEPENDENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_OTHER_PATH_DEPENDENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptPayoutType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptPayoutType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_CAPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_CAPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_TRIGGER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_TRIGGER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_KNOCK_IN_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_KNOCK_IN_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_KNOCK_IN_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_KNOCK_IN_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_KNOCK_OUT_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_KNOCK_OUT_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_KNOCK_OUT_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_KNOCK_OUT_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_RESET_BARRIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_RESET_BARRIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_ROLLING_BARRIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_ROLLING_BARRIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_ONE_TOUCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_ONE_TOUCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_NO_TOUCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_NO_TOUCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_DBL_ONE_TOUCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_DBL_ONE_TOUCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_DBL_NO_TOUCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_DBL_NO_TOUCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_FX_COMPOSITE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_FX_COMPOSITE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_FX_QUANTO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_FX_QUANTO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_FX_CRSS_CCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_FX_CRSS_CCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_STRK_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_STRK_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_CLNDR_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_CLNDR_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_PX_OBSVTN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_PX_OBSVTN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_PASS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_PASS_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_STRK_SCHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_STRK_SCHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_EQUITY_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_EQUITY_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventType_DIVIDEND_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventType_DIVIDEND_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceBoundaryMethod_LESS_THAN_COMPLEX_EVENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceBoundaryMethod_LESS_THAN_COMPLEX_EVENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceBoundaryMethod_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceBoundaryMethod_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceBoundaryMethod_EQUAL_TO_COMPLEX_EVENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceBoundaryMethod_EQUAL_TO_COMPLEX_EVENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceBoundaryMethod_GREATER_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceBoundaryMethod_GREATER_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceBoundaryMethod_GREATER_THAN_COMPLEX_EVENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceBoundaryMethod_GREATER_THAN_COMPLEX_EVENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_EXPIRATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_EXPIRATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_IMMEDIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_IMMEDIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_SPECIFIED_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_SPECIFIED_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_OFFICIAL_SETTL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_OFFICIAL_SETTL_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_DERIVATIVES_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_DERIVATIVES_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPriceTimeType_AS_SPECIFIED_MASTER_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPriceTimeType_AS_SPECIFIED_MASTER_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventCondition_AND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventCondition_AND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventCondition_OR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventCondition_OR));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_NEW_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_NEW_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_EXISTING_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_EXISTING_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnRejReason_UNKNOWN_CLIENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnRejReason_UNKNOWN_CLIENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnRejReason_EXCEEDS_MAXIMUM_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnRejReason_EXCEEDS_MAXIMUM_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnRejReason_UNKNOWN_OR_INVALID_CURRENCY_PAIR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnRejReason_UNKNOWN_OR_INVALID_CURRENCY_PAIR));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnRejReason_NO_AVAILABLE_STREAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnRejReason_NO_AVAILABLE_STREAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnAckType_ASSIGNMENT_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnAckType_ASSIGNMENT_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnAckType_ASSIGNMENT_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnAckType_ASSIGNMENT_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnType_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnType_ASSIGNMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnType_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnType_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamAsgnType_TERMINATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamAsgnType_TERMINATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchInst_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchInst_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchInst_DO_NOT_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchInst_DO_NOT_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_THIS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_THIS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_OTHER_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_OTHER_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_PRICE_AND_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_PRICE_AND_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_CREDIT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_CREDIT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_GROSS_POSITION_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_GROSS_POSITION_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_NET_POSITION_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_NET_POSITION_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_RISK_EXPOSURE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_RISK_EXPOSURE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_LONG_POSITION_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_LONG_POSITION_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LimitAmtType_SHORT_POSITION_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LimitAmtType_SHORT_POSITION_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqQualifier_SUMMARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqQualifier_SUMMARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqQualifier_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqQualifier_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqQualifier_EXCESS_DEFICIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqQualifier_EXCESS_DEFICIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqQualifier_NET_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqQualifier_NET_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtRptType_SUMMARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtRptType_SUMMARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtRptType_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtRptType_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtRptType_EXCESS_DEFICIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtRptType_EXCESS_DEFICIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_INVALID_OR_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_INVALID_OR_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_INVALID_OR_UNKNOWN_MARGIN_CLASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_INVALID_OR_UNKNOWN_MARGIN_CLASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_INVALID_TRANSPORT_TYPE_REQ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_INVALID_TRANSPORT_TYPE_REQ));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_INVALID_DESTINATION_REQ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_INVALID_DESTINATION_REQ));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_NO_MARGIN_REQ_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_NO_MARGIN_REQ_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_MARGIN_REQ_INQUIRY_QUALIFIER_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_MARGIN_REQ_INQUIRY_QUALIFIER_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_UNAUTHORIZED_FOR_MARGIN_REQ_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_UNAUTHORIZED_FOR_MARGIN_REQ_INQUIRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginReqmtInqResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginReqmtInqResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_ADDITIONAL_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_ADDITIONAL_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_ADJUSTED_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_ADJUSTED_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_UNADJUSTED_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_UNADJUSTED_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_BINARY_ADD_ON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_BINARY_ADD_ON_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_CASH_BALANCE_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_CASH_BALANCE_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_CONCENTRATION_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_CONCENTRATION_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_CORE_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_CORE_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_DELIVERY_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_DELIVERY_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_DISCRETIONARY_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_DISCRETIONARY_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_FUTURES_SPREAD_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_FUTURES_SPREAD_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_INITIAL_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_INITIAL_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_LIQUIDATING_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_LIQUIDATING_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_MARGIN_CALL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_MARGIN_CALL_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_MARGIN_DEFICIT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_MARGIN_DEFICIT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_MARGIN_EXCESS_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_MARGIN_EXCESS_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_OPTION_PREMIUM_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_OPTION_PREMIUM_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_PREMIUM_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_PREMIUM_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_RESERVE_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_RESERVE_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SECURITY_COLLATERAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SECURITY_COLLATERAL_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_STRESS_TEST_ADD_ON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_STRESS_TEST_ADD_ON_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SUPER_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SUPER_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_TOTAL_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_TOTAL_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_VARIATION_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_VARIATION_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SECONDARY_VARIATION_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SECONDARY_VARIATION_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_ROLLED_UP_MARGIN_DEFICIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_ROLLED_UP_MARGIN_DEFICIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SPREAD_RESPONSE_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SPREAD_RESPONSE_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SYSTEMIC_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SYSTEMIC_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_CURVE_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_CURVE_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_INDEX_SPREAD_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_INDEX_SPREAD_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_SECTOR_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_SECTOR_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_JUMP_TO_DEFAULT_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_JUMP_TO_DEFAULT_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_BASIS_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_BASIS_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_INTEREST_RATE_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_INTEREST_RATE_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_JUMP_TO_HEALTH_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_JUMP_TO_HEALTH_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginAmtType_OTHER_RISK_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginAmtType_OTHER_RISK_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_HEDGES_FOR_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_HEDGES_FOR_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_UNDERLIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_UNDERLIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_EQUITY_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_EQUITY_EQUIVALENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_NEAREST_EXCHANGE_TRADED_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_NEAREST_EXCHANGE_TRADED_CONTRACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_RETAIL_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_RETAIL_EQUIVALENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedInstrumentType_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedInstrumentType_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketMakerActivity_NO_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketMakerActivity_NO_PARTICIPATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketMakerActivity_BUY_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketMakerActivity_BUY_PARTICIPATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketMakerActivity_SELL_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketMakerActivity_SELL_PARTICIPATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketMakerActivity_BOTH_BUY_AND_SELL_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketMakerActivity_BOTH_BUY_AND_SELL_PARTICIPATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_VALID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_VALID_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_INVALID_OR_UNSUPPORTED_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_NO_DATA_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_NO_DATA_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_DATA_TEMPORARILY_UNAVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_DATA_TEMPORARILY_UNAVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_REQUEST_FOR_DATA_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_REQUEST_FOR_DATA_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_IS_ALSO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_IS_ALSO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_CLEARS_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_CLEARS_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_CLEARS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_CLEARS_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_TRADES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_TRADES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_TRADES_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_TRADES_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_SPONSORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_SPONSORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_SPONSORED_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_SPONSORED_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PROVIDES_GUARANTEE_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PROVIDES_GUARANTEE_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_IS_GUARANTEED_BY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_IS_GUARANTEED_BY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_MEMBER_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_MEMBER_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_HAS_MEMBERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_HAS_MEMBERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PROVIDES_MARKETPLACE_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PROVIDES_MARKETPLACE_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PARTICIPANT_OF_MARKETPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PARTICIPANT_OF_MARKETPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_CARRIES_POSITIONS_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_CARRIES_POSITIONS_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_POSTS_TRADES_TO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_POSTS_TRADES_TO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_ENTERS_TRADES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_ENTERS_TRADES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_ENTERS_TRADES_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_ENTERS_TRADES_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PROVIDES_QUOTES_TO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PROVIDES_QUOTES_TO));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_REQUESTS_QUOTES_FROM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_REQUESTS_QUOTES_FROM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_INVESTS_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_INVESTS_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_INVESTS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_INVESTS_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_BROKERS_TRADES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_BROKERS_TRADES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_BROKERS_TRADES_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_BROKERS_TRADES_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PROVIDES_TRADING_SERVICES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PROVIDES_TRADING_SERVICES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_USES_TRADING_SERVICES_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_USES_TRADING_SERVICES_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_APPROVES_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_APPROVES_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_APPROVED_BY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_APPROVED_BY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_PARENT_FIRM_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_PARENT_FIRM_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_SUBSIDIARY_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_SUBSIDIARY_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_REGULATORY_OWNER_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_REGULATORY_OWNER_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_OWNED_BY_REGULATORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_OWNED_BY_REGULATORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_CONTROLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_CONTROLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_IS_CONTROLLED_BY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_IS_CONTROLLED_BY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_LEGAL_OWNER_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_LEGAL_OWNER_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_OWNED_BY_LEGAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_OWNED_BY_LEGAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_BENEFICIAL_OWNER_OF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_BENEFICIAL_OWNER_OF));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_OWNED_BY_BENEFICIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_OWNED_BY_BENEFICIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_SETTLES_FOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_SETTLES_FOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRelationship_SETTLES_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRelationship_SETTLES_THROUGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_CREDIT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_CREDIT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_GROSS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_GROSS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_NET_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_NET_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_EXPOSURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_EXPOSURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_LONG_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_LONG_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_SHORT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_SHORT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_CASH_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_CASH_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_ADDITIONAL_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_ADDITIONAL_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_TOTAL_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_TOTAL_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_LIMIT_CONSUMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_LIMIT_CONSUMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_CLIP_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_CLIP_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_MAX_NOTIONAL_ORDER_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_MAX_NOTIONAL_ORDER_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_DV01_PV01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_DV01_PV01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_CS01_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_CS01_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_VOLUME_LIMIT_PER_TIME_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_VOLUME_LIMIT_PER_TIME_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_VOL_FILLED_PCT_ORD_VOL_TM_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_VOL_FILLED_PCT_ORD_VOL_TM_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_NOTL_FILLED_PCT_NOTL_TM_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_NOTL_FILLED_PCT_NOTL_TM_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitType_TRANSACTION_EXECUTION_LIMIT_PER_TIME_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitType_TRANSACTION_EXECUTION_LIMIT_PER_TIME_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrumentScopeOperator_INCLUDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrumentScopeOperator_INCLUDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrumentScopeOperator_EXCLUDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrumentScopeOperator_EXCLUDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailStatus_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailStatus_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailStatus_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailStatus_HALTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailStatus_HALTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_FIRM_OR_LEGAL_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_FIRM_OR_LEGAL_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_CURRENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_CURRENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_NATURAL_PERSON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_NATURAL_PERSON));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_EXCHANGE_ORDER_SUBMITTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_EXCHANGE_ORDER_SUBMITTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_PRIMARY_TRD_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_PRIMARY_TRD_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_ORIG_TRD_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_ORIG_TRD_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_ADDTNL_INTL_TRD_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_ADDTNL_INTL_TRD_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_ADDTNL_DOMESTIC_TRD_REPOSITORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_ADDTNL_DOMESTIC_TRD_REPOSITORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_REGULAR_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_REGULAR_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_HEAD_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_HEAD_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_SUPERVISOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_SUPERVISOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_ALGORITHM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_ALGORITHM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_RELATED_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_RELATED_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_OPTIONS_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_OPTIONS_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_SPECIFIED_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_SPECIFIED_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_CONSTITUENT_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_CONSTITUENT_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_BANK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_BANK));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_HUB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_HUB));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_TRI_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_TRI_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_LENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_LENDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_GENERAL_CLEARING_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_GENERAL_CLEARING_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_INDIVIDUAL_CLEARING_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_INDIVIDUAL_CLEARING_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_PREFERRED_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_PREFERRED_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_DIRECTED_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_DIRECTED_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_DESIGNATED_SPONSOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_DESIGNATED_SPONSOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_SPECIALIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_SPECIALIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRoleQualifier_EXEMPT_FROM_TRADE_REPORTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRoleQualifier_EXEMPT_FROM_TRADE_REPORTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdAckStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdAckStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdAckStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdAckStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdAckStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdAckStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_CREDIT_CONTROLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_CREDIT_CONTROLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_ENTITLEMENT_OR_ELIGIBILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_ENTITLEMENT_OR_ELIGIBILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_MARKET_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_MARKET_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_ACCOUNT_SELECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_ACCOUNT_SELECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_DELIVERY_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_DELIVERY_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityClassificationReason_SECTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityClassificationReason_SECTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_OPTIONS_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_OPTIONS_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_PENDING_EROSION_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_PENDING_EROSION_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_FINAL_EROSION_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_FINAL_EROSION_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_TEAR_UP_COUPON_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_TEAR_UP_COUPON_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_PRICE_ALIGNMENT_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_PRICE_ALIGNMENT_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_DELIVERY_INVOICE_CHARGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_DELIVERY_INVOICE_CHARGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtReason_DELIVERY_STORAGE_CHARGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosAmtReason_DELIVERY_STORAGE_CHARGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideClearingTradePriceType_TRADE_CLEARING_AT_EXECUTION_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideClearingTradePriceType_TRADE_CLEARING_AT_EXECUTION_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideClearingTradePriceType_TRADE_CLEARING_AT_ALTERNATE_CLEARING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideClearingTradePriceType_TRADE_CLEARING_AT_ALTERNATE_CLEARING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_INSTRUMENT_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_INSTRUMENT_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INSTRUMENT_ALREADY_EXISTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INSTRUMENT_ALREADY_EXISTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_REQUEST_TYPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_REQUEST_TYPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_SYSTEM_UNAVAILABLE_FOR_INSTRUMENT_CREATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_SYSTEM_UNAVAILABLE_FOR_INSTRUMENT_CREATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INELIGIBLE_INSTRUMENT_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INELIGIBLE_INSTRUMENT_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INSTRUMENT_ID_UNAVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INSTRUMENT_ID_UNAVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_OPTION_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_OPTION_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FUTURE_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FUTURE_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FX_LEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FX_LEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_LEG_PRICE_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_LEG_PRICE_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRejectReason_INVALID_INSTRUMENT_STRUCTURE_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRejectReason_INVALID_INSTRUMENT_STRUCTURE_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleStatus_THROTTLE_LIMIT_NOT_EXCEEDED_NOT_QUEUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleStatus_THROTTLE_LIMIT_NOT_EXCEEDED_NOT_QUEUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleStatus_QUEUED_DUE_TO_THROTTLE_LIMIT_EXCEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleStatus_QUEUED_DUE_TO_THROTTLE_LIMIT_EXCEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleAction_QUEUE_INBOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleAction_QUEUE_INBOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleAction_QUEUE_OUTBOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleAction_QUEUE_OUTBOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleAction_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleAction_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleAction_DISCONNECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleAction_DISCONNECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleAction_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleAction_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleType_INBOUND_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleType_INBOUND_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleType_OUTSTANDING_REQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleType_OUTSTANDING_REQUESTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleInst_REJECT_IF_THROTTLE_LIMIT_EXCEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleInst_REJECT_IF_THROTTLE_LIMIT_EXCEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleInst_QUEUE_IF_THROTTLE_LIMIT_EXCEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleInst_QUEUE_IF_THROTTLE_LIMIT_EXCEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleCountIndicator_OUTSTANDING_REQUESTS_UNCHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleCountIndicator_OUTSTANDING_REQUESTS_UNCHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ThrottleCountIndicator_OUTSTANDING_REQUESTS_DECREASED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ThrottleCountIndicator_OUTSTANDING_REQUESTS_DECREASED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocationRollupInstruction_ROLLUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocationRollupInstruction_ROLLUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocationRollupInstruction_DO_NOT_ROLL_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocationRollupInstruction_DO_NOT_ROLL_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReversalStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReversalStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReversalStatus_REFUSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReversalStatus_REFUSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReversalStatus_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReversalStatus_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ObligationType_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ObligationType_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_ObligationType_CONVERT_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ObligationType_CONVERT_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_ObligationType_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ObligationType_MORTGAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ObligationType_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ObligationType_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_PERCENT_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_PERCENT_PAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_DEAL_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_DEAL_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_UPFRONT_PNTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_UPFRONT_PNTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_UPFRONT_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_UPFRONT_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_PAR_UPFRONT_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_PAR_UPFRONT_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_SPREAD_UPFRONT_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_SPREAD_UPFRONT_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceNegotiationMethod_UPFRONT_PNTS_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceNegotiationMethod_UPFRONT_PNTS_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_UpfrontPriceType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UpfrontPriceType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UpfrontPriceType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UpfrontPriceType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleRestriction_NO_RESTRICTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleRestriction_NO_RESTRICTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleRestriction_SECURITY_NOT_SHORTABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_AT_OR_BELOW_BEST_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleRestriction_SECURITY_NOT_SHORTABLE_AT_OR_BELOW_BEST_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_WITHOUT_PRE_BORROW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleRestriction_SECURITY_NOT_SHORTABLE_WITHOUT_PRE_BORROW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_EXEMPTION_REASON_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_EXEMPTION_REASON_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_INCOMING_SSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_INCOMING_SSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_ABOVE_NATIONAL_BEST_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_ABOVE_NATIONAL_BEST_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_DELAYED_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_DELAYED_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_ODD_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_ODD_LOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_DOMESTIC_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_DOMESTIC_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_INTERNATIONAL_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_INTERNATIONAL_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_UNDERWRITER_OR_SYNDICATE_DISTRIBUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_UNDERWRITER_OR_SYNDICATE_DISTRIBUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleExemptionReason_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleExemptionReason_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplLevelRecoveryIndicator_NO_APPL_RECOVERY_NEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplLevelRecoveryIndicator_NO_APPL_RECOVERY_NEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplLevelRecoveryIndicator_APPL_RECOVERY_NEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplLevelRecoveryIndicator_APPL_RECOVERY_NEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestType_DEFINITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestType_DEFINITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestType_UTILIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestType_UTILIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestType_DEFINITIONS_AND_UTILIZATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestType_DEFINITIONS_AND_UTILIZATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RELATED_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RELATED_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RISK_LIMIT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RISK_LIMIT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RISK_LIMIT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RISK_WARNING_LEVEL_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RISK_WARNING_LEVEL_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INVALID_RISK_INSTRUMENT_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INVALID_RISK_INSTRUMENT_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_RISK_LIMIT_ACTIONS_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_RISK_LIMIT_ACTIONS_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_WARNING_LEVELS_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_WARNING_LEVELS_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_WARNING_LEVEL_ACTIONS_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_WARNING_LEVEL_ACTIONS_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_RISK_INSTRUMENT_SCOPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_RISK_INSTRUMENT_SCOPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_RISK_LIMIT_NOT_APPROVED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_RISK_LIMIT_NOT_APPROVED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_RISK_LIMIT_ALREADY_DEFINED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_RISK_LIMIT_ALREADY_DEFINED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_QUEUE_INBOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_QUEUE_INBOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_QUEUE_OUTBOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_QUEUE_OUTBOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_DISCONNECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_DISCONNECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_PING_CREDIT_CHECK_WITH_REVALIDATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_PING_CREDIT_CHECK_WITH_REVALIDATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_PING_CREDIT_CHECK_NO_REVALIDATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_PING_CREDIT_CHECK_NO_REVALIDATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_PUSH_CREDIT_CHECK_WITH_REVALIDATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_PUSH_CREDIT_CHECK_WITH_REVALIDATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_PUSH_CREDIT_CHECK_NO_REVALIDATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_PUSH_CREDIT_CHECK_NO_REVALIDATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_SUSPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitAction_HALT_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitAction_HALT_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_MAKE_MARKETS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_MAKE_MARKETS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_HOLD_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_HOLD_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_PERFORM_GIVE_UPS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_PERFORM_GIVE_UPS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_SUBMIT_IO_IS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_SUBMIT_IO_IS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_SUBSCRIBE_MARKET_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_SUBSCRIBE_MARKET_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_SHORT_WITH_PRE_BORROW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_SHORT_WITH_PRE_BORROW));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_SUBMIT_QUOTE_REQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_SUBMIT_QUOTE_REQUESTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementType_RESPOND_TO_QUOTE_REQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementType_RESPOND_TO_QUOTE_REQUESTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_TENOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_TENOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_PATTERN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_PATTERN));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_RESERVED100_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_RESERVED100_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_RESERVED1000_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_RESERVED1000_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_RESERVED4000_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_RESERVED4000_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_STRING));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_MULTIPLE_CHAR_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_MULTIPLE_CHAR_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_MONTH_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_MONTH_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_UTC_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_UTC_TIMESTAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_UTC_TIME_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_UTC_TIME_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_LOCAL_MKT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_LOCAL_MKT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_UTC_DATE_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_UTC_DATE_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_MULTIPLE_STRING_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_MULTIPLE_STRING_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_LANGUAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_LANGUAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_TZ_TIME_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_TZ_TIME_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_TZ_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_TZ_TIMESTAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_XML_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_XML_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_CHAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_CHAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_BOOLEAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_BOOLEAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_FLOAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_FLOAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_QTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_PRICE_OFFSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_PRICE_OFFSET));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_AMT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_INT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_INT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_LENGTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_LENGTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_NUM_IN_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_NUM_IN_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_SEQ_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_SEQ_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_TAG_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_TAG_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementAttribDatatype_DAY_OF_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementAttribDatatype_DAY_OF_MONTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesControl_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesControl_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesControl_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesControl_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeVolType_NUMBER_OF_UNITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeVolType_NUMBER_OF_UNITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeVolType_NUMBER_OF_ROUND_LOTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeVolType_NUMBER_OF_ROUND_LOTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_ADDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_ADDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_MODIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_MODIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_DELETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_DELETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_PARTIALLY_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_PARTIALLY_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_RELEASED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_RELEASED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_RESTATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_RESTATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventType_ACTIVATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventType_ACTIVATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ADD_ORDER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ADD_ORDER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_MODIFY_ORDER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_MODIFY_ORDER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_DELETE_ORDER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_DELETE_ORDER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ORDER_ENTERED_OOB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ORDER_ENTERED_OOB));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ORDER_MODIFIED_OOB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ORDER_MODIFIED_OOB));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ORDER_DELETED_OOB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ORDER_DELETED_OOB));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ORDER_ACTIVATED_OR_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ORDER_ACTIVATED_OR_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_ORDER_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_ORDER_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_RESERVE_ORDER_REFRESHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_RESERVE_ORDER_REFRESHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_AWAY_MARKET_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_AWAY_MARKET_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_START_OF_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_START_OF_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEventReason_END_OF_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderEventReason_END_OF_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_BLOCK_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_BLOCK_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_DIRECTED_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_DIRECTED_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_EXPOSURE_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_EXPOSURE_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_FLASH_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_FLASH_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_FACILITATION_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_FACILITATION_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_SOLICITATION_ORDER_AUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_SOLICITATION_ORDER_AUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_PRICE_IMPROVEMENT_MECHANISM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_PRICE_IMPROVEMENT_MECHANISM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionType_DIRECTED_ORDER_PRICE_IMPROVEMENT_MECHANISM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionType_DIRECTED_ORDER_PRICE_IMPROVEMENT_MECHANISM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionInstruction_AUTOMATED_AUCTION_PERMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionInstruction_AUTOMATED_AUCTION_PERMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AuctionInstruction_AUTOMATED_AUCTION_NOT_PERMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AuctionInstruction_AUTOMATED_AUCTION_NOT_PERMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_NOT_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_NOT_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_AWAY_MARKET_NETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_AWAY_MARKET_NETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_THREE_TICK_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_THREE_TICK_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_LOCKED_BY_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_LOCKED_BY_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_DIRECTED_ORDER_LOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_DIRECTED_ORDER_LOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_MULTILEG_LOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_MULTILEG_LOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_MARKET_ORDER_LOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_MARKET_ORDER_LOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_LockType_PRE_ASSIGNMENT_LOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LockType_PRE_ASSIGNMENT_LOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReleaseInstruction_ISO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReleaseInstruction_ISO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReleaseInstruction_NO_AWAY_MARKET_BETTER_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReleaseInstruction_NO_AWAY_MARKET_BETTER_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_AON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_AON));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_GENERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_GENERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_CLEARING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_CLEARING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureType_CMTA_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureType_CMTA_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureInstruction_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureInstruction_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureInstruction_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureInstruction_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DisclosureInstruction_USE_DEFAULT_SETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DisclosureInstruction_USE_DEFAULT_SETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_CUSTOMER_PROFESSIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_CUSTOMER_PROFESSIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_BROKER_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_BROKER_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_CUSTOMER_BROKER_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_CUSTOMER_BROKER_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_AWAY_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_AWAY_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradingCapacity_SYSTEMATIC_INTERNALISER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradingCapacity_SYSTEMATIC_INTERNALISER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingAccountType_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingAccountType_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingAccountType_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingAccountType_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingAccountType_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingAccountType_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedPriceSource_NB_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedPriceSource_NB_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedPriceSource_NB_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedPriceSource_NB_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MinQtyMethod_ONCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MinQtyMethod_ONCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MinQtyMethod_MULTIPLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MinQtyMethod_MULTIPLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_NOT_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_NOT_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_STOP_ORDER_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_STOP_ORDER_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_OCO_ORDER_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_OCO_ORDER_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_OTO_ORDER_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_OTO_ORDER_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Triggered_OUO_ORDER_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Triggered_OUO_ORDER_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_HOUR);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_MINUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_MINUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_SECOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_SECOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_EventTimeUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::EventTimeUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_WITHIN_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_WITHIN_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_ANOTHER_BROKER_DEALER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_ANOTHER_BROKER_DEALER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_OR_WITH_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_OR_WITH_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_DIRECT_ACCESS_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_DIRECT_ACCESS_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_FOREIGN_DEALER_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_FOREIGN_DEALER_EQUIVALENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOrigination_ORDER_RECEIVED_FROM_EXECUTION_ONLY_SERVICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOrigination_ORDER_RECEIVED_FROM_EXECUTION_ONLY_SERVICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearedIndicator_NOT_CLEARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearedIndicator_NOT_CLEARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearedIndicator_CLEARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearedIndicator_CLEARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearedIndicator_SUBMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearedIndicator_SUBMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearedIndicator_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearedIndicator_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractRefPosType_TWO_COMPONENT_INTERCOMMODITY_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractRefPosType_TWO_COMPONENT_INTERCOMMODITY_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractRefPosType_INDEX_OR_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractRefPosType_INDEX_OR_BASKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractRefPosType_TWO_COMPONENT_LOCATION_BASIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractRefPosType_TWO_COMPONENT_LOCATION_BASIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContractRefPosType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContractRefPosType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PositionCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionCapacity_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PositionCapacity_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionCapacity_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PositionCapacity_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionCapacity_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PositionCapacity_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_CUM_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_CUM_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_CUM_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_CUM_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_EX_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_EX_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_EX_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_EX_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_CUM_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_CUM_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_CUM_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_CUM_CAPITAL_REPAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_EX_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_EX_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_EX_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_EX_CAPITAL_REPAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_CASH_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_CASH_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_CUM_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_CUM_BONUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_EX_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_EX_BONUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_GUARANTEED_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_GUARANTEED_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_SPECIAL_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_SPECIAL_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_PRICE_IMPROVEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_PRICE_IMPROVEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_NON_PRICE_FORMING_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_NON_PRICE_FORMING_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_TRADE_EXEMPTED_FROM_TRADING_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_TRADE_EXEMPTED_FROM_TRADING_OBLIGATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_PRICE_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_PRICE_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradePriceCondition_PRICE_NOT_APPLICABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradePriceCondition_PRICE_NOT_APPLICABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocStatus_PENDING_CLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocStatus_PENDING_CLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocStatus_CLAIMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocStatus_CLAIMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocStatus_CLEARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocStatus_CLEARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_CLEARED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_CLEARED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_LONG_SIDE_CLAIMED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_LONG_SIDE_CLAIMED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_SHORT_SIDE_CLAIMED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_SHORT_SIDE_CLAIMED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_LONG_SIDE_REJECTED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_LONG_SIDE_REJECTED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_SHORT_SIDE_REJECTED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_SHORT_SIDE_REJECTED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_PENDING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_PENDING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_TRANSACTION_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_TRANSACTION_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_REMAINING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_REMAINING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeQtyType_PREVIOUS_REMAINING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeQtyType_PREVIOUS_REMAINING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocGroupInstruction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocGroupInstruction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocGroupInstruction_DO_NOT_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocGroupInstruction_DO_NOT_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_OffsetInstruction_OFFSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OffsetInstruction_OFFSET));
  return _val;
}


SWIGINTERN VALUE
_wrap_OffsetInstruction_ONSET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OffsetInstruction_ONSET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideAvgPxIndicator_NO_AVG_PRICING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideAvgPxIndicator_NO_AVG_PRICING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideAvgPxIndicator_TRADE_IS_PART_AVG_PRICE_GRP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideAvgPxIndicator_TRADE_IS_PART_AVG_PRICE_GRP));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideAvgPxIndicator_LAST_TRADE_IS_PART_AVG_PRICE_GRP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideAvgPxIndicator_LAST_TRADE_IS_PART_AVG_PRICE_GRP));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_NON_FIX_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_NON_FIX_SOURCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_SECONDARY_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_SECONDARY_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_TRADE_REPORT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_TRADE_REPORT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_FIRM_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_FIRM_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_SECONDARY_FIRM_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_SECONDARY_FIRM_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedTradeIDSource_REGULATORY_TRADE_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedTradeIDSource_REGULATORY_TRADE_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedPositionIDSource_POS_MAINT_RPT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedPositionIDSource_POS_MAINT_RPT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedPositionIDSource_TRANSFER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedPositionIDSource_TRANSFER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedPositionIDSource_POSITION_ENTITY_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedPositionIDSource_POSITION_ENTITY_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckType_PRICE_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckType_PRICE_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckType_NOTIONAL_VALUE_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckType_NOTIONAL_VALUE_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckType_QUANTITY_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckType_QUANTITY_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckAction_DO_NOT_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckAction_DO_NOT_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckAction_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckAction_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ValueCheckAction_BEST_EFFORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ValueCheckAction_BEST_EFFORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_INVALID_RELATED_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_INVALID_RELATED_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_INVALID_PARTY_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_INVALID_PARTY_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestStatus_ACCEPTED_WITH_CHANGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestStatus_ACCEPTED_WITH_CHANGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailRequestStatus_ACCEPTANCE_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailRequestStatus_ACCEPTANCE_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailDefinitionStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailDefinitionStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailDefinitionStatus_ACCEPTED_WITH_CHANGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailDefinitionStatus_ACCEPTED_WITH_CHANGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyDetailDefinitionStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyDetailDefinitionStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_RELATED_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_RELATED_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_ENTITLEMENT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_ENTITLEMENT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_ATTRIBUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_ENTITLEMENT_ATTRIBUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_INSTRUMENT_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_INSTRUMENT_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_MARKET_SEGMENT_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_MARKET_SEGMENT_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_START_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_START_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INVALID_END_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INVALID_END_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INSTRUMENT_SCOPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INSTRUMENT_SCOPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_MARKET_SEGMENT_SCOPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_MARKET_SEGMENT_SCOPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_ENTITLEMENT_NOT_APPROVED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_ENTITLEMENT_NOT_APPROVED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_ENTITLEMENT_ALREADY_DEFINED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_ENTITLEMENT_ALREADY_DEFINED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_ACCEPTED_WITH_CHANGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_ACCEPTED_WITH_CHANGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementStatus_DEFERRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementStatus_DEFERRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchAckStatus_RECEIVED_NOT_PROCESSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchAckStatus_RECEIVED_NOT_PROCESSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchAckStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchAckStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchAckStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchAckStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_INVALID_PARTY_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_INVALID_PARTY_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_UNAUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_UNAUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_INVALID_TRADE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_INVALID_TRADE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeMatchRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeMatchRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceMovementType_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceMovementType_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceMovementType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceMovementType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_INITIAL_BLOCK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_INITIAL_BLOCK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_COMPRESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_COMPRESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_NOVATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_NOVATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDEvent_POST_TRD_VAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDEvent_POST_TRD_VAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDSource_UNIQUE_TRANSACTION_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RegulatoryTradeIDSource_UNIQUE_TRANSACTION_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_CURRENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_CURRENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_PREVIOUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_PREVIOUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_BLOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_BLOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_RELATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_RELATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_CLEARED_BLOCK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_CLEARED_BLOCK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDType_TRADING_VENUE_TRANSACTION_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDType_TRADING_VENUE_TRANSACTION_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingIntention_DO_NOT_INTEND_TO_CLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingIntention_DO_NOT_INTEND_TO_CLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingIntention_INTEND_TO_CLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingIntention_INTEND_TO_CLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmationMethod_NON_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmationMethod_NON_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmationMethod_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmationMethod_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmationMethod_UNCONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmationMethod_UNCONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_VerificationMethod_NON_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::VerificationMethod_NON_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_VerificationMethod_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::VerificationMethod_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_NO_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_NO_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_END_USER_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_END_USER_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_INTER_AFFILIATE_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_INTER_AFFILIATE_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_TREASURY_AFFILIATE_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_TREASURY_AFFILIATE_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingRequirementException_COOPERATIVE_EXCEPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingRequirementException_COOPERATIVE_EXCEPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_IRSDirection_PAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IRSDirection_PAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_IRSDirection_RCV_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IRSDirection_RCV);
  return _val;
}


SWIGINTERN VALUE
_wrap_IRSDirection_NA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IRSDirection_NA);
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_RT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_RT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_PET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_PET));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_RTPET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_RTPET));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_PET_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_PET_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_RTPET_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_RTPET_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_POST_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_POST_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_VERIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_VERIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_PST_TRD_EVNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_PST_TRD_EVNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_PST_TRD_EVNT_RT_REPORTABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_PST_TRD_EVNT_RT_REPORTABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_LMTF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_LMTF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_DATF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_DATF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_VOLO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_VOLO));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_FWAF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_FWAF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_IDAF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_IDAF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_VOLW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_VOLW));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_FULF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_FULF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_FULA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_FULA));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_FULV_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_FULV));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_FULJ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_FULJ));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_COAF_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_COAF));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_CHILD_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_CHILD_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_ORDER_ROUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_ORDER_ROUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_SUPPLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_SUPPLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_NEW_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_NEW_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_TRANSACTION_CORRECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_TRANSACTION_CORRECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_TRANSACTION_MODIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_TRANSACTION_MODIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_COLLATERAL_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_COLLATERAL_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_MARGIN_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_MARGIN_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_TRANSACTION_REPORTED_IN_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_TRANSACTION_REPORTED_IN_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryReportType_TERMINATION_EARLY_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryReportType_TERMINATION_EARLY_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCollateralization_UNCOLLATERALIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeCollateralization_UNCOLLATERALIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCollateralization_PARTIALLY_COLLATERALIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeCollateralization_PARTIALLY_COLLATERALIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCollateralization_ONE_WAY_COLLATERALLIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeCollateralization_ONE_WAY_COLLATERALLIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCollateralization_FULLY_COLLATERALIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeCollateralization_FULLY_COLLATERALIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCollateralization_NET_EXPOSURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeCollateralization_NET_EXPOSURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_NOVATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_NOVATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_PARTIAL_NOVATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_PARTIAL_NOVATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_TRADE_UNWIND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_TRADE_UNWIND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_PARTIAL_TRADE_UNWIND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_PARTIAL_TRADE_UNWIND));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_FULL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_FULL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_PARTIAL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_PARTIAL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_AMENDMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_AMENDMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_INCREASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_INCREASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_CREDIT_EVENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_CREDIT_EVENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_STRATEGIC_RESTRUCTURING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_STRATEGIC_RESTRUCTURING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_SUCCESSION_EVENT_REORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_SUCCESSION_EVENT_REORGANIZATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_SUCCESSION_EVENT_RENAMING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_SUCCESSION_EVENT_RENAMING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_PORTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_PORTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_WITHDRAWL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_WITHDRAWL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_VOID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_VOID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_ACCOUNT_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_ACCOUNT_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_GIVE_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_GIVE_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_TAKE_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_TAKE_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_AVERAGE_PRICING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_AVERAGE_PRICING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_ALLOC_TRD_POSTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_ALLOC_TRD_POSTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_CASCADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_CASCADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_OPTION_ASGN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_OPTION_ASGN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_EXPIRATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_EXPIRATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_MATURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_EQUAL_POS_ADJ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_EQUAL_POS_ADJ));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_UNEQUAL_POS_ADJ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_UNEQUAL_POS_ADJ));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_CORRECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_CORRECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_EARLY_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_EARLY_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_RERATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_RERATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContinuation_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContinuation_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_INTEREST_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_INTEREST_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_EQUITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_EQUITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_COMMODITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_DEBT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_DEBT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_LOAN_FACILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_LOAN_FACILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetClass_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetClass_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_METALS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_METALS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_BULLION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_BULLION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_ENERGY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_ENERGY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_COMMODITY_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_COMMODITY_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_AGRICULTURAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_AGRICULTURAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_ENVIRONMENTAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_ENVIRONMENTAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FREIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FREIGHT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FERTILIZER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FERTILIZER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_INDUSTRIAL_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_INDUSTRIAL_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_INFLATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_INFLATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_PAPER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_POLYPROPYLENE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_POLYPROPYLENE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_OFFICIAL_ECONOMIC_STATISTICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_OFFICIAL_ECONOMIC_STATISTICS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_SINGLE_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_SINGLE_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_CREDIT_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_CREDIT_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_INDEX_TRANCHE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_INDEX_TRANCHE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_CREDIT_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_CREDIT_BASKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_BASKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FX_CROSS_RATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FX_CROSS_RATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FX_EMERGING_MARKETS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FX_EMERGING_MARKETS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FX_MAJORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FX_MAJORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_GOVERNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_GOVERNMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_CORPORATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_CORPORATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_FINANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_FINANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_MONEY_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_MONEY_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_MORTGAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_MUNICIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_MUNICIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_COMMON));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_PREFERRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_PREFERRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_EQUITY_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_EQUITY_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_EQUITY_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_EQUITY_BASKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_DIVIDEND_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_DIVIDEND_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_STOCK_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_STOCK_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_EXCHANGE_TRADED_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_EXCHANGE_TRADED_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_VOLATILITY_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_VOLATILITY_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_MUTUAL_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_MUTUAL_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_COLLECTIVE_INVESTMENT_VEHICLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_COLLECTIVE_INVESTMENT_VEHICLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_INVESTMENT_PROGRAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_INVESTMENT_PROGRAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_SPECIALIZED_ACCOUNT_PROGRAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_SPECIALIZED_ACCOUNT_PROGRAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_SINGLE_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_SINGLE_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_CROSS_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_CROSS_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_TERM_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_TERM_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_BRIDGE_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_BRIDGE_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_LETTER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_LETTER_OF_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_EXOTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_EXOTIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_OTHER_C10_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_OTHER_C10));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetSubClass_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetSubClass_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapClass_BASIS_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapClass_BASIS_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapClass_INDEX_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapClass_INDEX_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapClass_BROAD_BASED_SECURITY_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapClass_BROAD_BASED_SECURITY_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapClass_BASKET_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapClass_BASKET_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponType_ZERO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponType_ZERO));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponType_FIXED_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponType_FIXED_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponType_FLOATING_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponType_FLOATING_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponType_STRUCTURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponType_STRUCTURED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_HOUR);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_MINUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_MINUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_SECOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_SECOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponFrequencyUnit_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CouponFrequencyUnit_TERM);
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ONE_ONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ONE_ONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_THREE_SIXTY_US_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_THREE_SIXTY_US));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_THREE_SIXTY_SIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_THREE_SIXTY_SIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_THREE_SIXTY_M_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_THREE_SIXTY_M));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_E_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_E_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_E_THREE_SIXTY_ISDA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_E_THREE_SIXTY_ISDA));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_THREE_SIXTY_FIVE_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_THREE_SIXTY_FIVE_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_ACT_AFB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_ACT_AFB));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_ACT_ICMA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_ACT_ICMA));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_ACT_ISMA_ULTIMO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_ACT_ISMA_ULTIMO));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_ACT_ISDA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_ACT_ISDA));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_BUS_TWO_FIFTY_TWO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_BUS_TWO_FIFTY_TWO));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_E_PLUS_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_E_PLUS_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT_THREE_SIXTY_FIVE_L_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT_THREE_SIXTY_FIVE_L));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_NL_THREE_SIXTY_FIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_NL_THREE_SIXTY_FIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_NL_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_NL_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_ACT364_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_ACT364));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_THREE_SIXTY_FIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_THREE_SIXTY_FIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_ACTUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_ACTUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_THREE_SIXTY_ICMA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_THREE_SIXTY_ICMA));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_E_TWO_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_E_TWO_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_THIRTY_E_THREE_THREE_SIXTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_THIRTY_E_THREE_THREE_SIXTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CouponDayCount_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CouponDayCount_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LienSeniority_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LienSeniority_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LienSeniority_FIRST_LIEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LienSeniority_FIRST_LIEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LienSeniority_SECOND_LIEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LienSeniority_SECOND_LIEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LienSeniority_THIRD_LIEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LienSeniority_THIRD_LIEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_BRIDGE_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_BRIDGE_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_LETTER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_LETTER_OF_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_REVOLVING_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_REVOLVING_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_SWINGLINE_FUNDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_SWINGLINE_FUNDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_TERM_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_TERM_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_LoanFacility_TRADE_CLAIM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LoanFacility_TRADE_CLAIM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_ASIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_ASIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_AUSTRALIAN_NEW_ZEALAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_AUSTRALIAN_NEW_ZEALAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_EUROPEAN_EMERGING_MARKETS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_EUROPEAN_EMERGING_MARKETS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_JAPANESE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_JAPANESE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_NORTH_AMERICAN_HIGH_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_NORTH_AMERICAN_HIGH_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_NORTH_AMERICAN_INSURANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_NORTH_AMERICAN_INSURANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_NORTH_AMERICAN_INVESTMENT_GRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_NORTH_AMERICAN_INVESTMENT_GRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_SINGAPOREAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_SINGAPOREAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_WESTERN_EUROPEAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_WESTERN_EUROPEAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceEntityType_WESTERN_EUROPEAN_INSURANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceEntityType_WESTERN_EUROPEAN_INSURANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BlockTrdAllocIndicator_BLOCK_TO_BE_ALLOCATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BlockTrdAllocIndicator_BLOCK_TO_BE_ALLOCATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BlockTrdAllocIndicator_BLOCK_NOT_TO_BE_ALLOCATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BlockTrdAllocIndicator_BLOCK_NOT_TO_BE_ALLOCATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BlockTrdAllocIndicator_ALLOCATED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BlockTrdAllocIndicator_ALLOCATED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingObligationType_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingObligationType_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingObligationType_CONVERTIBLE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingObligationType_CONVERTIBLE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingObligationType_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingObligationType_MORTGAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingObligationType_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::UnderlyingObligationType_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlQuoteMethod_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlQuoteMethod_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlQuoteMethod_MID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlQuoteMethod_MID));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlQuoteMethod_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlQuoteMethod_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_HIGHEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_HIGHEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_AVERAGE_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_AVERAGE_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_AVERAGE_HIGHEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_AVERAGE_HIGHEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_BLENDED_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_BLENDED_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_BLENDED_HIGHEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_BLENDED_HIGHEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_AVERAGE_BLENDED_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_AVERAGE_BLENDED_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlValuationMethod_AVERAGE_BLENDED_HIGHEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlValuationMethod_AVERAGE_BLENDED_HIGHEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamType_PAYMENT_CASH_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamType_PAYMENT_CASH_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamType_PHYSICAL_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamType_PHYSICAL_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_MANDATORY_EARLY_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_MANDATORY_EARLY_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_OPTIONAL_EARLY_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_OPTIONAL_EARLY_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_CANCELABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_CANCELABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_EXTENDABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_EXTENDABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_MUTUAL_EARLY_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_MUTUAL_EARLY_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_EVERGREEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_EVERGREEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_CALLABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_CALLABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionType_PUTTABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionType_PUTTABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionDateTenorUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionDateTenorUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionDateTenorUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionDateTenorUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionDateTenorUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionDateTenorUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionDateTenorUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionDateTenorUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCalculationAgent_EXERCISING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCalculationAgent_EXERCISING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCalculationAgent_NON_EXERCISING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCalculationAgent_NON_EXERCISING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCalculationAgent_MASTER_AGREEENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCalculationAgent_MASTER_AGREEENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCalculationAgent_SUPPLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCalculationAgent_SUPPLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionSinglePartyBuyerSide_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionOptionSinglePartyBuyerSide_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionSinglePartyBuyerSide_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionOptionSinglePartyBuyerSide_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_CASH_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_CASH_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_CASH_PRICE_ALTERNATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_CASH_PRICE_ALTERNATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_PAR_YIELD_CURVE_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_PAR_YIELD_CURVE_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_ZERO_COUPON_YIELD_CURVE_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_ZERO_COUPON_YIELD_CURVE_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_PAR_YIELD_CURVE_UNADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_PAR_YIELD_CURVE_UNADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_CROSS_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_CROSS_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlMethod_COLLATERALIZED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlMethod_COLLATERALIZED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlQuoteType_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlQuoteType_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlQuoteType_MID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlQuoteType_MID));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlQuoteType_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlQuoteType_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlQuoteType_EXERCISING_PARTY_PAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlQuoteType_EXERCISING_PARTY_PAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionOptionExerciseEarliestDateOffsetUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionOptionExerciseEarliestDateOffsetUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionOptionExerciseEarliestDateOffsetUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProvisionOptionExerciseEarliestDateOffsetUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseFixedDateType_UNADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionOptionExerciseFixedDateType_UNADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionOptionExerciseFixedDateType_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionOptionExerciseFixedDateType_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlPaymentDateType_UNADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlPaymentDateType_UNADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionCashSettlPaymentDateType_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionCashSettlPaymentDateType_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProtectionTermEventUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProtectionTermEventUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProtectionTermEventUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ProtectionTermEventUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_CALENDAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_COMMODITY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_COMMODITY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_CURRENCY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_CURRENCY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_EXCHANGE_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_EXCHANGE_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventDayType_SCHEDULED_TRADING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProtectionTermEventDayType_SCHEDULED_TRADING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_HOLDING_OBLIGATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_HOLDING_OBLIGATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_CREDIT_EVENT_NOTICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_CREDIT_EVENT_NOTICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProtectionTermEventQualifier_FLOATING_RATE_INTEREST_SHORTFALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProtectionTermEventQualifier_FLOATING_RATE_INTEREST_SHORTFALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_BROKERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_BROKERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_UPFRONT_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_UPFRONT_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_INDEPENDENT_AMOUNT_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_INDEPENDENT_AMOUNT_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_PRINCIPAL_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_PRINCIPAL_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_NOVATION_TERMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_NOVATION_TERMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_EARLY_TERMINATION_PROVISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_EARLY_TERMINATION_PROVISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_CANCELABLE_PROVISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_CANCELABLE_PROVISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_EXTENDIBLE_PROVISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_EXTENDIBLE_PROVISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_CAP_RATE_PROVISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_CAP_RATE_PROVISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_FLOOR_RATE_PROVISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_FLOOR_RATE_PROVISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_OPTION_PREMIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_OPTION_PREMIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_SETTLEMENT_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_SETTLEMENT_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_CASH_SETTL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_CASH_SETTL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_SECURITY_LENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_SECURITY_LENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_REBATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_REBATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentPaySide_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentPaySide_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentPaySide_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentPaySide_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSettlStyle_STANDARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSettlStyle_STANDARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSettlStyle_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSettlStyle_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSettlStyle_STANDARDF_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSettlStyle_STANDARDF_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_PERIODIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_PERIODIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_SINGLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_SINGLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_DIVIDEND_RETURN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_DIVIDEND_RETURN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_PRICE_RETURN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_PRICE_RETURN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_TOTAL_RETURN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_TOTAL_RETURN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_VARIANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamType_CORRELATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamType_CORRELATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamDiscountType_STANDARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamDiscountType_STANDARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamDiscountType_FRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamDiscountType_FRA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCompoundingMethod_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCompoundingMethod_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCompoundingMethod_FLAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCompoundingMethod_FLAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCompoundingMethod_STRAIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCompoundingMethod_STRAIGHT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCompoundingMethod_SPREAD_EXCLUSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCompoundingMethod_SPREAD_EXCLUSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentFrequencyUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentFrequencyUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentFrequencyUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentFrequencyUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentFrequencyUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentFrequencyUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentFrequencyUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentFrequencyUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentFrequencyUnit_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentFrequencyUnit_TERM);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentDateOffsetUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentDateOffsetUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentDateOffsetUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamPaymentDateOffsetUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_MONDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_MONDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_TUESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_TUESDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_WEDNESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_WEDNESDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_THURSDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_THURSDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_FRIDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_FRIDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_SATURDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_SATURDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamResetWeeklyRollConvention_SUNDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamResetWeeklyRollConvention_SUNDAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexSource_BLOOMBERG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateIndexSource_BLOOMBERG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexSource_REUTERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateIndexSource_REUTERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexSource_TELERATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateIndexSource_TELERATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexSource_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateIndexSource_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexCurveUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamRateIndexCurveUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexCurveUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamRateIndexCurveUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexCurveUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamRateIndexCurveUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateIndexCurveUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamRateIndexCurveUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateSpreadPositionType_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateSpreadPositionType_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateSpreadPositionType_LONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateSpreadPositionType_LONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateTreatment_BOND_EQUIVALENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateTreatment_BOND_EQUIVALENT_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateTreatment_MONEY_MARKET_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateTreatment_MONEY_MARKET_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCapRateBuySide_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCapRateBuySide_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamCapRateBuySide_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamCapRateBuySide_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamFloorRateBuySide_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamFloorRateBuySide_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamFloorRateBuySide_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamFloorRateBuySide_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamAveragingMethod_UNWEIGHTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamAveragingMethod_UNWEIGHTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamAveragingMethod_WEIGHTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamAveragingMethod_WEIGHTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamNegativeRateTreatment_ZERO_INTEREST_RATE_METHOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamNegativeRateTreatment_ZERO_INTEREST_RATE_METHOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamNegativeRateTreatment_NEGATIVE_INTEREST_RATE_METHOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamNegativeRateTreatment_NEGATIVE_INTEREST_RATE_METHOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamInflationLagUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamInflationLagUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamInflationLagUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagUnit_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PaymentStreamInflationLagUnit_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_CALENDAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_COMMODITY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_COMMODITY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_CURRENCY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_CURRENCY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_EXCHANGE_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_EXCHANGE_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationLagDayType_SCHEDULED_TRADING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationLagDayType_SCHEDULED_TRADING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationInterpolationMethod_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationInterpolationMethod_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInflationInterpolationMethod_LINEAR_ZERO_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInflationInterpolationMethod_LINEAR_ZERO_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamFRADiscounting_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamFRADiscounting_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamFRADiscounting_ISDA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamFRADiscounting_ISDA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamFRADiscounting_AFMA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamFRADiscounting_AFMA));
  return _val;
}


SWIGINTERN VALUE
_wrap_NonDeliverableFixingDateType_UNADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NonDeliverableFixingDateType_UNADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_NonDeliverableFixingDateType_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NonDeliverableFixingDateType_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_CASH_FLOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_CASH_FLOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_FX_LINKED_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_FX_LINKED_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_FIXED_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_FIXED_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_FUTURE_VALUE_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_FUTURE_VALUE_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_KNOWN_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_KNOWN_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_FLOATING_RATE_MULTIPLIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_FLOATING_RATE_MULTIPLIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_CAP_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_CAP_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_FLOOR_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_FLOOR_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_NON_DELIVERABLE_SETTL_PAYMENT_DATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_NON_DELIVERABLE_SETTL_PAYMENT_DATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_NON_DELIVERABLE_SETTL_CALCULATION_DATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_NON_DELIVERABLE_SETTL_CALCULATION_DATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_NON_DELIVERABLE_FX_FIXING_DATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_NON_DELIVERABLE_FX_FIXING_DATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_SETTL_PERIOD_NOTNL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_SETTL_PERIOD_NOTNL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_SETTL_PERIOD_PX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_SETTL_PERIOD_PX));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_CALC_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_CALC_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_MULTIPLIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_MULTIPLIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_CAP_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_DIVIDEND_ACCRUAL_CAP_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_FLOOR_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_DIVIDEND_ACCRUAL_FLOOR_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_COMPOUNDING_RATE_MULTIPLIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_COMPOUNDING_RATE_MULTIPLIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_COMPOUNDING_RATE_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_COMPOUNDING_RATE_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_COMPOUNDING_CAP_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_COMPOUNDING_CAP_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleType_COMPOUNDING_FLOOR_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleType_COMPOUNDING_FLOOR_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleStepRelativeTo_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleStepRelativeTo_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentScheduleStepRelativeTo_PREVIOUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentScheduleStepRelativeTo_PREVIOUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubType_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubType_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubType_COMPOUNDING_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubType_COMPOUNDING_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubType_COMPOUNDING_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubType_COMPOUNDING_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubLength_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubLength_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStubLength_LONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStubLength_LONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_CALENDAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_COMMODITY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_COMMODITY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_CURRENCY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_CURRENCY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_EXCHANGE_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_EXCHANGE_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPaymentDateOffsetDayType_SCHEDULED_TRADING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPaymentDateOffsetDayType_SCHEDULED_TRADING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_NOT_APPLICABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_NOT_APPLICABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_FOLLOWING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_FOLLOWING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_FLOATING_RATE_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_FLOATING_RATE_NOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_MODIFIED_FOLLOWING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_MODIFIED_FOLLOWING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_PRECEDING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_PRECEDING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_MODIFIED_PRECEDING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_MODIFIED_PRECEDING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessDayConvention_NEAREST_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessDayConvention_NEAREST_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FIRST_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FIRST_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SECOND_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SECOND_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_THIRD_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_THIRD_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FOURTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FOURTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FIFTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FIFTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SIXTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SIXTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SEVENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SEVENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_EIGHTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_EIGHTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_NINTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_NINTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_ELEVENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_ELEVENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWELVTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWELVTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_THIRTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_THIRTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FORTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FORTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FIFTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FIFTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SIXTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SIXTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SEVENTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SEVENTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_EIGHTEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_EIGHTEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_NINETEENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_NINETEENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTIETH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTIETH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_FIRST_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_FIRST_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_SECOND_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_SECOND_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_THIRD_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_THIRD_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_FOURTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_FOURTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_FIFTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_FIFTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_SIXTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_SIXTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_SEVENTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_SEVENTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_EIGTH_DA28Y_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_EIGTH_DA28Y);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TWENTY_NINTH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TWENTY_NINTH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_THIRTIETH_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_THIRTIETH_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_EOM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_EOM);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FRN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FRN);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_IMM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_IMM);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_IMMCAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_IMMCAD);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_IMMAUD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_IMMAUD);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_IMMNZD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_IMMNZD);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_NONE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TBILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TBILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_MON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_MON);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_TUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_TUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_WED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_WED);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_THU_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_THU);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_FRI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_FRI);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SAT);
  return _val;
}


SWIGINTERN VALUE
_wrap_DateRollConvention_SUN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DateRollConvention_SUN);
  return _val;
}


SWIGINTERN VALUE
_wrap_AttachmentEncodingType_BASE64_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AttachmentEncodingType_BASE64));
  return _val;
}


SWIGINTERN VALUE
_wrap_AttachmentEncodingType_RAW_BINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AttachmentEncodingType_RAW_BINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_NegotiationMethod_AUTO_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NegotiationMethod_AUTO_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NegotiationMethod_NEGOTIATED_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NegotiationMethod_NEGOTIATED_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NegotiationMethod_PHONE_SPOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NegotiationMethod_PHONE_SPOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_ASIAN_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_ASIAN_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_ASIAN_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_ASIAN_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_BARRIER_CAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_BARRIER_CAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_BARRIER_FLOOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_BARRIER_FLOOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_KNOCK_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_KNOCK_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPeriodType_KNOCK_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPeriodType_KNOCK_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_CALENDAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_COMMODITY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_COMMODITY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_CURRENCY_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_CURRENCY_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_EXCHANGE_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_EXCHANGE_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventDateOffsetDayType_SCHEDULED_TRADING_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventDateOffsetDayType_SCHEDULED_TRADING_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_OFFICIAL_SETTL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_OFFICIAL_SETTL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_VALUATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_VALUATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_EXCAHGNE_SETTL_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_EXCAHGNE_SETTL_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_DERIVATIVES_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_DERIVATIVES_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexOptPayoutTime_AS_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexOptPayoutTime_AS_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventQuoteBasis_CURRENCY1_PER_CURRENCY2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventQuoteBasis_CURRENCY1_PER_CURRENCY2));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventQuoteBasis_CURRENCY2_PER_CURRENCY1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventQuoteBasis_CURRENCY2_PER_CURRENCY1));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventCreditEventNotifyingParty_SELLER_NOTIFIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventCreditEventNotifyingParty_SELLER_NOTIFIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventCreditEventNotifyingParty_BUYER_NOTIFIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventCreditEventNotifyingParty_BUYER_NOTIFIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventCreditEventNotifyingParty_SELLER_OR_BUYER_NOTIFIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventCreditEventNotifyingParty_SELLER_OR_BUYER_NOTIFIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleType_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleType_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleType_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleType_DELIVERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleType_PHYSICAL_SETTL_PERIODS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleType_PHYSICAL_SETTL_PERIODS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleToleranceType_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleToleranceType_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleToleranceType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleToleranceType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_ALL_TIMES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_ALL_TIMES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_ON_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_ON_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_OFF_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_OFF_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_BASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_BASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_BLOCK_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_BLOCK_HOURS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlFlowType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlFlowType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlHolidaysProcessingInstruction_DO_NOT_INCLUDE_HOLIDAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlHolidaysProcessingInstruction_DO_NOT_INCLUDE_HOLIDAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlHolidaysProcessingInstruction_INCLUDE_HOLIDAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlHolidaysProcessingInstruction_INCLUDE_HOLIDAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_MONDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_MONDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_TUESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_TUESDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_WEDNESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_WEDNESDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_THURSDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_THURSDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_FRIDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_FRIDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_SATURDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_SATURDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_SUNDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_SUNDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_ALL_WEEKDAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_ALL_WEEKDAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_ALL_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_ALL_DAYS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlDay_ALL_WEEKENDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlDay_ALL_WEEKENDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlTimeType_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlTimeType_HOUR));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryScheduleSettlTimeType_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryScheduleSettlTimeType_TIMESTAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamType_PERIODIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamType_PERIODIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamType_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamType_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamType_SINGLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamType_SINGLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryRestriction_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryRestriction_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryRestriction_NON_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryRestriction_NON_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryRestriction_FORCE_MAJEURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryRestriction_FORCE_MAJEURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryRestriction_SYSTEM_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryRestriction_SYSTEM_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryRestriction_UNIT_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryRestriction_UNIT_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamTitleTransferCondition_TRANSFERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamTitleTransferCondition_TRANSFERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamTitleTransferCondition_DOES_NOT_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamTitleTransferCondition_DOES_NOT_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamToleranceOptionSide_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamToleranceOptionSide_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamToleranceOptionSide_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamToleranceOptionSide_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamElectingPartySide_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamElectingPartySide_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamElectingPartySide_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamElectingPartySide_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapSubClass_AMORTIZING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapSubClass_AMORTIZING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapSubClass_COMPOUNDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapSubClass_COMPOUNDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapSubClass_CONSTANT_NOTIONAL_SCHEDULE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapSubClass_CONSTANT_NOTIONAL_SCHEDULE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapSubClass_ACCRETING_NOTIONAL_SCHEDULE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapSubClass_ACCRETING_NOTIONAL_SCHEDULE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SwapSubClass_CUSTOM_NOTIONAL_SCHEDULE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SwapSubClass_CUSTOM_NOTIONAL_SCHEDULE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_STRADDLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_STRADDLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_STRANGLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_STRANGLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_BUTTERFLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_BUTTERFLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_CONDOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_CONDOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_CALLABLE_INVERSIBLE_SNOWBALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_CALLABLE_INVERSIBLE_SNOWBALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_StrategyType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StrategyType_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDisruptionProvision_NEGOTIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDisruptionProvision_NEGOTIATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDisruptionProvision_CANCELLATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDisruptionProvision_CANCELLATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionProvision_NOT_APPLICABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionProvision_NOT_APPLICABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionProvision_APPLICABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionProvision_APPLICABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionProvision_AS_IN_MASTER_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionProvision_AS_IN_MASTER_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionProvision_AS_IN_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionProvision_AS_IN_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackProvision_MASTER_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackProvision_MASTER_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackProvision_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackProvision_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_BASKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_BASKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_BOND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_COMMODITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_CONVERTIBLE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_CONVERTIBLE_BOND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_EQUITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_EQUITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_EXCHANGE_TRADED_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_EXCHANGE_TRADED_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_FUTURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_MORTGAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketDisruptionFallbackUnderlierType_MUTUAL_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketDisruptionFallbackUnderlierType_MUTUAL_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseConfirmationMethod_NOT_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseConfirmationMethod_NOT_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseConfirmationMethod_NON_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseConfirmationMethod_NON_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseConfirmationMethod_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseConfirmationMethod_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseConfirmationMethod_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExerciseConfirmationMethod_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptionExerciseDateType_UNADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptionExerciseDateType_UNADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OptionExerciseDateType_ADJUSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OptionExerciseDateType_ADJUSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_BUSINESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_BUSINESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_CALENDAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_COMMODITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentDateOffsetDayType_SCHEDULED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentDateOffsetDayType_SCHEDULED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentForwardStartType_PREPAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentForwardStartType_PREPAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentForwardStartType_POSTPAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentForwardStartType_POSTPAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentForwardStartType_VARIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentForwardStartType_VARIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentForwardStartType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentForwardStartType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamSettlLevel_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamSettlLevel_AVERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamSettlLevel_MAXIMUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamSettlLevel_MAXIMUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamSettlLevel_MINIMUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamSettlLevel_MINIMUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamSettlLevel_CUMULATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamSettlLevel_CUMULATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateSpreadType_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateSpreadType_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRateSpreadType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRateSpreadType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayDistribution_ALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayDistribution_ALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayDistribution_FIRST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayDistribution_FIRST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayDistribution_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayDistribution_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayDistribution_PENULTIMATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayDistribution_PENULTIMATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_EVERY_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_EVERY_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_MONDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_MONDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_TUESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_TUESDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_WEDNESDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_WEDNESDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_THURSDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_THURSDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_FRIDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_FRIDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_SATURDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_SATURDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamPricingDayOfWeek_SUNDAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamPricingDayOfWeek_SUNDAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityNearbySettlDayUnit_WEEK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StreamCommodityNearbySettlDayUnit_WEEK);
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityNearbySettlDayUnit_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StreamCommodityNearbySettlDayUnit_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommoditySettlDateRollUnit_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StreamCommoditySettlDateRollUnit_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityDataSourceIDType_CITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamCommodityDataSourceIDType_CITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityDataSourceIDType_AIRPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamCommodityDataSourceIDType_AIRPORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityDataSourceIDType_WEATHER_STATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamCommodityDataSourceIDType_WEATHER_STATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamCommodityDataSourceIDType_WEATHER_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamCommodityDataSourceIDType_WEATHER_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_TERM));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_BUSINESS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_BUSINESS_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_CALCULATION_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_CALCULATION_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_SETTL_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_SETTL_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_CALENDAR_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_CALENDAR_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_HOUR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_HOUR));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalCommodityFrequency_PER_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalCommodityFrequency_PER_MONTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitReportStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitReportStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitReportStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitReportStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitReportRejectReason_UNK_RISK_LMT_RPRT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitReportRejectReason_UNK_RISK_LMT_RPRT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitReportRejectReason_UNK_PTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitReportRejectReason_UNK_PTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitReportRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitReportRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckType_SUBMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckType_SUBMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckType_LIMIT_CONSUMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckType_LIMIT_CONSUMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestType_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestType_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestType_PARTIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestType_PARTIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestStatus_APPROVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestStatus_APPROVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestStatus_PARTIALLY_APPROVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestStatus_PARTIALLY_APPROVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestStatus_APPROVAL_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestStatus_APPROVAL_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestStatus_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestStatus_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_CREDIT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_REQ_EXCEEDS_CREDIT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_CLIP_SIZE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_REQ_EXCEEDS_CLIP_SIZE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_MAX_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_REQ_EXCEEDS_MAX_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionType_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionType_SUSPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionType_HALT_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionType_HALT_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionType_REINSTATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionType_REINSTATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionResponse_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionResponse_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionResponse_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionResponse_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionResponse_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionResponse_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionRejectReason_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionRejectReason_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionRejectReason_UNK_REQ_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionRejectReason_UNK_REQ_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionRejectReason_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionRejectReason_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyActionRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyActionRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefRiskLimitCheckIDType_RISK_LIMIT_REQUEST_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefRiskLimitCheckIDType_RISK_LIMIT_REQUEST_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefRiskLimitCheckIDType_RISK_LIMIT_CHECK_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefRiskLimitCheckIDType_RISK_LIMIT_CHECK_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RefRiskLimitCheckIDType_OUT_OF_BAND_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RefRiskLimitCheckIDType_OUT_OF_BAND_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckModelType_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckModelType_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckModelType_PLUS_ONE_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckModelType_PLUS_ONE_MODEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckModelType_PING_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckModelType_PING_MODEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckModelType_PUSH_MODEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckModelType_PUSH_MODEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_CLAIM_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_CLAIM_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_SUCCEEDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_SUCCEEDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_FAILED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_FAILED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PRE_DEFINED_AUTO_ACCEPT_RULE_INVOKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PRE_DEFINED_AUTO_ACCEPT_RULE_INVOKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PRE_DEFINED_AUTO_REJECT_RULE_INVOKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PRE_DEFINED_AUTO_REJECT_RULE_INVOKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_ACCEPTED_BY_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_ACCEPTED_BY_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_REJECTED_BY_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_REJECTED_BY_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_ACCEPTED_BY_CREDIT_HUB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_ACCEPTED_BY_CREDIT_HUB));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_REJECTED_BY_CREDIT_HUB_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_REJECTED_BY_CREDIT_HUB));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_PENDING_CREDIT_HUB_CHECK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_PENDING_CREDIT_HUB_CHECK));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_ACCEPTED_BY_EXEC_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_ACCEPTED_BY_EXEC_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RiskLimitCheckStatus_REJECTED_BY_EXEC_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RiskLimitCheckStatus_REJECTED_BY_EXEC_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTransactionType_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTransactionType_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTransactionType_SEF_REQUIRED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTransactionType_SEF_REQUIRED_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTransactionType_SEF_PERMITTED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTransactionType_SEF_PERMITTED_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BatchProcessMode_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BatchProcessMode_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BatchProcessMode_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BatchProcessMode_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryPointSource_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryPointSource_PROPRIETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryStreamDeliveryPointSource_EIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryStreamDeliveryPointSource_EIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxonomyType_ISIN_OR_ALT_INSTRMT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TaxonomyType_ISIN_OR_ALT_INSTRMT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxonomyType_INTERIM_TAXONOMY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TaxonomyType_INTERIM_TAXONOMY));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDScope_CLEARING_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDScope_CLEARING_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegulatoryTradeIDScope_CLIENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegulatoryTradeIDScope_CLIENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_ORDER_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_ORDER_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_H_IT_LIFT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_H_IT_LIFT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_VIEW_INDICATIVE_PX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_VIEW_INDICATIVE_PX));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_VIEW_EXECUTABLE_PX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_VIEW_EXECUTABLE_PX));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_SINGLE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_SINGLE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_STREAMING_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_STREAMING_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_SINGLE_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_SINGLE_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EntitlementSubType_MULTI_BROKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EntitlementSubType_MULTI_BROKERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteModelType_QUOTE_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteModelType_QUOTE_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteModelType_QUOTE_MODIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteModelType_QUOTE_MODIFICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecMethod_UNSPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecMethod_UNSPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecMethod_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecMethod_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecMethod_AUTOMATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecMethod_AUTOMATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecMethod_VOICE_BROKERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecMethod_VOICE_BROKERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContingency_DOES_NOT_APPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContingency_DOES_NOT_APPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContingency_CONTINGENT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContingency_CONTINGENT_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeContingency_NON_CONTINGENT_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeContingency_NON_CONTINGENT_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_INTERMEDIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_INTERMEDIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_PREPAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_PREPAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_POSTPAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_POSTPAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_VARIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_VARIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_CONDITIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_CONDITIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_FIXED_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_FIXED_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentSubType_FLOATING_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentSubType_FLOATING_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestStatus_ACCEPTED_WITH_ADDITIONAL_EVENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestStatus_ACCEPTED_WITH_ADDITIONAL_EVENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestResult_RESPONSE_LEVEL_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestResult_RESPONSE_LEVEL_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestResult_INVALID_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestResult_INVALID_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestResult_INVALID_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestResult_INVALID_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassOrderRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassOrderRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderResponseLevel_NO_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderResponseLevel_NO_ACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderResponseLevel_MINIMUM_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderResponseLevel_MINIMUM_ACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderResponseLevel_ACK_EACH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderResponseLevel_ACK_EACH));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderResponseLevel_SUMMARY_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderResponseLevel_SUMMARY_ACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEntryAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderEntryAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEntryAction_MODIFY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderEntryAction_MODIFY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEntryAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderEntryAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEntryAction_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderEntryAction_SUSPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderEntryAction_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderEntryAction_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_ADDED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_ADDED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_REPLACED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_REPLACED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_CXLD_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_CXLD_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_UNSOLICITED_ORD_CXL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_UNSOLICITED_ORD_CXL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_NON_RESTING_ORD_ADDED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_NON_RESTING_ORD_ADDED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_REPLACED_WITH_NON_RESTING_ORD_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_REPLACED_WITH_NON_RESTING_ORD_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_TRIGGER_ORD_REPLACED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_TRIGGER_ORD_REPLACED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_SUSPENDED_ORD_REPLACED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_SUSPENDED_ORD_REPLACED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_SUSPENDED_ORD_CXLD_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_SUSPENDED_ORD_CXLD_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_CXL_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_CXL_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_PENDING_CXL_EXECUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_PENDING_CXL_EXECUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_RESTING_ORD_TRIGGERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_RESTING_ORD_TRIGGERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_SUSPENDED_ORD_ACTIVATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_SUSPENDED_ORD_ACTIVATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ACTIVE_ORD_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ACTIVE_ORD_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTypeReason_ORD_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecTypeReason_ORD_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferType_REQUEST_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferType_REQUEST_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferType_ACCEPT_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferType_ACCEPT_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferType_DECLINE_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferType_DECLINE_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferScope_INTER_FIRM_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferScope_INTER_FIRM_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferScope_INTRA_FIRM_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferScope_INTRA_FIRM_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferScope_CMTA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferScope_CMTA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_REJECTED_BY_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_REJECTED_BY_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_ACCEPT_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_ACCEPT_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_DECLINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_DECLINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferStatus_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferStatus_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_SUCCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_SUCCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_INVALID_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_INVALID_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_UNAUTHORIZED_TO_SUBMIT_XFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_UNAUTHORIZED_TO_SUBMIT_XFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_UNKNOWN_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_UNKNOWN_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferReportType_SUBMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferReportType_SUBMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransferReportType_ALLEGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransferReportType_ALLEGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_COUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_COUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_AVERAGE_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_AVERAGE_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TOTAL_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TOTAL_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_DISTRIBUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_DISTRIBUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_RATIO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_RATIO));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_VOLATILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_VOLATILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_DURATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_DURATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_AVERAGE_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_AVERAGE_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TOTAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TOTAL_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_HIGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_HIGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_LOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_LOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_MIDPOINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_MIDPOINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_FIRST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_FIRST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_EXCHANGE_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_EXCHANGE_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_EXCHANGE_BEST_WITH_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_EXCHANGE_BEST_WITH_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_CONSOLIDATED_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_CONSOLIDATED_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_CONSOLIDATED_BEST_WITH_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_CONSOLIDATED_BEST_WITH_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_AVERAGE_DURATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_AVERAGE_DURATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TOTAL_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TOTAL_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_TOTAL_BENEFITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_TOTAL_BENEFITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_MEDIAN_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_MEDIAN_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_AVERAGE_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_AVERAGE_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticType_MEDIAN_DURATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticType_MEDIAN_DURATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_BID_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_BID_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_OFFER_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_OFFER_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_BID_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_BID_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_OFFER_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_OFFER_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_ORDERS_AND_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_ORDERS_AND_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADE_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADE_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_AUCTION_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_AUCTION_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_OPENING_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_OPENING_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_CLOSING_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_CLOSING_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_SETTLEMENT_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_SETTLEMENT_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_UNDERLYING_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_UNDERLYING_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_OPEN_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_OPEN_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_INDEX_VALUES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_INDEX_VALUES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_MARGIN_RATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_MARGIN_RATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_OUTAGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_OUTAGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_SCHEDULED_AUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_SCHEDULED_AUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_REFERENCE_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_REFERENCE_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADE_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADE_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_MARKET_DATA_FEE_ITEMS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_MARKET_DATA_FEE_ITEMS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_REBATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_REBATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_DISCOUNTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_DISCOUNTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_PAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_PAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TAXES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TAXES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_LEVIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_LEVIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_BENEFITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_BENEFITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_ORDERS_RF_QS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_ORDERS_RF_QS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_MARKET_MAKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_MARKET_MAKERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADING_INTERRUPTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADING_INTERRUPTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADING_SUSPENSIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADING_SUSPENSIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_NO_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_NO_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_REQUEST_FOR_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_REQUEST_FOR_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScope_TRADE_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScope_TRADE_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_VISIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_VISIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_HIDDEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_HIDDEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_INDICATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_INDICATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_MARKET_CONSENSUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_MARKET_CONSENSUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_POWER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_POWER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_HARDWARE_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_HARDWARE_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_SOFTWARE_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_SOFTWARE_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_NETWORK_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_NETWORK_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_FAILED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_FAILED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_EXECUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_EXECUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_ENTERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_ENTERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_MODIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_MODIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_MARKET_DATA_ACCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_MARKET_DATA_ACCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_TERMINAL_ACCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_TERMINAL_ACCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_CLEARED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_CLEARED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_SETTLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_SETTLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_MONETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_MONETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_NON_MONETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_NON_MONETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_NEITHER_HIDDEN_NOR_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_NEITHER_HIDDEN_NOR_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_VENUE_DECISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_VENUE_DECISION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_MINIMUM_TIME_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_MINIMUM_TIME_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_NOT_EXECUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_NOT_EXECUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticSubScope_DIRECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticSubScope_DIRECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScopeType_ENTRY_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScopeType_ENTRY_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScopeType_MODIFICATION_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScopeType_MODIFICATION_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScopeType_CANCEL_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScopeType_CANCEL_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScopeType_DOWNWARD_MOVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScopeType_DOWNWARD_MOVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticScopeType_UPWARD_MOVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticScopeType_UPWARD_MOVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_SLIDING_WINDOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_SLIDING_WINDOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_SLIDING_WINDOW_PEAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_SLIDING_WINDOW_PEAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_FIXED_DATE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_FIXED_DATE_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_FIXED_TIME_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_FIXED_TIME_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_CURRENT_TIME_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_CURRENT_TIME_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_PREVIOUS_TIME_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_PREVIOUS_TIME_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_MAXIMUM_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_MAXIMUM_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticIntervalType_MAXIMUM_RANGE_UP_TO_PREVIOUS_TIME_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticIntervalType_MAXIMUM_RANGE_UP_TO_PREVIOUS_TIME_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_BUYERS_TO_SELLERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_BUYERS_TO_SELLERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_UPTICKS_TO_DOWNTICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_UPTICKS_TO_DOWNTICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_MARKET_MAKER_TO_NON_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_MARKET_MAKER_TO_NON_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_AUTOMATED_TO_NON_AUTOMATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_AUTOMATED_TO_NON_AUTOMATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_ORDERS_TO_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_ORDERS_TO_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_QUOTES_TO_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_QUOTES_TO_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_ORDERS_AND_QUOTES_TO_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_ORDERS_AND_QUOTES_TO_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_FAILED_TO_TOTAL_TRADED_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_FAILED_TO_TOTAL_TRADED_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_BENEFITS_TO_TOTAL_TRADED_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_BENEFITS_TO_TOTAL_TRADED_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_FEES_TO_TOTAL_TRADED_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_FEES_TO_TOTAL_TRADED_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_TRADE_VOLUME_TO_TOTAL_TRADED_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_TRADE_VOLUME_TO_TOTAL_TRADED_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRatioType_ORDERS_TO_TOTAL_NUMBER_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRatioType_ORDERS_TO_TOTAL_NUMBER_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_SECURITY_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_SECURITY_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_INSTRUMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_INSTRUMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_TRADE_DATE_OUT_OF_SUPPORTED_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_TRADE_DATE_OUT_OF_SUPPORTED_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_SCOPE_OR_SUB_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_SCOPE_OR_SUB_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_SCOPE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_SCOPE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_MARKET_DEPTH_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_MARKET_DEPTH_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_FREQUENCY_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_FREQUENCY_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_INTERVAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_STATISTIC_INTERVAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_DATE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_STATISTIC_DATE_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TIME_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TIME_RANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNSUPPORTED_RATIO_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNSUPPORTED_RATIO_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADE_INPUT_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADE_INPUT_SOURCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_UNAUTHORIZED_FOR_STATISTIC_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_UNAUTHORIZED_FOR_STATISTIC_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticRequestResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticRequestResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticStatus_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticStatus_INACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticStatus_INACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticValueType_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticValueType_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDStatisticValueType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDStatisticValueType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetGroup_FINANCIALS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetGroup_FINANCIALS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetGroup_COMMODITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetGroup_COMMODITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssetGroup_ALTERNATIVE_INVESTMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AssetGroup_ALTERNATIVE_INVESTMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_UNKNOWN_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_UNKNOWN_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_UNKNOWN_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_UNKNOWN_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_UNKNOWN_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_UNKNOWN_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_UNACCEPTABLE_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_UNACCEPTABLE_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollRptStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollRptStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_ASW_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_ASW_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_OIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_OIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_Z_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_Z_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_DISCOUNT_MARGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_DISCOUNT_MARGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_I_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_I_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_OAS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_OAS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_G_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_G_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_CDS_BASIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_CDS_BASIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_CDS_INTERPOLATED_BASIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_CDS_INTERPOLATED_BASIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_DV01_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_DV01));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_PV01_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_PV01));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueType_CS01_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueType_CS01));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueSide_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueSide_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueSide_MID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueSide_MID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelativeValueSide_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelativeValueSide_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_INSTRUMENT_REF_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_INSTRUMENT_REF_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_INSTRUMENT_REF_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_INSTRUMENT_REF_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_OFF_MARKET_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_OFF_MARKET_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_OFF_MARKET_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_OFF_MARKET_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_ORDER_BOOK_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_ORDER_BOOK_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_ORDER_BOOK_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_ORDER_BOOK_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_OPEN_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_OPEN_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_OPEN_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_OPEN_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_SETTLEMENT_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_SETTLEMENT_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_SETTLEMENT_PRICES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_SETTLEMENT_PRICES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_STATS_REF_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_STATS_REF_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_STATS_REF_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_STATS_REF_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_START_STATISTICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_START_STATISTICS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReportEvent_END_STATISTICS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDReportEvent_END_STATISTICS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentStatus_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentStatus_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentStatus_INACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentStatus_INACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentStatus_PUBLISHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentStatus_PUBLISHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentType_POOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentType_POOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentType_RETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentType_RETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentType_WHOLESALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentType_WHOLESALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentSubType_INTER_PRODUCT_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentSubType_INTER_PRODUCT_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentRelationship_MARKET_SEGMENT_POOL_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentRelationship_MARKET_SEGMENT_POOL_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentRelationship_RETAIL_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentRelationship_RETAIL_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketSegmentRelationship_WHOLESALE_SEGMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketSegmentRelationship_WHOLESALE_SEGMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteSideIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteSideIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteSideIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteSideIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerPriority_NO_PRIORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerPriority_NO_PRIORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerPriority_UNCONDITIONAL_PRIORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerPriority_UNCONDITIONAL_PRIORITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_SHARES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_SHARES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_DERIVATIVES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_DERIVATIVES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_PAYMENT_VS_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_PAYMENT_VS_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_CASCADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_CASCADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_REPURCHASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_REPURCHASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlSubMethod_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlSubMethod_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CalculationMethod_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CalculationMethod_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_CalculationMethod_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CalculationMethod_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_MARKET_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_MARKET_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_PORTFOLIO_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_PORTFOLIO_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_VALUE_CONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_VALUE_CONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_COLLATERAL_CREDIT_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_COLLATERAL_CREDIT_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_ADDITIONAL_COLLATERAL_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_ADDITIONAL_COLLATERAL_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralAmountType_ESTIMATED_MARKET_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralAmountType_ESTIMATED_MARKET_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_UNSPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_UNSPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_ACCEPTANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_ACCEPTANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_CLEARING_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_CLEARING_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_RETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_RETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_SALES_COMMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_SALES_COMMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_LOCAL_COMMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_LOCAL_COMMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountType_RESEARCH_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountType_RESEARCH_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlPriceDefault_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlPriceDefault_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashSettlPriceDefault_HEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CashSettlPriceDefault_HEDGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPVFinalPriceElectionFallback_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPVFinalPriceElectionFallback_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ComplexEventPVFinalPriceElectionFallback_HEDGE_ELECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ComplexEventPVFinalPriceElectionFallback_HEDGE_ELECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendEntitlementEvent_EX_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendEntitlementEvent_EX_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendEntitlementEvent_RECORD_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendEntitlementEvent_RECORD_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendAmountType_RECORD_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendAmountType_RECORD_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendAmountType_EX_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendAmountType_EX_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendAmountType_PAID_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendAmountType_PAID_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendAmountType_PER_MASTER_CONFIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendAmountType_PER_MASTER_CONFIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_NonCashDividendTreatment_POTENTIAL_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NonCashDividendTreatment_POTENTIAL_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NonCashDividendTreatment_CASH_EQUIVALENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NonCashDividendTreatment_CASH_EQUIVALENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendComposition_EQUITY_AMOUNT_RECEIVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendComposition_EQUITY_AMOUNT_RECEIVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DividendComposition_CALCULATION_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DividendComposition_CALCULATION_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikeIndexQuote_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikeIndexQuote_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikeIndexQuote_MID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikeIndexQuote_MID));
  return _val;
}


SWIGINTERN VALUE
_wrap_StrikeIndexQuote_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StrikeIndexQuote_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExtraordinaryEventAdjustmentMethod_CALCULATION_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExtraordinaryEventAdjustmentMethod_CALCULATION_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExtraordinaryEventAdjustmentMethod_OPTIONS_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExtraordinaryEventAdjustmentMethod_OPTIONS_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInterpolationPeriod_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInterpolationPeriod_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInterpolationPeriod_INITIAL_AND_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInterpolationPeriod_INITIAL_AND_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInterpolationPeriod_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInterpolationPeriod_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamInterpolationPeriod_ANY_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamInterpolationPeriod_ANY_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamLinkStrikePriceType_VOLATILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamLinkStrikePriceType_VOLATILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamLinkStrikePriceType_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamLinkStrikePriceType_VARIANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRealizedVarianceMethod_PREVIOUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRealizedVarianceMethod_PREVIOUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRealizedVarianceMethod_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRealizedVarianceMethod_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentStreamRealizedVarianceMethod_BOTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentStreamRealizedVarianceMethod_BOTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionBreakFeeElection_FLAT_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionBreakFeeElection_FLAT_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionBreakFeeElection_AMORTIZED_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionBreakFeeElection_AMORTIZED_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionBreakFeeElection_FUNDING_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionBreakFeeElection_FUNDING_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionBreakFeeElection_FLAT_AND_FUNDING_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionBreakFeeElection_FLAT_AND_FUNDING_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProvisionBreakFeeElection_AMORTIZED_AND_FUNDING_FEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProvisionBreakFeeElection_AMORTIZED_AND_FUNDING_FEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateDateMode_PRICE_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateDateMode_PRICE_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateDateMode_DIVIDEND_VALUATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateDateMode_DIVIDEND_VALUATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceSequence_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceSequence_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceSequence_INTERIM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceSequence_INTERIM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceSequence_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceSequence_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_OFFICIAL_SETTL_PX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_OFFICIAL_SETTL_PX));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_XETRA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_XETRA));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_DERIVATIVES_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_DERIVATIVES_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_HIGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_HIGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_LOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_LOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateQuoteTimeType_AS_SPECIFIED_IN_MASTER_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateQuoteTimeType_AS_SPECIFIED_IN_MASTER_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateValuationPriceOption_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateValuationPriceOption_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateValuationPriceOption_FUTURES_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateValuationPriceOption_FUTURES_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRateValuationPriceOption_OPTIONS_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRateValuationPriceOption_OPTIONS_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceBasis_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceBasis_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceBasis_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceBasis_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceBasis_ACCRUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceBasis_ACCRUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceBasis_CLEAN_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceBasis_CLEAN_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceType_ABSOLUTE_TERMS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceType_ABSOLUTE_TERMS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnRatePriceType_PERCENTAGE_OF_NOTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnRatePriceType_PERCENTAGE_OF_NOTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalAdjustments_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalAdjustments_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalAdjustments_PORTFOLIO_REBALANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalAdjustments_PORTFOLIO_REBALANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_StreamNotionalAdjustments_STANDARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StreamNotionalAdjustments_STANDARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingNotionalAdjustments_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingNotionalAdjustments_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingNotionalAdjustments_PORTFOLIO_REBALANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingNotionalAdjustments_PORTFOLIO_REBALANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_UnderlyingNotionalAdjustments_STANDARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UnderlyingNotionalAdjustments_STANDARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RemunerationIndicator_NO_REMUNERATION_PAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RemunerationIndicator_NO_REMUNERATION_PAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RemunerationIndicator_REMUNERATION_PAID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RemunerationIndicator_REMUNERATION_PAID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRiskLimitStatus_DISABLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRiskLimitStatus_DISABLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRiskLimitStatus_ENABLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRiskLimitStatus_ENABLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AlgorithmicTradeIndicator_NON_ALGORITHMIC_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AlgorithmicTradeIndicator_NON_ALGORITHMIC_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AlgorithmicTradeIndicator_ALGORITHMIC_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AlgorithmicTradeIndicator_ALGORITHMIC_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_PRE_TRADE_TRANSPARENCY_WAIVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_PRE_TRADE_TRANSPARENCY_WAIVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_POST_TRADE_DEFERRAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_POST_TRADE_DEFERRAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_EXEMPT_FROM_PUBLICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_EXEMPT_FROM_PUBLICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_SUBSCRIBERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_SUBSCRIBERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_PRICE_LEVEL_PUBLICATION_TO_SUBSCRIBERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_PRICE_LEVEL_PUBLICATION_TO_SUBSCRIBERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_THE_PUBLIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_THE_PUBLIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationType_PUBLICATION_INTERNAL_TO_EXECUTION_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationType_PUBLICATION_INTERNAL_TO_EXECUTION_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_AVERAGE_SPREAD_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_AVERAGE_SPREAD_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_REF_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_REF_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_OTHER_CONDITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_OTHER_CONDITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_REF_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_REF_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ILLIQUID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ILLIQUID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ORDER_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ORDER_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_DEFERRAL_DUE_TO_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_ILLIQUID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_DEFERRAL_DUE_TO_ILLIQUID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_SIZE_SPECIFIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_DEFERRAL_DUE_TO_SIZE_SPECIFIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_SIZE_DUE_TO_ORDER_HIDDEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_NO_PUBLIC_PRICE_SIZE_DUE_TO_ORDER_HIDDEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_EXEMPTED_DUE_TO_SECURITIES_FINANCING_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_EXEMPTED_DUE_TO_SECURITIES_FINANCING_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_EXEMPTED_DUE_TO_ESCB_POLICY_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_EXEMPTED_DUE_TO_ESCB_POLICY_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_REPORT_BY_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_EXCEPTION_DUE_TO_REPORT_BY_PAPER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_TRADE_EXECUTED_WITH_NON_REPORTING_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_EXCEPTION_DUE_TO_TRADE_EXECUTED_WITH_NON_REPORTING_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_INTRA_FIRM_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_EXCEPTION_DUE_TO_INTRA_FIRM_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegPublicationReason_REPORTED_OUTSIDE_REPORTING_HOURS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegPublicationReason_REPORTED_OUTSIDE_REPORTING_HOURS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossedIndicator_NO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossedIndicator_NO_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossedIndicator_CROSS_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossedIndicator_CROSS_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossedIndicator_CROSS_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossedIndicator_CROSS_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_AGGREGATED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_AGGREGATED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_PENDING_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_PENDING_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_LIQUIDITY_PROVISION_ACTIVITY_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_LIQUIDITY_PROVISION_ACTIVITY_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_RISK_REDUCTION_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_RISK_REDUCTION_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_ALGORITHMIC_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_ALGORITHMIC_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_SYSTEMATIC_INTERNALISER_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_SYSTEMATIC_INTERNALISER_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_ALL_EXECUTIONS_SUBMITTED_TO_APA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_ALL_EXECUTIONS_SUBMITTED_TO_APA));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_ORDER_EXECUTION_INSTRUCTED_BY_CLIENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_ORDER_EXECUTION_INSTRUCTED_BY_CLIENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_LARGE_IN_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_LARGE_IN_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_HIDDEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_HIDDEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_SUBJECT_TO_EUSTO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_SUBJECT_TO_EUSTO));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_SUBJECT_TO_UKSTO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_SUBJECT_TO_UKSTO));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_REPRESENTATIVE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_REPRESENTATIVE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_LINKAGE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_LINKAGE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderAttributeType_EXEMPT_FROM_STO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderAttributeType_EXEMPT_FROM_STO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_NOT_REPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_NOT_REPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_ON_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_ON_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_SI_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_SI_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_SI_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_SI_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_NON_SI_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_NON_SI_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_SUB_DELEGATION_BY_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_SUB_DELEGATION_BY_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_REPORTABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_REPORTABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_NON_SI_BUYER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_NON_SI_BUYER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_OFF_BOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_OFF_BOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportingIndicator_NOT_REPORTABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportingIndicator_NOT_REPORTABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_TRADING_RISK_CONTROL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_TRADING_RISK_CONTROL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_CLEARING_RISK_CONTROL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_CLEARING_RISK_CONTROL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_MARKET_MAKER_PROTECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_MARKET_MAKER_PROTECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_STOP_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_STOP_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_EMERGENCY_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_EMERGENCY_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_SESSION_LOSS_LOGOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_SESSION_LOSS_LOGOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_DUPLICATE_LOGIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_DUPLICATE_LOGIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_PRODUCT_NOT_TRADED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_PRODUCT_NOT_TRADED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_INSTRUMENT_NOT_TRADED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_INSTRUMENT_NOT_TRADED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_COMPLE_INSTRUMENT_DELETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_COMPLE_INSTRUMENT_DELETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_CIRCUIT_BREAKER_ACTIVATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_CIRCUIT_BREAKER_ACTIVATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassActionReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassActionReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_NotAffectedReason_ORDER_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NotAffectedReason_ORDER_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_NotAffectedReason_INSTRUMENT_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NotAffectedReason_INSTRUMENT_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOwnershipIndicator_NO_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOwnershipIndicator_NO_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOwnershipIndicator_EXECUTING_PARTY_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOwnershipIndicator_EXECUTING_PARTY_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOwnershipIndicator_ENTERING_PARTY_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOwnershipIndicator_ENTERING_PARTY_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderOwnershipIndicator_SPECIFIED_PARTY_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderOwnershipIndicator_SPECIFIED_PARTY_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InTheMoneyCondition_STANDARD_ITM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InTheMoneyCondition_STANDARD_ITM));
  return _val;
}


SWIGINTERN VALUE
_wrap_InTheMoneyCondition_ATMITM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InTheMoneyCondition_ATMITM));
  return _val;
}


SWIGINTERN VALUE
_wrap_InTheMoneyCondition_ATM_CALL_ITM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InTheMoneyCondition_ATM_CALL_ITM));
  return _val;
}


SWIGINTERN VALUE
_wrap_InTheMoneyCondition_ATM_PUT_ITM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InTheMoneyCondition_ATM_PUT_ITM));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationType_NO_RESTRICTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExDestinationType_NO_RESTRICTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationType_TRADED_ONLY_ON_TRADING_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExDestinationType_TRADED_ONLY_ON_TRADING_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationType_TRADED_ONLY_ON_SI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExDestinationType_TRADED_ONLY_ON_SI));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExDestinationType_TRADED_ON_TRADING_VENUE_OR_SI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExDestinationType_TRADED_ON_TRADING_VENUE_OR_SI));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketCondition_NORMAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketCondition_NORMAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketCondition_STRESSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketCondition_STRESSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarketCondition_EXCEPTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarketCondition_EXCEPTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAttributeType_QUOTE_ABOVE_STANDARD_MARKET_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAttributeType_QUOTE_ABOVE_STANDARD_MARKET_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAttributeType_QUOTE_ABOVE_SPECIFIC_INSTRUMENT_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAttributeType_QUOTE_ABOVE_SPECIFIC_INSTRUMENT_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAttributeType_QUOTE_APPLICABLE_FOR_LIQUIDTY_PROVISION_ACTIVITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAttributeType_QUOTE_APPLICABLE_FOR_LIQUIDTY_PROVISION_ACTIVITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAttributeType_QUOTE_ISSUER_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAttributeType_QUOTE_ISSUER_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteAttributeType_BID_OR_ASK_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteAttributeType_BID_OR_ASK_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQualifier_ACCRUED_INTEREST_IS_FACTORED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceQualifier_ACCRUED_INTEREST_IS_FACTORED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQualifier_TAX_IS_FACTORED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceQualifier_TAX_IS_FACTORED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceQualifier_BOND_AMORTIZATION_IS_FACTORED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceQualifier_BOND_AMORTIZATION_IS_FACTORED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDValueTier_RANGE1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDValueTier_RANGE1));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDValueTier_RANGE2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDValueTier_RANGE2));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDValueTier_RANGE3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDValueTier_RANGE3));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeQualifier_CONTRIBUTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeQualifier_CONTRIBUTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeQualifier_DOES_NOT_CONTRIBUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeQualifier_DOES_NOT_CONTRIBUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountSubType_RESEARCH_PAYMENT_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountSubType_RESEARCH_PAYMENT_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountSubType_COMMISSION_SHARING_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountSubType_COMMISSION_SHARING_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommissionAmountSubType_OTHER_TYPE_RESEARCH_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommissionAmountSubType_OTHER_TYPE_RESEARCH_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_ARGUS_MC_CLOSKEY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_ARGUS_MC_CLOSKEY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_BALTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_BALTIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_EXCHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_EXCHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_GLOBAL_COAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_GLOBAL_COAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_IHS_MC_CLOSKEY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_IHS_MC_CLOSKEY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_PLATTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_PLATTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommodityFinalPriceType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CommodityFinalPriceType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_REQUEST_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceDataDateType_ADMIT_TO_TRADE_REQUEST_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_APPROVAL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceDataDateType_ADMIT_TO_TRADE_APPROVAL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_OR_FIRST_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceDataDateType_ADMIT_TO_TRADE_OR_FIRST_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReferenceDataDateType_TERMINATION_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReferenceDataDateType_TERMINATION_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_VARIANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_VOLATILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_VOLATILITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_TOTAL_RETURN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_TOTAL_RETURN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_CONTRACT_FOR_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_CONTRACT_FOR_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_CREDIT_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_CREDIT_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_SPREAD_BET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_SPREAD_BET));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_FORWARD_PRICE_UNDERLYING_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_FORWARD_PRICE_UNDERLYING_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ReturnTrigger_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ReturnTrigger_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AveragePriceType_TIME_WEIGHTED_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AveragePriceType_TIME_WEIGHTED_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AveragePriceType_VOLUME_WEIGHTED_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AveragePriceType_VOLUME_WEIGHTED_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AveragePriceType_PERCENT_OF_VOLUME_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AveragePriceType_PERCENT_OF_VOLUME_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AveragePriceType_LIMIT_ORDER_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AveragePriceType_LIMIT_ORDER_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocGroupStatus_ADDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocGroupStatus_ADDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocGroupStatus_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocGroupStatus_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocGroupStatus_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocGroupStatus_REPLACED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocGroupStatus_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocGroupStatus_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocGroupStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocGroupStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_NO_MATCHING_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_NO_MATCHING_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_NO_MATCHING_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_NO_MATCHING_ALLOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_ALLOCATION_DATA_ELEMENT_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_ALLOCATION_DATA_ELEMENT_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_CONFIRMATION_DATA_ELEMENT_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_CONFIRMATION_DATA_ELEMENT_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_DATA_DIFFERENCE_NOT_WITHIN_TOLERANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_DATA_DIFFERENCE_NOT_WITHIN_TOLERANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_MATCH_WITHIN_TOLERANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_MATCH_WITHIN_TOLERANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_ACCRUED_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_ACCRUED_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_DEAL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_DEAL_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_TRADE_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_TRADE_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_SETTLEMENT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_SETTLEMENT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_SIDE_INDICATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_SIDE_INDICATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_TRADED_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_TRADED_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_ACCOUNT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_ACCOUNT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_EXECUTING_BROKER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_EXECUTING_BROKER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_SETTLEMENT_CURRENCY_AND_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_SETTLEMENT_CURRENCY_AND_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_INVESTMENT_MANAGER_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_INVESTMENT_MANAGER_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_NET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_NET_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_PLACE_OF_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_PLACE_OF_SETTLEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_COMMISSIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_COMMISSIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_SECURITY_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_SECURITY_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_QUALITY_ALLOCATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_QUALITY_ALLOCATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionElementType_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionElementType_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionToleranceValueType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionToleranceValueType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchExceptionToleranceValueType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchExceptionToleranceValueType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchingDataPointIndicator_MANDATORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchingDataPointIndicator_MANDATORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchingDataPointIndicator_OPTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MatchingDataPointIndicator_OPTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationRejectReason_UNKNOWN_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationRejectReason_UNKNOWN_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationRejectReason_UNKNOWN_EXECUTION_FILLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationRejectReason_UNKNOWN_EXECUTION_FILLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAggregationRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAggregationRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OffshoreIndicator_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OffshoreIndicator_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OffshoreIndicator_OFFSHORE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OffshoreIndicator_OFFSHORE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OffshoreIndicator_ONSHORE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OffshoreIndicator_ONSHORE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportTransType_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportTransType_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayReportStatus_DISPUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayReportStatus_DISPUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PayRequestStatus_DISPUTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PayRequestStatus_DISPUTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentDebitOrCredit_DEBIT_PAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentDebitOrCredit_DEBIT_PAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentDebitOrCredit_CREDIT_RECEIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentDebitOrCredit_CREDIT_RECEIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentStatus_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentStatus_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentStatus_INITIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentStatus_INITIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentStatus_CONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentStatus_CONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostTradePaymentStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PostTradePaymentStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_DuplicateClOrdIDIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DuplicateClOrdIDIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_DuplicateClOrdIDIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DuplicateClOrdIDIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventInitiatorType_CUSTOMER_OR_CLIENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EventInitiatorType_CUSTOMER_OR_CLIENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventInitiatorType_EXCHANGE_OR_EXECUTION_VENUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EventInitiatorType_EXCHANGE_OR_EXECUTION_VENUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventInitiatorType_FIRM_OR_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EventInitiatorType_FIRM_OR_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOEntryType_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOEntryType_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOEntryType_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOEntryType_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOEntryType_MID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOEntryType_MID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOSource_NOT_APPLICABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOSource_NOT_APPLICABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOSource_DIRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOSource_DIRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOSource_SIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOSource_SIP));
  return _val;
}


SWIGINTERN VALUE
_wrap_NBBOSource_HYBRID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NBBOSource_HYBRID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SingleQuoteIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SingleQuoteIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_SingleQuoteIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SingleQuoteIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampManualIndicator_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TrdRegTimestampManualIndicator_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampManualIndicator_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TrdRegTimestampManualIndicator_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralReinvestmentType_MONEY_MARKET_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralReinvestmentType_MONEY_MARKET_FUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralReinvestmentType_OTHER_COMINGLED_POOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralReinvestmentType_OTHER_COMINGLED_POOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralReinvestmentType_REPO_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralReinvestmentType_REPO_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralReinvestmentType_DIRECT_PURCHASE_OF_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralReinvestmentType_DIRECT_PURCHASE_OF_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollateralReinvestmentType_OTHER_INVESTMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollateralReinvestmentType_OTHER_INVESTMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_REPO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_REPO));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_FREE_CEDITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_FREE_CEDITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_CUSTOMER_SHORT_SALES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_CUSTOMER_SHORT_SALES));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_BROKER_SHORT_SALES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_BROKER_SHORT_SALES));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_UNSECURED_BORROWING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_UNSECURED_BORROWING));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundingSource_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::FundingSource_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginDirection_POSTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginDirection_POSTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MarginDirection_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MarginDirection_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransactionAttributeType_EXCLUSIVE_ARRANGEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransactionAttributeType_EXCLUSIVE_ARRANGEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransactionAttributeType_COLLATERAL_REUSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransactionAttributeType_COLLATERAL_REUSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TransactionAttributeType_COLLATERAL_ARRANGMENT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TransactionAttributeType_COLLATERAL_ARRANGMENT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingArrangmentIndicator_NO_ROUTING_ARRANGMENT_IN_PLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingArrangmentIndicator_NO_ROUTING_ARRANGMENT_IN_PLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingArrangmentIndicator_ROUTING_ARRANGEMENT_IN_PLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingArrangmentIndicator_ROUTING_ARRANGEMENT_IN_PLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedOrderIDSource_NON_FIX_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedOrderIDSource_NON_FIX_SOURCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedOrderIDSource_SYSTEM_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedOrderIDSource_SYSTEM_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedOrderIDSource_CLIENT_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedOrderIDSource_CLIENT_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedOrderIDSource_SECONDARY_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedOrderIDSource_SECONDARY_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RelatedOrderIDSource_SECONDARY_CLIENT_ORDER_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RelatedOrderIDSource_SECONDARY_CLIENT_ORDER_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRelationship_NOT_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderRelationship_NOT_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRelationship_ORDER_AGGREGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderRelationship_ORDER_AGGREGATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRelationship_ORDER_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrderRelationship_ORDER_SPLIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_CUSIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_SEDOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_SEDOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_ISIN_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_ISIN_NUMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CurrencyCodeSource_DIGITAL_TOKEN_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CurrencyCodeSource_DIGITAL_TOKEN_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiJurisdictionReportingIndicator_NOT_MULTI_JRSDCTN_ELIGIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiJurisdictionReportingIndicator_NOT_MULTI_JRSDCTN_ELIGIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiJurisdictionReportingIndicator_MULTI_JRSDCTN_ELIGIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiJurisdictionReportingIndicator_MULTI_JRSDCTN_ELIGIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SelfMatchPreventionInstruction_CANCEL_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SelfMatchPreventionInstruction_CANCEL_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_PASSIVE));
  return _val;
}


static swig_class SwigClassSessionID;

SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  FIX::SessionID *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionID *)new FIX::SessionID();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  FIX::SessionID *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SessionID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SessionID", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SessionID", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SessionID", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionID *)new FIX::SessionID((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SessionID_allocate(VALUE self)
#else
_wrap_SessionID_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  FIX::SessionID *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SessionID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SessionID", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SessionID", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionID", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionID *)new FIX::SessionID((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionID__SWIG_0(nargs, args, self);
  }
  if (argc == 3) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SessionID__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SessionID__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SessionID.new", 
    "    SessionID.new()\n"
    "    SessionID.new(std::string const &beginString, std::string const &senderCompID, std::string const &targetCompID, std::string const &sessionQualifier)\n"
    "    SessionID.new(std::string const &beginString, std::string const &senderCompID, std::string const &targetCompID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getBeginString(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::BeginString *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getBeginString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::BeginString *) &((FIX::SessionID const *)arg1)->getBeginString();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__BeginString, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getSenderCompID(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::SenderCompID *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getSenderCompID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SenderCompID *) &((FIX::SessionID const *)arg1)->getSenderCompID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__SenderCompID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getTargetCompID(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::TargetCompID *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getTargetCompID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::TargetCompID *) &((FIX::SessionID const *)arg1)->getTargetCompID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__TargetCompID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getSessionQualifier(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getSessionQualifier", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::SessionID const *)arg1)->getSessionQualifier();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_isFIXT(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","isFIXT", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::SessionID const *)arg1)->isFIXT();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::SessionID const *)arg1)->toString();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_toStringFrozen(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","toStringFrozen", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::SessionID const *)arg1)->toStringFrozen();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_fromString(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID *","fromString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","fromString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","fromString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->fromString((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    temp2 = std::string((char*)StringValuePtr(argv[0]));
    arg2 = &temp2;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::SessionID const *)arg1)->toString(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionID_toString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SessionID_toString__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionID_toString__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SessionID.toString", 
    "    std::string SessionID.toString()\n"
    "    std::string & SessionID.toString(std::string &str)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::SessionID.~

  call-seq:
    ~ -> SessionID

Invert operator.
*/
SWIGINTERN VALUE
_wrap_SessionID___invert__(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::SessionID result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","operator ~", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::SessionID const *)arg1)->operator ~();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::SessionID(result)), SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID___str__(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX_SessionID___str__(arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionID(void *self) {
    FIX::SessionID *arg1 = (FIX::SessionID *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((FIX::SessionID const &)*arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((FIX::SessionID const &)*arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream &
    <<(arg0, arg1) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::ostream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::ostream *) &FIX::operator <<(*arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.>>

  call-seq:
    >>(stream, sessionID) -> std::istream &
    >>(arg0, arg1) -> std::istream

Right shifting operator or extracting operator.
*/
SWIGINTERN VALUE
_wrap___rshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::istream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::operator >>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::operator >>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID &","FIX::operator >>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID &","FIX::operator >>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::istream *) &FIX::operator >>(*arg1,*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassDictionary;

SWIGINTERN VALUE
_wrap_new_Dictionary__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Dictionary";
  FIX::Dictionary *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Dictionary", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Dictionary", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *)new FIX::Dictionary((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Dictionary_allocate(VALUE self)
#else
_wrap_Dictionary_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Dictionary);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Dictionary__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::Dictionary";
  FIX::Dictionary *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *)new FIX::Dictionary();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Dictionary(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Dictionary__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Dictionary__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Dictionary.new", 
    "    Dictionary.new(std::string const &name)\n"
    "    Dictionary.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Dictionary(void *self) {
    FIX::Dictionary *arg1 = (FIX::Dictionary *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Dictionary_getName(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->getName();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Dictionary.size

  call-seq:
    size -> size_t

Size or Length of the Dictionary.
*/
SWIGINTERN VALUE
_wrap_Dictionary_size(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->size();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","getString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->getString((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->getString((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Dictionary_getString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Dictionary_getString__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Dictionary_getString__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Dictionary.getString", 
    "    std::string Dictionary.getString(std::string const &, bool capitalize)\n"
    "    std::string Dictionary.getString(std::string const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getInt(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getInt", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getInt", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getInt", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Dictionary const *)arg1)->getInt((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getDouble(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getDouble", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getDouble", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (double)((FIX::Dictionary const *)arg1)->getDouble((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_double(static_cast< double >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getBool(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getBool", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getBool", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getBool", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Dictionary const *)arg1)->getBool((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getDay(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getDay", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getDay", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::Dictionary const *)arg1)->getDay((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setString(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","setString", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setString((std::string const &)*arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setInt(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setInt", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setInt", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setInt", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setInt", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setInt((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setDouble(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setDouble", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setDouble", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","setDouble", 3, argv[1] ));
  } 
  arg3 = static_cast< double >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setDouble((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setBool(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setBool", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setBool", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setBool", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setBool", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setBool((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setDay(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setDay", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setDay", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setDay", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setDay((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_has(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","has", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","has", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::Dictionary const *)arg1)->has((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_merge(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  FIX::Dictionary *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","merge", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Dictionary const &","merge", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","merge", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Dictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->merge((FIX::Dictionary const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Dictionary.begin

  call-seq:
    begin -> FIX::Dictionary::iterator

Return an iterator to the beginning of the Dictionary.
*/
SWIGINTERN VALUE
_wrap_Dictionary_begin(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< std::string,std::string >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->begin();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::Dictionary::iterator(result)), SWIGTYPE_p_std__mapT_std__string_std__string_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


/*
  Document-method: Quickfix::Dictionary.end

  call-seq:
    end -> FIX::Dictionary::iterator

Return an iterator to past the end of the Dictionary.
*/
SWIGINTERN VALUE
_wrap_Dictionary_end(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< std::string,std::string >::const_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::Dictionary const *)arg1)->end();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::Dictionary::iterator(result)), SWIGTYPE_p_std__mapT_std__string_std__string_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BEGINSTRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BEGINSTRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SENDERCOMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SENDERCOMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_TARGETCOMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TARGETCOMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_SESSION_QUALIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SESSION_QUALIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_DEFAULT_APPLVERID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DEFAULT_APPLVERID);
  return _val;
}


SWIGINTERN VALUE
_wrap_CONNECTION_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CONNECTION_TYPE);
  return _val;
}


SWIGINTERN VALUE
_wrap_USE_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::USE_DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SEND_RESETSEQNUMFLAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SEND_RESETSEQNUMFLAG);
  return _val;
}


SWIGINTERN VALUE
_wrap_SEND_REDUNDANT_RESENDREQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SEND_REDUNDANT_RESENDREQUESTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_TRANSPORT_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TRANSPORT_DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_APP_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::APP_DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_USE_LOCAL_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::USE_LOCAL_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_START_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::START_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_END_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::END_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_START_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::START_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_END_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::END_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGON_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGON_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGOUT_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGOUT_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGON_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGON_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGOUT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGOUT_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CHECK_COMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CHECK_COMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_CHECK_LATENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CHECK_LATENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MAX_LATENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MAX_LATENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_HEARTBTINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::HEARTBTINT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_ACCEPT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_ACCEPT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_REUSE_ADDRESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_REUSE_ADDRESS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_SOURCE_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_SOURCE_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_SOURCE_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_SOURCE_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_NODELAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_NODELAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_SEND_BUFFER_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_SEND_BUFFER_SIZE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_RECEIVE_BUFFER_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_RECEIVE_BUFFER_SIZE);
  return _val;
}


SWIGINTERN VALUE
_wrap_RECONNECT_INTERVAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RECONNECT_INTERVAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_LENGTH_AND_CHECKSUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_LENGTH_AND_CHECKSUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_FIELDS_OUT_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_FIELDS_OUT_OF_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_FIELDS_HAVE_VALUES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_FIELDS_HAVE_VALUES);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_USER_DEFINED_FIELDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_USER_DEFINED_FIELDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_ALLOW_UNKNOWN_MSG_FIELDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ALLOW_UNKNOWN_MSG_FIELDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_PRESERVE_MESSAGE_FIELDS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PRESERVE_MESSAGE_FIELDS_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGON_TIMEOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGON_TIMEOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGOUT_TIMEOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGOUT_TIMEOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_FILE_STORE_PATH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FILE_STORE_PATH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_CONNECTION_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_CONNECTION_STRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_FILE_LOG_PATH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FILE_LOG_PATH);
  return _val;
}


SWIGINTERN VALUE
_wrap_FILE_LOG_BACKUP_PATH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FILE_LOG_BACKUP_PATH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_INCOMING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_INCOMING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_OUTGOING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_OUTGOING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_EVENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_EVENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_INCOMING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_INCOMING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_OUTGOING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_OUTGOING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_EVENT_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_EVENT_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_INCOMING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_INCOMING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_OUTGOING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_OUTGOING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_EVENT_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_EVENT_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_CONNECTION_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_CONNECTION_STRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_INCOMING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_INCOMING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_OUTGOING_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_OUTGOING_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_EVENT_TABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_EVENT_TABLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_LOGON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_LOGON);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_LOGOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_LOGOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_DISCONNECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_DISCONNECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_REFRESH_ON_LOGON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::REFRESH_ON_LOGON);
  return _val;
}


SWIGINTERN VALUE
_wrap_MILLISECONDS_IN_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MILLISECONDS_IN_TIMESTAMP);
  return _val;
}


SWIGINTERN VALUE
_wrap_TIMESTAMP_PRECISION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TIMESTAMP_PRECISION);
  return _val;
}


SWIGINTERN VALUE
_wrap_HTTP_ACCEPT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::HTTP_ACCEPT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PERSIST_MESSAGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PERSIST_MESSAGES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SERVER_CERTIFICATE_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SERVER_CERTIFICATE_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SERVER_CERTIFICATE_KEY_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SERVER_CERTIFICATE_KEY_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CLIENT_CERTIFICATE_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CLIENT_CERTIFICATE_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CLIENT_CERTIFICATE_KEY_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CLIENT_CERTIFICATE_KEY_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CERTIFICATE_AUTHORITIES_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CERTIFICATE_AUTHORITIES_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CERTIFICATE_AUTHORITIES_DIRECTORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CERTIFICATE_AUTHORITIES_DIRECTORY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CERTIFICATE_REVOCATION_LIST_FILE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CERTIFICATE_REVOCATION_LIST_FILE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CERTIFICATE_REVOCATION_LIST_DIRECTORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CERTIFICATE_REVOCATION_LIST_DIRECTORY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CERTIFICATE_VERIFY_LEVEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CERTIFICATE_VERIFY_LEVEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SSL_PROTOCOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SSL_PROTOCOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SSL_CIPHER_SUITE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SSL_CIPHER_SUITE);
  return _val;
}


static swig_class SwigClassSessionSettings;

SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  FIX::SessionSettings *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionSettings *)new FIX::SessionSettings();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  FIX::SessionSettings *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","SessionSettings", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","SessionSettings", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SessionSettings", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionSettings *)new FIX::SessionSettings(*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  FIX::SessionSettings *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","SessionSettings", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","SessionSettings", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionSettings *)new FIX::SessionSettings(*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  FIX::SessionSettings *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SessionSettings", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionSettings", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SessionSettings", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionSettings *)new FIX::SessionSettings((std::string const &)*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SessionSettings_allocate(VALUE self)
#else
_wrap_SessionSettings_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionSettings);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  FIX::SessionSettings *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SessionSettings", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SessionSettings", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionSettings *)new FIX::SessionSettings((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionSettings(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionSettings__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionSettings__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionSettings__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SessionSettings__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SessionSettings__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SessionSettings.new", 
    "    SessionSettings.new()\n"
    "    SessionSettings.new(std::istream &stream, bool resolveEnvVars)\n"
    "    SessionSettings.new(std::istream &stream)\n"
    "    SessionSettings.new(std::string const &file, bool resolveEnvVars)\n"
    "    SessionSettings.new(std::string const &file)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_has(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::SessionSettings const *)arg1)->has((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Dictionary *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","get", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","get", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *) &((FIX::SessionSettings const *)arg1)->get((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Dictionary arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Dictionary,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Dictionary","set", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary","set", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< FIX::Dictionary * >(argp3));
    }
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->set((FIX::SessionID const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Dictionary *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *) &((FIX::SessionSettings const *)arg1)->get();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionSettings_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SessionSettings_get__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionSettings_get__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SessionSettings.get", 
    "    FIX::Dictionary const SessionSettings.get(FIX::SessionID const &)\n"
    "    FIX::Dictionary const & SessionSettings.get()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::Dictionary *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Dictionary const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Dictionary * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->set((FIX::Dictionary const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionSettings_set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Dictionary, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionSettings_set__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Dictionary, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SessionSettings_set__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SessionSettings.set", 
    "    void SessionSettings.set(FIX::SessionID const &, FIX::Dictionary)\n"
    "    void SessionSettings.set(FIX::Dictionary const &defaults)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::SessionSettings.size

  call-seq:
    size -> size_t

Size or Length of the SessionSettings.
*/
SWIGINTERN VALUE
_wrap_SessionSettings_size(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::SessionSettings const *)arg1)->size();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::SessionSettings const *)arg1)->getSessions();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = swig::from(static_cast< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_setFromString(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","setFromString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setFromString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setFromString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      FIX_SessionSettings_setFromString(arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionSettings(void *self) {
    FIX::SessionSettings *arg1 = (FIX::SessionSettings *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::FIX.>>

  call-seq:
    >>(stream, sessionID) -> std::istream
    >>(arg0, arg1) -> std::istream &

Right shifting operator or extracting operator.
*/
SWIGINTERN VALUE
_wrap___rshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::SessionSettings *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::istream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::operator >>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::operator >>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionSettings &","FIX::operator >>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings &","FIX::operator >>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionSettings * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::istream *) &FIX::operator >>(*arg1,*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___rshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___rshift____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___rshift____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__rshift__", 
    "    std::istream __rshift__(std::istream &stream, FIX::SessionID &sessionID)\n"
    "    std::istream & __rshift__(std::istream &, FIX::SessionSettings &)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(arg0, arg1) -> std::ostream &

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::SessionSettings *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::ostream *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionSettings * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::ostream *) &FIX::operator <<(*arg1,(FIX::SessionSettings const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__lshift__", 
    "    std::ostream __lshift__(std::ostream &stream, FIX::FieldBase const &field)\n"
    "    std::ostream __lshift__(std::ostream &stream, FIX::Message const &message)\n"
    "    std::ostream __lshift__(std::ostream &stream, FIX::SessionID const &sessionID)\n"
    "    std::ostream & __lshift__(std::ostream &, FIX::SessionSettings const &)\n");
  
  return Qnil;
}


static swig_class SwigClassSession;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Session_allocate(VALUE self)
#else
_wrap_Session_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Session);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Session(int argc, VALUE *argv, VALUE self) {
  SwigValueWrapper< std::function< FIX::UtcTimeStamp () > > arg1 ;
  Application *arg2 = 0 ;
  MessageStoreFactory *arg3 = 0 ;
  FIX::SessionID *arg4 = 0 ;
  DataDictionaryProvider *arg5 = 0 ;
  TimeRange *arg6 = 0 ;
  int arg7 ;
  LogFactory *arg8 = (LogFactory *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Session";
  FIX::Session *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__functionT_FIX__UtcTimeStamp_fF_t,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::function< FIX::UtcTimeStamp () >","Session", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::function< FIX::UtcTimeStamp () >","Session", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< std::function< FIX::UtcTimeStamp () > * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_Application,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Application &","Session", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Application &","Session", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< Application * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "MessageStoreFactory &","Session", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "MessageStoreFactory &","Session", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< MessageStoreFactory * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::SessionID const &","Session", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","Session", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::SessionID * >(argp4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_DataDictionaryProvider,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "DataDictionaryProvider const &","Session", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionaryProvider const &","Session", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< DataDictionaryProvider * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_TimeRange,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "TimeRange const &","Session", 6, argv[5] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TimeRange const &","Session", 6, argv[5])); 
  }
  arg6 = reinterpret_cast< TimeRange * >(argp6);
  ecode7 = SWIG_AsVal_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "int","Session", 7, argv[6] ));
  } 
  arg7 = static_cast< int >(val7);
  res8 = SWIG_ConvertPtr(argv[7], &argp8,SWIGTYPE_p_LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "LogFactory *","Session", 8, argv[7] )); 
  }
  arg8 = reinterpret_cast< LogFactory * >(argp8);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)new FIX::Session(arg1,*arg2,*arg3,(FIX::SessionID const &)*arg4,(DataDictionaryProvider const &)*arg5,(TimeRange const &)*arg6,arg7,arg8);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_Session(void *self) {
    FIX::Session *arg1 = (FIX::Session *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Session_logon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->logon();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_logout__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","logout", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","logout", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->logout((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_logout__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->logout();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_logout(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_logout__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_logout__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Session.logout", 
    "    void Session.logout(std::string const &reason)\n"
    "    void Session.logout()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isEnabled(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isEnabled();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sentLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","sentLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->sentLogon();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sentLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","sentLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->sentLogout();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_receivedLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","receivedLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->receivedLogon();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isLoggedOn();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_reset(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSessionID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::SessionID *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session const *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SessionID *) &((FIX::Session const *)arg1)->getSessionID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setDataDictionaryProvider(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  DataDictionaryProvider *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setDataDictionaryProvider", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_DataDictionaryProvider,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionaryProvider const &","setDataDictionaryProvider", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionaryProvider const &","setDataDictionaryProvider", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< DataDictionaryProvider * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setDataDictionaryProvider((DataDictionaryProvider const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getDataDictionaryProvider(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DataDictionaryProvider *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session const *","getDataDictionaryProvider", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (DataDictionaryProvider *) &((FIX::Session const *)arg1)->getDataDictionaryProvider();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DataDictionaryProvider, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::SenderCompID *arg2 = 0 ;
  FIX::TargetCompID *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::TargetCompID * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(FIX::SenderCompID const &)*arg2,(FIX::TargetCompID const &)*arg3,(std::string const &)*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::SenderCompID *arg2 = 0 ;
  FIX::TargetCompID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::TargetCompID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(FIX::SenderCompID const &)*arg2,(FIX::TargetCompID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_sendToTarget(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_sendToTarget__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_sendToTarget__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_sendToTarget__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SenderCompID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__TargetCompID, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_sendToTarget__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_sendToTarget__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SenderCompID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__TargetCompID, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Session_sendToTarget__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Session_sendToTarget__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Session.sendToTarget", 
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &message)\n"
    "    bool Session.sendToTarget(FIX::Message &message, FIX::SessionID const &sessionID)\n"
    "    bool Session.sendToTarget(FIX::Message &, FIX::SenderCompID const &senderCompID, FIX::TargetCompID const &targetCompID, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &, FIX::SenderCompID const &senderCompID, FIX::TargetCompID const &targetCompID)\n"
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &senderCompID, std::string const &targetCompID, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &senderCompID, std::string const &targetCompID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSessions(int argc, VALUE *argv, VALUE self) {
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::Session::getSessions();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = swig::from(static_cast< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_doesSessionExist(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::doesSessionExist", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::doesSessionExist", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::doesSessionExist((FIX::SessionID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::lookupSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::lookupSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)FIX::Session::lookupSession((FIX::SessionID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::lookupSession", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::lookupSession", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::Session::lookupSession", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)FIX::Session::lookupSession((std::string const &)*arg1,arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::lookupSession", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::lookupSession", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)FIX::Session::lookupSession((std::string const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_lookupSession(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_lookupSession__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_lookupSession__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Session_lookupSession__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Session.lookupSession", 
    "    FIX::Session Session.lookupSession(FIX::SessionID const &)\n"
    "    FIX::Session Session.lookupSession(std::string const &, bool reverse)\n"
    "    FIX::Session * Session.lookupSession(std::string const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isSessionRegistered(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::isSessionRegistered", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::isSessionRegistered", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::isSessionRegistered((FIX::SessionID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_registerSession(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::registerSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::registerSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)FIX::Session::registerSession((FIX::SessionID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_unregisterSession(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::unregisterSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::unregisterSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      FIX::Session::unregisterSession((FIX::SessionID const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_numSessions(int argc, VALUE *argv, VALUE self) {
  size_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = FIX::Session::numSessions();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isSessionTime(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isSessionTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","isSessionTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","isSessionTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isSessionTime((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isLogonTime(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isLogonTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","isLogonTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","isLogonTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isLogonTime((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isInitiator(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isInitiator", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isInitiator();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isAcceptor(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isAcceptor", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isAcceptor();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLogonTime(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimeRange *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLogonTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (TimeRange *) &(arg1)->getLogonTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TimeRange, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setLogonTime(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  TimeRange *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setLogonTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_TimeRange,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "TimeRange const &","setLogonTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TimeRange const &","setLogonTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< TimeRange * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setLogonTime((TimeRange const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSenderDefaultApplVerID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getSenderDefaultApplVerID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &(arg1)->getSenderDefaultApplVerID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setSenderDefaultApplVerID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setSenderDefaultApplVerID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSenderDefaultApplVerID", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSenderDefaultApplVerID", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setSenderDefaultApplVerID((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getTargetDefaultApplVerID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getTargetDefaultApplVerID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &(arg1)->getTargetDefaultApplVerID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setTargetDefaultApplVerID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setTargetDefaultApplVerID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setTargetDefaultApplVerID", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setTargetDefaultApplVerID", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setTargetDefaultApplVerID((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSendRedundantResendRequests(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getSendRedundantResendRequests", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getSendRedundantResendRequests();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setSendRedundantResendRequests(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setSendRedundantResendRequests", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setSendRedundantResendRequests", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setSendRedundantResendRequests(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getCheckCompId(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getCheckCompId", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getCheckCompId();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setCheckCompId(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setCheckCompId", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setCheckCompId", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCheckCompId(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getCheckLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getCheckLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getCheckLatency();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setCheckLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setCheckLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setCheckLatency", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCheckLatency(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getMaxLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getMaxLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getMaxLatency();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setMaxLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setMaxLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setMaxLatency", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setMaxLatency(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLogonTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLogonTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getLogonTimeout();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setLogonTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setLogonTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setLogonTimeout", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setLogonTimeout(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLogoutTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLogoutTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getLogoutTimeout();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setLogoutTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setLogoutTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setLogoutTimeout", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setLogoutTimeout(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getResetOnLogon();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnLogon", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setResetOnLogon(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getResetOnLogout();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnLogout", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setResetOnLogout(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnDisconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnDisconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getResetOnDisconnect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnDisconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnDisconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnDisconnect", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setResetOnDisconnect(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getRefreshOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getRefreshOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getRefreshOnLogon();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setRefreshOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setRefreshOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setRefreshOnLogon", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setRefreshOnLogon(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getMillisecondsInTimeStamp(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getMillisecondsInTimeStamp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getMillisecondsInTimeStamp();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setMillisecondsInTimeStamp(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setMillisecondsInTimeStamp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setMillisecondsInTimeStamp", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setMillisecondsInTimeStamp(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getTimestampPrecision(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getTimestampPrecision", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getTimestampPrecision();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setTimestampPrecision(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setTimestampPrecision", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setTimestampPrecision", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setTimestampPrecision(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSupportedTimestampPrecision(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getSupportedTimestampPrecision", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getSupportedTimestampPrecision();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_supportsSubSecondTimestamps(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::supportsSubSecondTimestamps", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::supportsSubSecondTimestamps", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::Session::supportsSubSecondTimestamps((std::string const &)*arg1);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getPersistMessages(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getPersistMessages", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getPersistMessages();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setPersistMessages(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setPersistMessages", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setPersistMessages", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setPersistMessages(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getValidateLengthAndChecksum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getValidateLengthAndChecksum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->getValidateLengthAndChecksum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setValidateLengthAndChecksum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setValidateLengthAndChecksum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setValidateLengthAndChecksum", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setValidateLengthAndChecksum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResponder(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  Responder *arg2 = (Responder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResponder", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Responder, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Responder *","setResponder", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Responder * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setResponder(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_send(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","send", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","send", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","send", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->send(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","next", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","next", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->next((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  FIX::UtcTimeStamp *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","next", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","next", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","next", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","next", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::UtcTimeStamp * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","next", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->next((std::string const &)*arg2,(FIX::UtcTimeStamp const &)*arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  FIX::UtcTimeStamp *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","next", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","next", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","next", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","next", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::UtcTimeStamp * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->next((std::string const &)*arg2,(FIX::UtcTimeStamp const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::UtcTimeStamp *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","next", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","next", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","next", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","next", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::UtcTimeStamp * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","next", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->next((FIX::Message const &)*arg2,(FIX::UtcTimeStamp const &)*arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::UtcTimeStamp *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","next", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","next", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","next", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","next", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::UtcTimeStamp * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->next((FIX::Message const &)*arg2,(FIX::UtcTimeStamp const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_next__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_next__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_next__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Session_next__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Session_next__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "Session.next", 
    "    void Session.next(FIX::UtcTimeStamp const &now)\n"
    "    void Session.next(std::string const &, FIX::UtcTimeStamp const &now, bool queued)\n"
    "    void Session.next(std::string const &, FIX::UtcTimeStamp const &now)\n"
    "    void Session.next(FIX::Message const &, FIX::UtcTimeStamp const &now, bool queued)\n"
    "    void Session.next(FIX::Message const &, FIX::UtcTimeStamp const &now)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_disconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","disconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->disconnect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getExpectedSenderNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getExpectedSenderNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getExpectedSenderNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getExpectedTargetNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getExpectedTargetNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->getExpectedTargetNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLog(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLog", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (Log *)(arg1)->getLog();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getStore(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getStore", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (MessageStore *)(arg1)->getStore();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassLogFactory;

SWIGINTERN void
free_FIX_LogFactory(void *self) {
    FIX::LogFactory *arg1 = (FIX::LogFactory *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_LogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_LogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_LogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "LogFactory.create", 
    "    FIX::Log LogFactory.create()\n"
    "    FIX::Log * LogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassScreenLogFactory;

SWIGINTERN VALUE
_wrap_new_ScreenLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLogFactory";
  FIX::ScreenLogFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","ScreenLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","ScreenLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ScreenLogFactory *)new FIX::ScreenLogFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_ScreenLogFactory_allocate(VALUE self)
#else
_wrap_ScreenLogFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ScreenLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_ScreenLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLogFactory";
  FIX::ScreenLogFactory *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","ScreenLogFactory", 1, argv[0] ));
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ScreenLogFactory", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","ScreenLogFactory", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ScreenLogFactory *)new FIX::ScreenLogFactory(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ScreenLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ScreenLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_ScreenLogFactory__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ScreenLogFactory.new", 
    "    ScreenLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    ScreenLogFactory.new(bool incoming, bool outgoing, bool event)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ScreenLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__ScreenLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ScreenLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__ScreenLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ScreenLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ScreenLogFactory.create", 
    "    FIX::Log ScreenLogFactory.create()\n"
    "    FIX::Log * ScreenLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_ScreenLogFactory(void *self) {
    FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *)self;
    delete arg1;
}

static swig_class SwigClassLog;

SWIGINTERN void
free_FIX_Log(void *self) {
    FIX::Log *arg1 = (FIX::Log *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::Log.clear

  call-seq:
    clear

Clear Log contents.
*/
SWIGINTERN VALUE
_wrap_Log_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_backup(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


static swig_class SwigClassNullLog;

/*
  Document-method: Quickfix::NullLog.clear

  call-seq:
    clear

Clear NullLog contents.
*/
SWIGINTERN VALUE
_wrap_NullLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::NullLog *arg1 = (FIX::NullLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NullLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NullLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NullLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NullLog_backup(int argc, VALUE *argv, VALUE self) {
  FIX::NullLog *arg1 = (FIX::NullLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NullLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NullLog *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NullLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NullLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::NullLog *arg1 = (FIX::NullLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NullLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NullLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NullLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NullLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::NullLog *arg1 = (FIX::NullLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NullLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NullLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NullLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NullLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::NullLog *arg1 = (FIX::NullLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NullLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NullLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NullLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_NullLog_allocate(VALUE self)
#else
_wrap_NullLog_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__NullLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_NullLog(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::NullLog";
  FIX::NullLog *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::NullLog *)new FIX::NullLog();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_NullLog(void *self) {
    FIX::NullLog *arg1 = (FIX::NullLog *)self;
    delete arg1;
}

static swig_class SwigClassScreenLog;

SWIGINTERN VALUE
_wrap_new_ScreenLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLog";
  FIX::ScreenLog *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","ScreenLog", 1, argv[0] ));
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ScreenLog", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","ScreenLog", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ScreenLog *)new FIX::ScreenLog(arg1,arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_ScreenLog_allocate(VALUE self)
#else
_wrap_ScreenLog_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ScreenLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_ScreenLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLog";
  FIX::ScreenLog *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","ScreenLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","ScreenLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ScreenLog", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","ScreenLog", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","ScreenLog", 4, argv[3] ));
  } 
  arg4 = static_cast< bool >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::ScreenLog *)new FIX::ScreenLog((FIX::SessionID const &)*arg1,arg2,arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ScreenLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v = 0;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_ScreenLog__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_ScreenLog__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "ScreenLog.new", 
    "    ScreenLog.new(bool incoming, bool outgoing, bool event)\n"
    "    ScreenLog.new(FIX::SessionID const &sessionID, bool incoming, bool outgoing, bool event)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::ScreenLog.clear

  call-seq:
    clear

Clear ScreenLog contents.
*/
SWIGINTERN VALUE
_wrap_ScreenLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_backup(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_ScreenLog(void *self) {
    FIX::ScreenLog *arg1 = (FIX::ScreenLog *)self;
    delete arg1;
}

static swig_class SwigClassFileLogFactory;

SWIGINTERN VALUE
_wrap_new_FileLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileLogFactory";
  FIX::FileLogFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FileLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FileLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLogFactory *)new FIX::FileLogFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FileLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLogFactory";
  FIX::FileLogFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLogFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLogFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLogFactory *)new FIX::FileLogFactory((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FileLogFactory_allocate(VALUE self)
#else
_wrap_FileLogFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FileLogFactory__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLogFactory";
  FIX::FileLogFactory *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLogFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLogFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FileLogFactory", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLogFactory", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLogFactory *)new FIX::FileLogFactory((std::string const &)*arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLogFactory__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FileLogFactory__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FileLogFactory.new", 
    "    FileLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    FileLogFactory.new(std::string const &path)\n"
    "    FileLogFactory.new(std::string const &path, std::string const &backupPath)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FileLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FileLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FileLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FileLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FileLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FileLogFactory.create", 
    "    FIX::Log FileLogFactory.create()\n"
    "    FIX::Log * FileLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileLogFactory(void *self) {
    FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *)self;
    delete arg1;
}

static swig_class SwigClassFileLog;

SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  FIX::FileLog *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  FIX::FileLog *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FileLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1,(std::string const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  FIX::FileLog *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FileLog", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FileLog", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1,(FIX::SessionID const &)*arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FileLog_allocate(VALUE self)
#else
_wrap_FileLog_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  FIX::FileLog *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FileLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","FileLog", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FileLog", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1,(std::string const &)*arg2,(FIX::SessionID const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLog__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FileLog__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FileLog__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_FileLog__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FileLog.new", 
    "    FileLog.new(std::string const &path)\n"
    "    FileLog.new(std::string const &path, std::string const &backupPath)\n"
    "    FileLog.new(std::string const &path, FIX::SessionID const &sessionID)\n"
    "    FileLog.new(std::string const &path, std::string const &backupPath, FIX::SessionID const &sessionID)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FileLog(void *self) {
    FIX::FileLog *arg1 = (FIX::FileLog *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::FileLog.clear

  call-seq:
    clear

Clear FileLog contents.
*/
SWIGINTERN VALUE
_wrap_FileLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_backup(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


static swig_class SwigClassMessageStoreFactory;

SWIGINTERN void
free_FIX_MessageStoreFactory(void *self) {
    FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassMemoryStoreFactory;

SWIGINTERN VALUE
_wrap_MemoryStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStoreFactory *arg1 = (FIX::MemoryStoreFactory *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStoreFactory *arg1 = (FIX::MemoryStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MemoryStoreFactory_allocate(VALUE self)
#else
_wrap_MemoryStoreFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MemoryStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MemoryStoreFactory(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::MemoryStoreFactory";
  FIX::MemoryStoreFactory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MemoryStoreFactory *)new FIX::MemoryStoreFactory();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MemoryStoreFactory(void *self) {
    FIX::MemoryStoreFactory *arg1 = (FIX::MemoryStoreFactory *)self;
    delete arg1;
}

static swig_class SwigClassMessageStore;

SWIGINTERN void
free_FIX_MessageStore(void *self) {
    FIX::MessageStore *arg1 = (FIX::MessageStore *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::MessageStore const *)arg1)->get(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MessageStore const *)arg1)->getNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MessageStore const *)arg1)->getNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::MessageStore const *)arg1)->getCreationTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassMemoryStore;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MemoryStore_allocate(VALUE self)
#else
_wrap_MemoryStore_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MemoryStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MemoryStore(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MemoryStore";
  FIX::MemoryStore *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","MemoryStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","MemoryStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MemoryStore *)new FIX::MemoryStore((FIX::UtcTimeStamp const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::MemoryStore const *)arg1)->get(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MemoryStore const *)arg1)->getNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MemoryStore const *)arg1)->getNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","setCreationTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","setCreationTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCreationTime((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::MemoryStore const *)arg1)->getCreationTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MemoryStore(void *self) {
    FIX::MemoryStore *arg1 = (FIX::MemoryStore *)self;
    delete arg1;
}

static swig_class SwigClassMessageStoreFactoryExceptionWrapper;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MessageStoreFactoryExceptionWrapper_allocate(VALUE self)
#else
_wrap_MessageStoreFactoryExceptionWrapper_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MessageStoreFactoryExceptionWrapper(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MessageStoreFactoryExceptionWrapper";
  FIX::MessageStoreFactoryExceptionWrapper *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","MessageStoreFactoryExceptionWrapper", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStoreFactoryExceptionWrapper *)new FIX::MessageStoreFactoryExceptionWrapper(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactoryExceptionWrapper_create(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactoryExceptionWrapper *arg1 = (FIX::MessageStoreFactoryExceptionWrapper *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  bool *arg4 = 0 ;
  FIX::ConfigError *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactoryExceptionWrapper *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactoryExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "bool &","create", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","create", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< bool * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_FIX__ConfigError,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::ConfigError &","create", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::ConfigError &","create", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< FIX::ConfigError * >(argp5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3,*arg4,*arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactoryExceptionWrapper_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactoryExceptionWrapper *arg1 = (FIX::MessageStoreFactoryExceptionWrapper *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactoryExceptionWrapper *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactoryExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageStoreFactoryExceptionWrapper(void *self) {
    FIX::MessageStoreFactoryExceptionWrapper *arg1 = (FIX::MessageStoreFactoryExceptionWrapper *)self;
    delete arg1;
}

static swig_class SwigClassMessageStoreExceptionWrapper;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MessageStoreExceptionWrapper_allocate(VALUE self)
#else
_wrap_MessageStoreExceptionWrapper_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageStoreExceptionWrapper);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MessageStoreExceptionWrapper(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MessageStoreExceptionWrapper";
  FIX::MessageStoreExceptionWrapper *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","MessageStoreExceptionWrapper", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStoreExceptionWrapper *)new FIX::MessageStoreExceptionWrapper(arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageStoreExceptionWrapper(void *self) {
    FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_set(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool *arg4 = 0 ;
  FIX::IOException *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "bool &","set", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","set", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< bool * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::IOException &","set", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","set", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< FIX::IOException * >(argp5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3,*arg4,*arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_get(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  bool *arg5 = 0 ;
  FIX::IOException *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "bool &","get", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","get", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< bool * >(argp5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::IOException &","get", 6, argv[4] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","get", 6, argv[4])); 
  }
  arg6 = reinterpret_cast< FIX::IOException * >(argp6);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::MessageStoreExceptionWrapper const *)arg1)->get(arg2,arg3,*arg4,*arg5,*arg6);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getNextSenderMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getNextSenderMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MessageStoreExceptionWrapper const *)arg1)->getNextSenderMsgSeqNum(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getNextTargetMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getNextTargetMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MessageStoreExceptionWrapper const *)arg1)->getNextTargetMsgSeqNum(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  FIX::IOException *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","setNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","setNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::IOException &","setNextSenderMsgSeqNum", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","setNextSenderMsgSeqNum", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::IOException * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2,*arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  FIX::IOException *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","setNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","setNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::IOException &","setNextTargetMsgSeqNum", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","setNextTargetMsgSeqNum", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::IOException * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2,*arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","incrNextSenderMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","incrNextSenderMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","incrNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","incrNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","incrNextTargetMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","incrNextTargetMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","incrNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","incrNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getCreationTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getCreationTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getCreationTime", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getCreationTime", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (arg1)->getCreationTime(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  bool *arg3 = 0 ;
  FIX::IOException *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","reset", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","reset", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::IOException &","reset", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","reset", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::IOException * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2,*arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","refresh", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","refresh", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","refresh", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","refresh", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh(*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassFileStoreFactory;

SWIGINTERN VALUE
_wrap_new_FileStoreFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileStoreFactory";
  FIX::FileStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FileStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FileStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileStoreFactory *)new FIX::FileStoreFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FileStoreFactory_allocate(VALUE self)
#else
_wrap_FileStoreFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FileStoreFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileStoreFactory";
  FIX::FileStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FileStoreFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FileStoreFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileStoreFactory *)new FIX::FileStoreFactory((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileStoreFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileStoreFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileStoreFactory__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FileStoreFactory.new", 
    "    FileStoreFactory.new(FIX::SessionSettings const &settings)\n"
    "    FileStoreFactory.new(std::string const &path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::FileStoreFactory *arg1 = (FIX::FileStoreFactory *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::FileStoreFactory *arg1 = (FIX::FileStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileStoreFactory(void *self) {
    FIX::FileStoreFactory *arg1 = (FIX::FileStoreFactory *)self;
    delete arg1;
}

static swig_class SwigClassFileStore;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_FileStore_allocate(VALUE self)
#else
_wrap_FileStore_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_FileStore(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  std::string arg2 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileStore";
  FIX::FileStore *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","FileStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","FileStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","FileStore", 2, argv[1] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","FileStore", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FileStore", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::FileStore *)new FIX::FileStore((FIX::UtcTimeStamp const &)*arg1,arg2,(FIX::SessionID const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileStore(void *self) {
    FIX::FileStore *arg1 = (FIX::FileStore *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FileStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::FileStore const *)arg1)->get(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FileStore const *)arg1)->getNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::FileStore const *)arg1)->getNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::FileStore const *)arg1)->getCreationTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassApplication;

SWIGINTERN void
free_FIX_Application(void *self) {
    FIX::Application *arg1 = (FIX::Application *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Application_onCreate(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onCreate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onCreate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onCreate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::onCreate");
            } else {
          (arg1)->onCreate((FIX::SessionID const &)*arg2);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_onLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogon", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogon", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::onLogon");
            } else {
          (arg1)->onLogon((FIX::SessionID const &)*arg2);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_onLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogout", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogout", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::onLogout");
            } else {
          (arg1)->onLogout((FIX::SessionID const &)*arg2);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_toAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","toAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::toAdmin");
            } else {
          (arg1)->toAdmin(*arg2,(FIX::SessionID const &)*arg3);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_toApp(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","toApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::toApp");
            } else {
          (arg1)->toApp(*arg2,(FIX::SessionID const &)*arg3);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_fromAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","fromAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::fromAdmin");
            } else {
          (arg1)->fromAdmin((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_fromApp(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","fromApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    {
      if(tryRubyException([&]() mutable 
          {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("FIX::Application::fromApp");
            } else {
          (arg1)->fromApp((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
            }
            return self;
          fail:
            return Qnil;
          }) == Qnil) 
      {
        SWIG_fail;
      }
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_Application_allocate(VALUE self)
#else
_wrap_Application_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Application);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_Application(int argc, VALUE *argv, VALUE self) {
  VALUE arg1 = (VALUE) 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Application";
  FIX::Application *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  arg1 = self;
  {
    if(tryRubyException([&]() mutable 
        {
      if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
            result = (FIX::Application *)new SwigDirector_Application(arg1); 
          } else {
        rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
            return Qnil;
          }
          
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_disown_Application(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","disown_Application", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassSynchronizedApplication;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SynchronizedApplication_allocate(VALUE self)
#else
_wrap_SynchronizedApplication_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SynchronizedApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SynchronizedApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SynchronizedApplication";
  FIX::SynchronizedApplication *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SynchronizedApplication", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SynchronizedApplication", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SynchronizedApplication *)new FIX::SynchronizedApplication(*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onCreate(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onCreate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onCreate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onCreate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onCreate((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onLogon(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogon", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogon", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onLogon((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onLogout(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogout", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogout", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onLogout((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_toAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","toAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->toAdmin(*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_toApp(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","toApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->toApp(*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_fromAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","fromAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->fromAdmin((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_fromApp(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","fromApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->fromApp((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_mutex_set(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  Mutex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_mutex", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_Mutex,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Mutex","m_mutex", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Mutex","m_mutex", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< Mutex * >(argp2));
    }
  }
  if (arg1) (arg1)->m_mutex = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_mutex_get(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Mutex result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_mutex", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  result =  ((arg1)->m_mutex);
  vresult = SWIG_NewPointerObj((new Mutex(result)), SWIGTYPE_p_Mutex, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_app(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  FIX::Application *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Application *) &(arg1)->app();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_app_set(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Application *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Application &","m_app", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","m_app", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Application * >(argp2);
  if (arg1) (arg1)->m_app = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_app_get(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  FIX::Application *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  result = (FIX::Application *) &(FIX::Application &) ((arg1)->m_app);
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SynchronizedApplication(void *self) {
    FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *)self;
    delete arg1;
}

static swig_class SwigClassNullApplication;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_NullApplication_allocate(VALUE self)
#else
_wrap_NullApplication_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__NullApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_NullApplication(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::NullApplication";
  FIX::NullApplication *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::NullApplication *)new FIX::NullApplication();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_NullApplication(void *self) {
    FIX::NullApplication *arg1 = (FIX::NullApplication *)self;
    delete arg1;
}

static swig_class SwigClassInitiator;

SWIGINTERN void
free_FIX_Initiator(void *self) {
    FIX::Initiator *arg1 = (FIX::Initiator *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Initiator_start(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","start", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->start();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_block(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","block", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->block();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_poll(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","poll", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->poll();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_stop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","stop", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->stop(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_stop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->stop();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Initiator_stop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Initiator_stop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Initiator_stop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Initiator.stop", 
    "    void Initiator.stop(bool force)\n"
    "    void Initiator.stop()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isLoggedOn();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSession__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  Responder *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSession", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSession", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_Responder,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "Responder &","getSession", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Responder &","getSession", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< Responder * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)(arg1)->getSession((FIX::SessionID const &)*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *) &((FIX::Initiator const *)arg1)->getSessions();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = swig::from(static_cast< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSession__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator const *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSession", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSession", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)((FIX::Initiator const *)arg1)->getSession((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Initiator_getSession(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Initiator_getSession__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_Responder, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Initiator_getSession__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Initiator.getSession", 
    "    FIX::Session Initiator.getSession(FIX::SessionID const &sessionID, Responder &)\n"
    "    FIX::Session * Initiator.getSession(FIX::SessionID const &sessionID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSessionSettings(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Dictionary *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator const *","getSessionSettings", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSessionSettings", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSessionSettings", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *)((FIX::Initiator const *)arg1)->getSessionSettings((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_has(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->has((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_isStopped(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","isStopped", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isStopped();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  FIX::Application *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getApplication", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Application *) &(arg1)->getApplication();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getMessageStoreFactory(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::MessageStoreFactory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getMessageStoreFactory", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStoreFactory *) &(arg1)->getMessageStoreFactory();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getLog(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getLog", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->getLog();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassSocketInitiatorBase;

SWIGINTERN VALUE
_wrap_new_SocketInitiatorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketInitiatorBase";
  FIX::SocketInitiator *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketInitiator *)new FIX::SocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketInitiatorBase_allocate(VALUE self)
#else
_wrap_SocketInitiatorBase_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketInitiator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketInitiatorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketInitiatorBase";
  FIX::SocketInitiator *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","SocketInitiator", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","SocketInitiator", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketInitiator *)new FIX::SocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketInitiatorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SocketInitiatorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, SWIG_POINTER_NO_NULL);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SocketInitiatorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SocketInitiator.new", 
    "    SocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketInitiator(void *self) {
    FIX::SocketInitiator *arg1 = (FIX::SocketInitiator *)self;
    delete arg1;
}

static swig_class SwigClassAcceptor;

SWIGINTERN void
free_FIX_Acceptor(void *self) {
    FIX::Acceptor *arg1 = (FIX::Acceptor *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Acceptor_getLog(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getLog", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->getLog();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_start(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","start", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->start();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_block(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","block", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->block();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_poll(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","poll", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->poll();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_stop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","stop", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->stop(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_stop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->stop();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Acceptor_stop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Acceptor_stop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Acceptor_stop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Acceptor.stop", 
    "    void Acceptor.stop(bool force)\n"
    "    void Acceptor.stop()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isLoggedOn();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSession__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  std::string *arg2 = 0 ;
  Responder *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSession", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSession", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_Responder,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "Responder &","getSession", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Responder &","getSession", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< Responder * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)(arg1)->getSession((std::string const &)*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *) &((FIX::Acceptor const *)arg1)->getSessions();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = swig::from(static_cast< std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSession__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Session *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor const *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSession", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSession", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Session *)((FIX::Acceptor const *)arg1)->getSession((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Acceptor_getSession(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Acceptor_getSession__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_Responder, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Acceptor_getSession__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Acceptor.getSession", 
    "    FIX::Session Acceptor.getSession(std::string const &msg, Responder &)\n"
    "    FIX::Session * Acceptor.getSession(FIX::SessionID const &sessionID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSessionSettings(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Dictionary *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor const *","getSessionSettings", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSessionSettings", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSessionSettings", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Dictionary *)((FIX::Acceptor const *)arg1)->getSessionSettings((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_has(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->has((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_isStopped(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","isStopped", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->isStopped();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  FIX::Application *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getApplication", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Application *) &(arg1)->getApplication();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getMessageStoreFactory(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::MessageStoreFactory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getMessageStoreFactory", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStoreFactory *) &(arg1)->getMessageStoreFactory();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassSocketAcceptorBase;

SWIGINTERN VALUE
_wrap_new_SocketAcceptorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketAcceptorBase";
  FIX::SocketAcceptor *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketAcceptor *)new FIX::SocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SocketAcceptorBase_allocate(VALUE self)
#else
_wrap_SocketAcceptorBase_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketAcceptor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SocketAcceptorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketAcceptorBase";
  FIX::SocketAcceptor *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","SocketAcceptor", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","SocketAcceptor", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketAcceptor *)new FIX::SocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketAcceptorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SocketAcceptorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, SWIG_POINTER_NO_NULL);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SocketAcceptorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SocketAcceptor.new", 
    "    SocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketAcceptor(void *self) {
    FIX::SocketAcceptor *arg1 = (FIX::SocketAcceptor *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SocketAcceptorBase_sessionToPort(int argc, VALUE *argv, VALUE self) {
  FIX::SocketAcceptor *arg1 = (FIX::SocketAcceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::SocketAcceptor::SessionToPort *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SocketAcceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SocketAcceptor *","sessionToPort", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SocketAcceptor * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SocketAcceptor::SessionToPort *) &(arg1)->sessionToPort();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_FIX__SessionID_uint16_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassDataDictionary;

SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","DataDictionary", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","DataDictionary", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary((FIX::DataDictionary const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","DataDictionary", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","DataDictionary", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","DataDictionary", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary(*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","DataDictionary", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","DataDictionary", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary(*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DataDictionary", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DataDictionary", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","DataDictionary", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary((std::string const &)*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DataDictionary_allocate(VALUE self)
#else
_wrap_DataDictionary_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DataDictionary);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  FIX::DataDictionary *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DataDictionary", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DataDictionary", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DataDictionary *)new FIX::DataDictionary((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DataDictionary(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DataDictionary__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DataDictionary, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_DataDictionary__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_DataDictionary__SWIG_4(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "DataDictionary.new", 
    "    DataDictionary.new()\n"
    "    DataDictionary.new(FIX::DataDictionary const &copy)\n"
    "    DataDictionary.new(std::istream &stream, bool preserveMsgFldsOrder)\n"
    "    DataDictionary.new(std::istream &stream)\n"
    "    DataDictionary.new(std::string const &url, bool preserveMsgFldsOrder)\n"
    "    DataDictionary.new(std::string const &url)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DataDictionary(void *self) {
    FIX::DataDictionary *arg1 = (FIX::DataDictionary *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DataDictionary_readFromURL(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromURL", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","readFromURL", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","readFromURL", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->readFromURL((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_readFromDocument(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  DOMDocumentPtr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_DOMDocumentPtr,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DOMDocumentPtr const &","readFromDocument", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DOMDocumentPtr const &","readFromDocument", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< DOMDocumentPtr * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->readFromDocument((DOMDocumentPtr const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_readFromStream(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::istream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromStream", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream &","readFromStream", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","readFromStream", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->readFromStream(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getOrderedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  message_order *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getOrderedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (message_order *) &((FIX::DataDictionary const *)arg1)->getOrderedFields();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_message_order, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getHeaderOrderedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  message_order *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getHeaderOrderedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (message_order *) &((FIX::DataDictionary const *)arg1)->getHeaderOrderedFields();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_message_order, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getTrailerOrderedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  message_order *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getTrailerOrderedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (message_order *) &((FIX::DataDictionary const *)arg1)->getTrailerOrderedFields();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_message_order, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getMessageOrderedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  message_order *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getMessageOrderedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getMessageOrderedFields", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getMessageOrderedFields", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (message_order *) &((FIX::DataDictionary const *)arg1)->getMessageOrderedFields((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_message_order, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_setVersion(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","setVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setVersion", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setVersion", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setVersion((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getVersion(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::DataDictionary const *)arg1)->getVersion();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addFieldName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addFieldName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addFieldName(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getFieldName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string temp3 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    temp3 = std::string((char*)StringValuePtr(argv[1]));
    arg3 = &temp3;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getFieldName(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getFieldTag(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int temp3 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldTag", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getFieldTag", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getFieldTag", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    temp3 = NUM2INT(argv[1]);
    arg3 = &temp3;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getFieldTag((std::string const &)*arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg3)) : Qnil;
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addValueName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addValueName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addValueName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addValueName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addValueName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","addValueName", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addValueName", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addValueName(arg2,(std::string const &)*arg3,(std::string const &)*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getValueName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  std::string temp4 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getValueName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getValueName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","getValueName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getValueName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    temp4 = std::string((char*)StringValuePtr(argv[2]));
    arg4 = &temp4;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getValueName(arg2,(std::string const &)*arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getNameValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  std::string temp4 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getNameValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getNameValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","getNameValue", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getNameValue", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    temp4 = std::string((char*)StringValuePtr(argv[2]));
    arg4 = &temp4;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getNameValue(arg2,(std::string const &)*arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addMsgType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addMsgType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addMsgType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addMsgType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addMsgType((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMsgType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMsgType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isMsgType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isMsgType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isMsgType((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addMsgField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addMsgField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addMsgField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addMsgField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addMsgField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addMsgField((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMsgField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMsgField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isMsgField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isMsgField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isMsgField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isMsgField((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addHeaderField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addHeaderField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addHeaderField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","addHeaderField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addHeaderField(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isHeaderField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isHeaderField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isHeaderField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isHeaderField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addTrailerField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addTrailerField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addTrailerField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","addTrailerField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addTrailerField(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isTrailerField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isTrailerField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isTrailerField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isTrailerField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  FIX::TYPE::Type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "FIX::TYPE::Type","addFieldType", 3, argv[1] ));
  } 
  arg3 = static_cast< FIX::TYPE::Type >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addFieldType(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getFieldType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  FIX::TYPE::Type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__TYPE__Type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::TYPE::Type &","getFieldType", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::TYPE::Type &","getFieldType", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::TYPE::Type * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getFieldType(arg2,*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addRequiredField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addRequiredField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addRequiredField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addRequiredField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addRequiredField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addRequiredField((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isRequiredField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isRequiredField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isRequiredField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isRequiredField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isRequiredField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isRequiredField((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addFieldValue", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addFieldValue", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addFieldValue(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_hasFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","hasFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->hasFieldValue(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","isFieldValue", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isFieldValue", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isFieldValue(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  FIX::DataDictionary *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","addGroup", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","addGroup", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","addGroup", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->addGroup((std::string const &)*arg2,arg3,arg4,(FIX::DataDictionary const &)*arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isGroup((std::string const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int *arg4 = 0 ;
  FIX::DataDictionary **arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int temp4 ;
  FIX::DataDictionary *temp5 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    temp4 = NUM2INT(argv[2]);
    arg4 = &temp4;
  }
  {
    arg5 = new FIX::DataDictionary*[1];
    *arg5 = temp5;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->getGroup((std::string const &)*arg2,arg3,*arg4,(FIX::DataDictionary const *&)*arg5);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg4)) : Qnil;
    }
  }
  {
    void* argp;
    FIX::DataDictionary* pDD = 0;
    int res = SWIG_ConvertPtr(argv[3], &argp, SWIGTYPE_p_FIX__DataDictionary, 0 );
    pDD = reinterpret_cast< FIX::DataDictionary * >(argp);
    *pDD = *(*arg5);
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isDataField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isDataField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isDataField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isDataField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMultipleValueField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMultipleValueField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isMultipleValueField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isMultipleValueField(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkFieldsOutOfOrder(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkFieldsOutOfOrder", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkFieldsOutOfOrder", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->checkFieldsOutOfOrder(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkFieldsHaveValues(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkFieldsHaveValues", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkFieldsHaveValues", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->checkFieldsHaveValues(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkUserDefinedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkUserDefinedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkUserDefinedFields", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->checkUserDefinedFields(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_allowUnknownMsgFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","allowUnknownMsgFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","allowUnknownMsgFields", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->allowUnknownMsgFields(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_preserveMessageFieldsOrder(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","preserveMessageFieldsOrder", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","preserveMessageFieldsOrder", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->preserveMessageFieldsOrder(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMessageFieldsOrderPreserved(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMessageFieldsOrderPreserved", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)((FIX::DataDictionary const *)arg1)->isMessageFieldsOrderPreserved();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_validate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::DataDictionary *arg2 = (FIX::DataDictionary *) (FIX::DataDictionary *)0 ;
  FIX::DataDictionary *arg3 = (FIX::DataDictionary *) (FIX::DataDictionary *)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const &","FIX::DataDictionary::validate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","FIX::DataDictionary::validate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const *const","FIX::DataDictionary::validate", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::DataDictionary const *const","FIX::DataDictionary::validate", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< FIX::DataDictionary * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      FIX::DataDictionary::validate((FIX::Message const &)*arg1,(FIX::DataDictionary const *)arg2,(FIX::DataDictionary const *)arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_validate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  FIX::Message *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","validate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","validate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","validate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::DataDictionary const *)arg1)->validate((FIX::Message const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_validate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  FIX::Message *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","validate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","validate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","validate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","validate", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::DataDictionary const *)arg1)->validate((FIX::Message const &)*arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DataDictionary_validate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataDictionary_validate__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DataDictionary_validate__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DataDictionary_validate__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DataDictionary.validate", 
    "    void DataDictionary.validate(FIX::DataDictionary const *const pSessionDD, FIX::DataDictionary const *const pAppID)\n"
    "    void DataDictionary.validate(FIX::Message const &message)\n"
    "    void DataDictionary.validate(FIX::Message const &message, bool bodyOnly)\n");
  
  return Qnil;
}


static swig_class SwigClassSSLSocketAcceptorBase;

SWIGINTERN VALUE
_wrap_new_SSLSocketAcceptorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SSLSocketAcceptorBase";
  FIX::SSLSocketAcceptor *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SSLSocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SSLSocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SSLSocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SSLSocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SSLSocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SSLSocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SSLSocketAcceptor *)new FIX::SSLSocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SSLSocketAcceptorBase_allocate(VALUE self)
#else
_wrap_SSLSocketAcceptorBase_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SSLSocketAcceptor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SSLSocketAcceptorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SSLSocketAcceptorBase";
  FIX::SSLSocketAcceptor *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SSLSocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SSLSocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SSLSocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SSLSocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SSLSocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SSLSocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","SSLSocketAcceptor", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","SSLSocketAcceptor", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SSLSocketAcceptor *)new FIX::SSLSocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SSLSocketAcceptorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SSLSocketAcceptorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, SWIG_POINTER_NO_NULL);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SSLSocketAcceptorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SSLSocketAcceptor.new", 
    "    SSLSocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SSLSocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SSLSocketAcceptor(void *self) {
    FIX::SSLSocketAcceptor *arg1 = (FIX::SSLSocketAcceptor *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SSLSocketAcceptorBase_setPassword(int argc, VALUE *argv, VALUE self) {
  FIX::SSLSocketAcceptor *arg1 = (FIX::SSLSocketAcceptor *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SSLSocketAcceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SSLSocketAcceptor *","setPassword", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SSLSocketAcceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setPassword", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setPassword", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setPassword((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SSLSocketAcceptorBase_passwordHandleCallback(int argc, VALUE *argv, VALUE self) {
  FIX::SSLSocketAcceptor *arg1 = (FIX::SSLSocketAcceptor *) 0 ;
  char *arg2 = (char *) 0 ;
  size_t arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SSLSocketAcceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SSLSocketAcceptor *","passwordHandleCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SSLSocketAcceptor * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","passwordHandleCallback", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "size_t","passwordHandleCallback", 3, argv[1] ));
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","passwordHandleCallback", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->passwordHandleCallback(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SSLSocketAcceptorBase_passPhraseHandleCB(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","FIX::SSLSocketAcceptor::passPhraseHandleCB", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::SSLSocketAcceptor::passPhraseHandleCB", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::SSLSocketAcceptor::passPhraseHandleCB", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[3],SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "void *","FIX::SSLSocketAcceptor::passPhraseHandleCB", 4, argv[3] )); 
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)FIX::SSLSocketAcceptor::passPhraseHandleCB(arg1,arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


static swig_class SwigClassSSLSocketInitiatorBase;

SWIGINTERN VALUE
_wrap_new_SSLSocketInitiatorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SSLSocketInitiatorBase";
  FIX::SSLSocketInitiator *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SSLSocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SSLSocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SSLSocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SSLSocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SSLSocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SSLSocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SSLSocketInitiator *)new FIX::SSLSocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_SSLSocketInitiatorBase_allocate(VALUE self)
#else
_wrap_SSLSocketInitiatorBase_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SSLSocketInitiator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_SSLSocketInitiatorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SSLSocketInitiatorBase";
  FIX::SSLSocketInitiator *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","SSLSocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","SSLSocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","SSLSocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","SSLSocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","SSLSocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","SSLSocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","SSLSocketInitiator", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","SSLSocketInitiator", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::SSLSocketInitiator *)new FIX::SSLSocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SSLSocketInitiatorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SSLSocketInitiatorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, SWIG_POINTER_NO_NULL);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SSLSocketInitiatorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SSLSocketInitiator.new", 
    "    SSLSocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SSLSocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SSLSocketInitiator(void *self) {
    FIX::SSLSocketInitiator *arg1 = (FIX::SSLSocketInitiator *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SSLSocketInitiatorBase_setPassword(int argc, VALUE *argv, VALUE self) {
  FIX::SSLSocketInitiator *arg1 = (FIX::SSLSocketInitiator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SSLSocketInitiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SSLSocketInitiator *","setPassword", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SSLSocketInitiator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setPassword", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setPassword", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setPassword((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SSLSocketInitiatorBase_setCertAndKey(int argc, VALUE *argv, VALUE self) {
  FIX::SSLSocketInitiator *arg1 = (FIX::SSLSocketInitiator *) 0 ;
  X509 *arg2 = (X509 *) 0 ;
  RSA *arg3 = (RSA *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SSLSocketInitiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SSLSocketInitiator *","setCertAndKey", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SSLSocketInitiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_X509, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "X509 *","setCertAndKey", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< X509 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_RSA, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "RSA *","setCertAndKey", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< RSA * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setCertAndKey(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SSLSocketInitiatorBase_passwordHandleCallback(int argc, VALUE *argv, VALUE self) {
  FIX::SSLSocketInitiator *arg1 = (FIX::SSLSocketInitiator *) 0 ;
  char *arg2 = (char *) 0 ;
  size_t arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SSLSocketInitiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SSLSocketInitiator *","passwordHandleCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SSLSocketInitiator * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","passwordHandleCallback", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "size_t","passwordHandleCallback", 3, argv[1] ));
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","passwordHandleCallback", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->passwordHandleCallback(arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SSLSocketInitiatorBase_passwordHandleCB(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","FIX::SSLSocketInitiator::passwordHandleCB", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::SSLSocketInitiator::passwordHandleCB", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::SSLSocketInitiator::passwordHandleCB", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[3],SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "void *","FIX::SSLSocketInitiator::passwordHandleCB", 4, argv[3] )); 
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)FIX::SSLSocketInitiator::passwordHandleCB(arg1,arg2,arg3,arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


static swig_class SwigClassDatabaseConnectionID;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_DatabaseConnectionID_allocate(VALUE self)
#else
_wrap_DatabaseConnectionID_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DatabaseConnectionID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_DatabaseConnectionID(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DatabaseConnectionID";
  FIX::DatabaseConnectionID *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","DatabaseConnectionID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DatabaseConnectionID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DatabaseConnectionID", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DatabaseConnectionID", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","DatabaseConnectionID", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DatabaseConnectionID", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","DatabaseConnectionID", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DatabaseConnectionID", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","DatabaseConnectionID", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DatabaseConnectionID *)new FIX::DatabaseConnectionID((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DatabaseConnectionID_getDatabase(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const *","getDatabase", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::DatabaseConnectionID const *)arg1)->getDatabase();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DatabaseConnectionID_getUser(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const *","getUser", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::DatabaseConnectionID const *)arg1)->getUser();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DatabaseConnectionID_getPassword(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const *","getPassword", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::DatabaseConnectionID const *)arg1)->getPassword();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DatabaseConnectionID_getHost(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const *","getHost", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &((FIX::DatabaseConnectionID const *)arg1)->getHost();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DatabaseConnectionID_getPort(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const *","getPort", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (short)((FIX::DatabaseConnectionID const *)arg1)->getPort();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_short(static_cast< short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_DatabaseConnectionID(void *self) {
    FIX::DatabaseConnectionID *arg1 = (FIX::DatabaseConnectionID *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  FIX::DatabaseConnectionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator <((FIX::DatabaseConnectionID const &)*arg1,(FIX::DatabaseConnectionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___lt__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_6(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__lt__", 
    "    bool __lt__(FIX::DateTime const &lhs, FIX::DateTime const &rhs)\n"
    "    bool __lt__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __lt__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __lt__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __lt__(std::string const &lhs, FIX::StringField const &rhs)\n"
    "    bool __lt__(FIX::SessionID const &lhs, FIX::SessionID const &rhs)\n"
    "    bool __lt__(FIX::DatabaseConnectionID const &lhs, FIX::DatabaseConnectionID const &rhs)\n");
  
  return Qnil;
}


/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  FIX::DatabaseConnectionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)FIX::operator ==((FIX::DatabaseConnectionID const &)*arg1,(FIX::DatabaseConnectionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___eq__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DateTime, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_6(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v = 0;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__eq__", 
    "    bool __eq__(FIX::DateTime const &lhs, FIX::DateTime const &rhs)\n"
    "    bool __eq__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __eq__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __eq__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __eq__(std::string const &lhs, FIX::StringField const &rhs)\n"
    "    bool __eq__(FIX::SessionID const &lhs, FIX::SessionID const &rhs)\n"
    "    bool __eq__(FIX::DatabaseConnectionID const &lhs, FIX::DatabaseConnectionID const &rhs)\n");
  
  return Qnil;
}


static swig_class SwigClassMySQLQuery;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLQuery_allocate(VALUE self)
#else
_wrap_MySQLQuery_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLQuery);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLQuery(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLQuery";
  FIX::MySQLQuery *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MySQLQuery", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLQuery", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLQuery *)new FIX::MySQLQuery((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLQuery(void *self) {
    FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MySQLQuery_execute(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  MYSQL *arg2 = (MYSQL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","execute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_MYSQL, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "MYSQL *","execute", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< MYSQL * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->execute(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLQuery_success(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","success", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->success();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLQuery_rows(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","rows", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->rows();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLQuery_reason(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","reason", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (std::string *) &(arg1)->reason();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLQuery_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getValue", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (char *)(arg1)->getValue(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLQuery_throwException(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLQuery *arg1 = (FIX::MySQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLQuery *","throwException", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->throwException();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassMySQLConnection;

SWIGINTERN VALUE
_wrap_new_MySQLConnection__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLConnection";
  FIX::MySQLConnection *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","MySQLConnection", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","MySQLConnection", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLConnection *)new FIX::MySQLConnection((FIX::DatabaseConnectionID const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLConnection_allocate(VALUE self)
#else
_wrap_MySQLConnection_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLConnection);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLConnection__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLConnection";
  FIX::MySQLConnection *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MySQLConnection", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLConnection", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","MySQLConnection", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLConnection", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLConnection", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLConnection", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLConnection", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLConnection", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","MySQLConnection", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLConnection *)new FIX::MySQLConnection((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MySQLConnection(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MySQLConnection__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_MySQLConnection__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "MySQLConnection.new", 
    "    MySQLConnection.new(FIX::DatabaseConnectionID const &id)\n"
    "    MySQLConnection.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLConnection(void *self) {
    FIX::MySQLConnection *arg1 = (FIX::MySQLConnection *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MySQLConnection_connectionID(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLConnection *arg1 = (FIX::MySQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::DatabaseConnectionID *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLConnection *","connectionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DatabaseConnectionID *) &(arg1)->connectionID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLConnection_connected(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLConnection *arg1 = (FIX::MySQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLConnection *","connected", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->connected();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLConnection_reconnect(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLConnection *arg1 = (FIX::MySQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLConnection *","reconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->reconnect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLConnection_execute(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLConnection *arg1 = (FIX::MySQLConnection *) 0 ;
  FIX::MySQLQuery *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLConnection *","execute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLConnection * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__MySQLQuery,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MySQLQuery &","execute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MySQLQuery &","execute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::MySQLQuery * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->execute(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassMySQLStoreFactory;

SWIGINTERN VALUE
_wrap_MySQLStoreFactory_DEFAULT_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLStoreFactory::DEFAULT_DATABASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_DEFAULT_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLStoreFactory::DEFAULT_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_DEFAULT_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLStoreFactory::DEFAULT_PASSWORD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_DEFAULT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLStoreFactory::DEFAULT_HOST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_DEFAULT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_short(static_cast< short >(FIX::MySQLStoreFactory::DEFAULT_PORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_new_MySQLStoreFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLStoreFactory";
  FIX::MySQLStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","MySQLStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","MySQLStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStoreFactory *)new FIX::MySQLStoreFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MySQLStoreFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLStoreFactory";
  FIX::MySQLStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const &","MySQLStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","MySQLStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStoreFactory *)new FIX::MySQLStoreFactory((FIX::Dictionary const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MySQLStoreFactory__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLStoreFactory";
  FIX::MySQLStoreFactory *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MySQLStoreFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStoreFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","MySQLStoreFactory", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStoreFactory", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLStoreFactory", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStoreFactory", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLStoreFactory", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStoreFactory", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","MySQLStoreFactory", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStoreFactory *)new FIX::MySQLStoreFactory((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLStoreFactory_allocate(VALUE self)
#else
_wrap_MySQLStoreFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLStoreFactory__SWIG_3(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::MySQLStoreFactory";
  FIX::MySQLStoreFactory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStoreFactory *)new FIX::MySQLStoreFactory();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MySQLStoreFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MySQLStoreFactory__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MySQLStoreFactory__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MySQLStoreFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_MySQLStoreFactory__SWIG_2(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "MySQLStoreFactory.new", 
    "    MySQLStoreFactory.new(FIX::SessionSettings const &settings)\n"
    "    MySQLStoreFactory.new(FIX::Dictionary const &dictionary)\n"
    "    MySQLStoreFactory.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    MySQLStoreFactory.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStoreFactory *arg1 = (FIX::MySQLStoreFactory *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStoreFactory *arg1 = (FIX::MySQLStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLStoreFactory(void *self) {
    FIX::MySQLStoreFactory *arg1 = (FIX::MySQLStoreFactory *)self;
    delete arg1;
}

static swig_class SwigClassMySQLStore;

SWIGINTERN VALUE
_wrap_new_MySQLStore__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::DatabaseConnectionID *arg3 = 0 ;
  FIX::MySQLConnectionPool *arg4 = (FIX::MySQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLStore";
  FIX::MySQLStore *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","MySQLStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","MySQLStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","MySQLStore", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","MySQLStore", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","MySQLStore", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","MySQLStore", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::MySQLConnectionPool *","MySQLStore", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< FIX::MySQLConnectionPool * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStore *)new FIX::MySQLStore((FIX::UtcTimeStamp const &)*arg1,(FIX::SessionID const &)*arg2,(FIX::DatabaseConnectionID const &)*arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLStore_allocate(VALUE self)
#else
_wrap_MySQLStore_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLStore__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  short arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int res6 = SWIG_OLDOBJ ;
  short val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLStore";
  FIX::MySQLStore *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","MySQLStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","MySQLStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","MySQLStore", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","MySQLStore", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLStore", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStore", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLStore", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStore", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","MySQLStore", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStore", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res6 = SWIG_AsPtr_std_string(argv[5], &ptr);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "std::string const &","MySQLStore", 6, argv[5] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLStore", 6, argv[5])); 
    }
    arg6 = ptr;
  }
  ecode7 = SWIG_AsVal_short(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "short","MySQLStore", 7, argv[6] ));
  } 
  arg7 = static_cast< short >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLStore *)new FIX::MySQLStore((FIX::UtcTimeStamp const &)*arg1,(FIX::SessionID const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[4], 0 );
      rb_str_append( argv[4], rb_str_new2(arg5->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[5], 0 );
      rb_str_append( argv[5], rb_str_new2(arg6->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return self;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MySQLStore(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs;
  if (argc > 7) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_MySQLStore__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              int res = SWIG_AsPtr_std_string(argv[5], (std::string**)(0));
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_short(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_MySQLStore__SWIG_1(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "MySQLStore.new", 
    "    MySQLStore.new(FIX::UtcTimeStamp const &now, FIX::SessionID const &sessionID, FIX::DatabaseConnectionID const &connection, FIX::MySQLConnectionPool *pool)\n"
    "    MySQLStore.new(FIX::UtcTimeStamp const &now, FIX::SessionID const &sessionID, std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLStore(void *self) {
    FIX::MySQLStore *arg1 = (FIX::MySQLStore *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MySQLStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::MySQLStore const *)arg1)->get(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MySQLStore const *)arg1)->getNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::MySQLStore const *)arg1)->getNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::MySQLStore const *)arg1)->getCreationTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLStore *arg1 = (FIX::MySQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassMySQLLog;

SWIGINTERN VALUE
_wrap_new_MySQLLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::DatabaseConnectionID *arg2 = 0 ;
  FIX::MySQLConnectionPool *arg3 = (FIX::MySQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLog";
  FIX::MySQLLog *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","MySQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","MySQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","MySQLLog", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","MySQLLog", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::MySQLConnectionPool *","MySQLLog", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< FIX::MySQLConnectionPool * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLog *)new FIX::MySQLLog((FIX::SessionID const &)*arg1,(FIX::DatabaseConnectionID const &)*arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MySQLLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  FIX::MySQLConnectionPool *arg2 = (FIX::MySQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLog";
  FIX::MySQLLog *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","MySQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","MySQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MySQLConnectionPool *","MySQLLog", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< FIX::MySQLConnectionPool * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLog *)new FIX::MySQLLog((FIX::DatabaseConnectionID const &)*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MySQLLog__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  short arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  short val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLog";
  FIX::MySQLLog *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","MySQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","MySQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  ecode6 = SWIG_AsVal_short(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "short","MySQLLog", 6, argv[5] ));
  } 
  arg6 = static_cast< short >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLog *)new FIX::MySQLLog((FIX::SessionID const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[4], 0 );
      rb_str_append( argv[4], rb_str_new2(arg5->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLLog_allocate(VALUE self)
#else
_wrap_MySQLLog_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLLog__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLog";
  FIX::MySQLLog *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLLog", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLog", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","MySQLLog", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLog *)new FIX::MySQLLog((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MySQLLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_MySQLLog__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_MySQLLog__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_MySQLLog__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_short(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_MySQLLog__SWIG_2(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "MySQLLog.new", 
    "    MySQLLog.new(FIX::SessionID const &sessionID, FIX::DatabaseConnectionID const &connectionID, FIX::MySQLConnectionPool *pool)\n"
    "    MySQLLog.new(FIX::DatabaseConnectionID const &connectionID, FIX::MySQLConnectionPool *pool)\n"
    "    MySQLLog.new(FIX::SessionID const &sessionID, std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    MySQLLog.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLLog(void *self) {
    FIX::MySQLLog *arg1 = (FIX::MySQLLog *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::MySQLLog.clear

  call-seq:
    clear

Clear MySQLLog contents.
*/
SWIGINTERN VALUE
_wrap_MySQLLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_backup(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_setIncomingTable(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","setIncomingTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setIncomingTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setIncomingTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setIncomingTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_setOutgoingTable(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","setOutgoingTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setOutgoingTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setOutgoingTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setOutgoingTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_setEventTable(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","setEventTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setEventTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setEventTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setEventTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLog *arg1 = (FIX::MySQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


static swig_class SwigClassMySQLLogFactory;

SWIGINTERN VALUE
_wrap_MySQLLogFactory_DEFAULT_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLLogFactory::DEFAULT_DATABASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_DEFAULT_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLLogFactory::DEFAULT_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_DEFAULT_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLLogFactory::DEFAULT_PASSWORD));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_DEFAULT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::MySQLLogFactory::DEFAULT_HOST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_DEFAULT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_short(static_cast< short >(FIX::MySQLLogFactory::DEFAULT_PORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_new_MySQLLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLogFactory";
  FIX::MySQLLogFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","MySQLLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","MySQLLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLogFactory *)new FIX::MySQLLogFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MySQLLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MySQLLogFactory";
  FIX::MySQLLogFactory *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","MySQLLogFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLogFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","MySQLLogFactory", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLogFactory", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","MySQLLogFactory", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLogFactory", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","MySQLLogFactory", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","MySQLLogFactory", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","MySQLLogFactory", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLogFactory *)new FIX::MySQLLogFactory((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_MySQLLogFactory_allocate(VALUE self)
#else
_wrap_MySQLLogFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MySQLLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_MySQLLogFactory__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::MySQLLogFactory";
  FIX::MySQLLogFactory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MySQLLogFactory *)new FIX::MySQLLogFactory();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MySQLLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MySQLLogFactory__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MySQLLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_MySQLLogFactory__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "MySQLLogFactory.new", 
    "    MySQLLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    MySQLLogFactory.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    MySQLLogFactory.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLogFactory *arg1 = (FIX::MySQLLogFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLogFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLogFactory *arg1 = (FIX::MySQLLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_MySQLLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__MySQLLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_MySQLLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__MySQLLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_MySQLLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "MySQLLogFactory.create", 
    "    FIX::Log MySQLLogFactory.create()\n"
    "    FIX::Log * MySQLLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MySQLLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MySQLLogFactory *arg1 = (FIX::MySQLLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MySQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MySQLLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MySQLLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MySQLLogFactory(void *self) {
    FIX::MySQLLogFactory *arg1 = (FIX::MySQLLogFactory *)self;
    delete arg1;
}

static swig_class SwigClassPostgreSQLQuery;

SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLQuery_allocate(VALUE self)
#else
_wrap_PostgreSQLQuery_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLQuery);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLQuery(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLQuery";
  FIX::PostgreSQLQuery *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLQuery", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLQuery", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLQuery *)new FIX::PostgreSQLQuery((std::string const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLQuery(void *self) {
    FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PostgreSQLQuery_execute(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  PGconn *arg2 = (PGconn *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","execute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_PGconn, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "PGconn *","execute", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< PGconn * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->execute(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLQuery_success(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","success", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->success();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLQuery_rows(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","rows", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)(arg1)->rows();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLQuery_reason(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","reason", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (char *)(arg1)->reason();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLQuery_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getValue", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (char *)(arg1)->getValue(arg2,arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLQuery_throwException(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLQuery *arg1 = (FIX::PostgreSQLQuery *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLQuery, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery *","throwException", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->throwException();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassPostgreSQLConnection;

SWIGINTERN VALUE
_wrap_new_PostgreSQLConnection__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLConnection";
  FIX::PostgreSQLConnection *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","PostgreSQLConnection", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","PostgreSQLConnection", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLConnection *)new FIX::PostgreSQLConnection((FIX::DatabaseConnectionID const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLConnection_allocate(VALUE self)
#else
_wrap_PostgreSQLConnection_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLConnection);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLConnection__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLConnection";
  FIX::PostgreSQLConnection *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLConnection", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLConnection", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLConnection", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLConnection", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLConnection", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLConnection", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLConnection", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLConnection", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","PostgreSQLConnection", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLConnection *)new FIX::PostgreSQLConnection((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PostgreSQLConnection(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PostgreSQLConnection__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_PostgreSQLConnection__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "PostgreSQLConnection.new", 
    "    PostgreSQLConnection.new(FIX::DatabaseConnectionID const &id)\n"
    "    PostgreSQLConnection.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLConnection(void *self) {
    FIX::PostgreSQLConnection *arg1 = (FIX::PostgreSQLConnection *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PostgreSQLConnection_connectionID(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLConnection *arg1 = (FIX::PostgreSQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::DatabaseConnectionID *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnection *","connectionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::DatabaseConnectionID *) &(arg1)->connectionID();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__DatabaseConnectionID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLConnection_connected(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLConnection *arg1 = (FIX::PostgreSQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnection *","connected", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->connected();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLConnection_reconnect(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLConnection *arg1 = (FIX::PostgreSQLConnection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnection *","reconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLConnection * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->reconnect();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLConnection_execute(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLConnection *arg1 = (FIX::PostgreSQLConnection *) 0 ;
  FIX::PostgreSQLQuery *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLConnection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnection *","execute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLConnection * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__PostgreSQLQuery,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::PostgreSQLQuery &","execute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::PostgreSQLQuery &","execute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::PostgreSQLQuery * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->execute(*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


static swig_class SwigClassPostgreSQLStoreFactory;

SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_DEFAULT_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLStoreFactory::DEFAULT_DATABASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_DEFAULT_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLStoreFactory::DEFAULT_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_DEFAULT_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLStoreFactory::DEFAULT_PASSWORD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_DEFAULT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLStoreFactory::DEFAULT_HOST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_DEFAULT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_short(static_cast< short >(FIX::PostgreSQLStoreFactory::DEFAULT_PORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLStoreFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStoreFactory";
  FIX::PostgreSQLStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","PostgreSQLStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","PostgreSQLStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStoreFactory *)new FIX::PostgreSQLStoreFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLStoreFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStoreFactory";
  FIX::PostgreSQLStoreFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const &","PostgreSQLStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","PostgreSQLStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStoreFactory *)new FIX::PostgreSQLStoreFactory((FIX::Dictionary const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLStoreFactory__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStoreFactory";
  FIX::PostgreSQLStoreFactory *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStoreFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStoreFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStoreFactory", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStoreFactory", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStoreFactory", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStoreFactory", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStoreFactory", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStoreFactory", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","PostgreSQLStoreFactory", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStoreFactory *)new FIX::PostgreSQLStoreFactory((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLStoreFactory_allocate(VALUE self)
#else
_wrap_PostgreSQLStoreFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLStoreFactory__SWIG_3(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStoreFactory";
  FIX::PostgreSQLStoreFactory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStoreFactory *)new FIX::PostgreSQLStoreFactory();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PostgreSQLStoreFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_PostgreSQLStoreFactory__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PostgreSQLStoreFactory__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PostgreSQLStoreFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_PostgreSQLStoreFactory__SWIG_2(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "PostgreSQLStoreFactory.new", 
    "    PostgreSQLStoreFactory.new(FIX::SessionSettings const &settings)\n"
    "    PostgreSQLStoreFactory.new(FIX::Dictionary const &dictionary)\n"
    "    PostgreSQLStoreFactory.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    PostgreSQLStoreFactory.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStoreFactory *arg1 = (FIX::PostgreSQLStoreFactory *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FIX::MessageStore *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::MessageStore *)(arg1)->create((FIX::UtcTimeStamp const &)*arg2,(FIX::SessionID const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStoreFactory *arg1 = (FIX::PostgreSQLStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLStoreFactory(void *self) {
    FIX::PostgreSQLStoreFactory *arg1 = (FIX::PostgreSQLStoreFactory *)self;
    delete arg1;
}

static swig_class SwigClassPostgreSQLStore;

SWIGINTERN VALUE
_wrap_new_PostgreSQLStore__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::DatabaseConnectionID *arg3 = 0 ;
  FIX::PostgreSQLConnectionPool *arg4 = (FIX::PostgreSQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStore";
  FIX::PostgreSQLStore *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","PostgreSQLStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","PostgreSQLStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","PostgreSQLStore", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","PostgreSQLStore", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","PostgreSQLStore", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","PostgreSQLStore", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnectionPool *","PostgreSQLStore", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< FIX::PostgreSQLConnectionPool * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStore *)new FIX::PostgreSQLStore((FIX::UtcTimeStamp const &)*arg1,(FIX::SessionID const &)*arg2,(FIX::DatabaseConnectionID const &)*arg3,arg4);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLStore_allocate(VALUE self)
#else
_wrap_PostgreSQLStore_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLStore__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStamp *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  short arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int res6 = SWIG_OLDOBJ ;
  short val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLStore";
  FIX::PostgreSQLStore *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","PostgreSQLStore", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","PostgreSQLStore", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStamp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","PostgreSQLStore", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","PostgreSQLStore", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStore", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStore", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStore", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStore", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStore", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStore", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res6 = SWIG_AsPtr_std_string(argv[5], &ptr);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLStore", 6, argv[5] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLStore", 6, argv[5])); 
    }
    arg6 = ptr;
  }
  ecode7 = SWIG_AsVal_short(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "short","PostgreSQLStore", 7, argv[6] ));
  } 
  arg7 = static_cast< short >(val7);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLStore *)new FIX::PostgreSQLStore((FIX::UtcTimeStamp const &)*arg1,(FIX::SessionID const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,arg7);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[4], 0 );
      rb_str_append( argv[4], rb_str_new2(arg5->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[5], 0 );
      rb_str_append( argv[5], rb_str_new2(arg6->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return self;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PostgreSQLStore(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs;
  if (argc > 7) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 4) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_PostgreSQLStore__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              int res = SWIG_AsPtr_std_string(argv[5], (std::string**)(0));
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_short(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_PostgreSQLStore__SWIG_1(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "PostgreSQLStore.new", 
    "    PostgreSQLStore.new(FIX::UtcTimeStamp const &now, FIX::SessionID const &sessionID, FIX::DatabaseConnectionID const &connection, FIX::PostgreSQLConnectionPool *pool)\n"
    "    PostgreSQLStore.new(FIX::UtcTimeStamp const &now, FIX::SessionID const &sessionID, std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLStore(void *self) {
    FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *)self;
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PostgreSQLStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  {
    if(tryRubyException([&]() mutable 
        {
      ((FIX::PostgreSQLStore const *)arg1)->get(arg2,arg3,*arg4);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::PostgreSQLStore const *)arg1)->getNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (int)((FIX::PostgreSQLStore const *)arg1)->getNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextSenderMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setNextTargetMsgSeqNum(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextSenderMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->incrNextTargetMsgSeqNum();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::UtcTimeStamp result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = ((FIX::PostgreSQLStore const *)arg1)->getCreationTime();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj((new FIX::UtcTimeStamp(result)), SWIGTYPE_p_FIX__UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  FIX::UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStamp const &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStamp const &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStamp * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->reset((FIX::UtcTimeStamp const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLStore *arg1 = (FIX::PostgreSQLStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLStore * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->refresh();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


static swig_class SwigClassPostgreSQLLog;

SWIGINTERN VALUE
_wrap_new_PostgreSQLLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::DatabaseConnectionID *arg2 = 0 ;
  FIX::PostgreSQLConnectionPool *arg3 = (FIX::PostgreSQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLog";
  FIX::PostgreSQLLog *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","PostgreSQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","PostgreSQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","PostgreSQLLog", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","PostgreSQLLog", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnectionPool *","PostgreSQLLog", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< FIX::PostgreSQLConnectionPool * >(argp3);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLog *)new FIX::PostgreSQLLog((FIX::SessionID const &)*arg1,(FIX::DatabaseConnectionID const &)*arg2,arg3);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DatabaseConnectionID *arg1 = 0 ;
  FIX::PostgreSQLConnectionPool *arg2 = (FIX::PostgreSQLConnectionPool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLog";
  FIX::PostgreSQLLog *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DatabaseConnectionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DatabaseConnectionID const &","PostgreSQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DatabaseConnectionID const &","PostgreSQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DatabaseConnectionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::PostgreSQLConnectionPool *","PostgreSQLLog", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< FIX::PostgreSQLConnectionPool * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLog *)new FIX::PostgreSQLLog((FIX::DatabaseConnectionID const &)*arg1,arg2);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLog__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  short arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  short val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLog";
  FIX::PostgreSQLLog *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","PostgreSQLLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","PostgreSQLLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  ecode6 = SWIG_AsVal_short(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "short","PostgreSQLLog", 6, argv[5] ));
  } 
  arg6 = static_cast< short >(val6);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLog *)new FIX::PostgreSQLLog((FIX::SessionID const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[4], 0 );
      rb_str_append( argv[4], rb_str_new2(arg5->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLLog_allocate(VALUE self)
#else
_wrap_PostgreSQLLog_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLog__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLog";
  FIX::PostgreSQLLog *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLog", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLog", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","PostgreSQLLog", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLog *)new FIX::PostgreSQLLog((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PostgreSQLLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_PostgreSQLLog__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_PostgreSQLLog__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_PostgreSQLLog__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_short(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_PostgreSQLLog__SWIG_2(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "PostgreSQLLog.new", 
    "    PostgreSQLLog.new(FIX::SessionID const &s, FIX::DatabaseConnectionID const &d, FIX::PostgreSQLConnectionPool *p)\n"
    "    PostgreSQLLog.new(FIX::DatabaseConnectionID const &d, FIX::PostgreSQLConnectionPool *p)\n"
    "    PostgreSQLLog.new(FIX::SessionID const &s, std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    PostgreSQLLog.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLLog(void *self) {
    FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *)self;
    delete arg1;
}

/*
  Document-method: Quickfix::PostgreSQLLog.clear

  call-seq:
    clear

Clear PostgreSQLLog contents.
*/
SWIGINTERN VALUE
_wrap_PostgreSQLLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->clear();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_backup(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","backup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->backup();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_setIncomingTable(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","setIncomingTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setIncomingTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setIncomingTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setIncomingTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_setOutgoingTable(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","setOutgoingTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setOutgoingTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setOutgoingTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setOutgoingTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_setEventTable(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","setEventTable", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setEventTable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setEventTable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->setEventTable((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onIncoming((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onOutgoing((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLog *arg1 = (FIX::PostgreSQLLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->onEvent((std::string const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


static swig_class SwigClassPostgreSQLLogFactory;

SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_DEFAULT_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLLogFactory::DEFAULT_DATABASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_DEFAULT_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLLogFactory::DEFAULT_USER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_DEFAULT_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLLogFactory::DEFAULT_PASSWORD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_DEFAULT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_std_string(static_cast< std::string >(FIX::PostgreSQLLogFactory::DEFAULT_HOST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_DEFAULT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_short(static_cast< short >(FIX::PostgreSQLLogFactory::DEFAULT_PORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLogFactory";
  FIX::PostgreSQLLogFactory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","PostgreSQLLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","PostgreSQLLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLogFactory *)new FIX::PostgreSQLLogFactory((FIX::SessionSettings const &)*arg1);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  short arg5 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  short val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLogFactory";
  FIX::PostgreSQLLogFactory *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLogFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLogFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLogFactory", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLogFactory", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLogFactory", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLogFactory", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","PostgreSQLLogFactory", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","PostgreSQLLogFactory", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_short(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "short","PostgreSQLLogFactory", 5, argv[4] ));
  } 
  arg5 = static_cast< short >(val5);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLogFactory *)new FIX::PostgreSQLLogFactory((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" ) 	 
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
_wrap_PostgreSQLLogFactory_allocate(VALUE self)
#else
_wrap_PostgreSQLLogFactory_allocate(int argc, VALUE *argv, VALUE self)
#endif
{
  VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PostgreSQLLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
  rb_obj_call_init(vresult, argc, argv);
#endif
  return vresult;
}


SWIGINTERN VALUE
_wrap_new_PostgreSQLLogFactory__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Quickfix::PostgreSQLLogFactory";
  FIX::PostgreSQLLogFactory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::PostgreSQLLogFactory *)new FIX::PostgreSQLLogFactory();
          DATA_PTR(self) = result;
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PostgreSQLLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_PostgreSQLLogFactory__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PostgreSQLLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 5) {
    int _v = 0;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_short(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_PostgreSQLLogFactory__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "PostgreSQLLogFactory.new", 
    "    PostgreSQLLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    PostgreSQLLogFactory.new(std::string const &database, std::string const &user, std::string const &password, std::string const &host, short port)\n"
    "    PostgreSQLLogFactory.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLogFactory *arg1 = (FIX::PostgreSQLLogFactory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLogFactory * >(argp1);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create();
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLogFactory *arg1 = (FIX::PostgreSQLLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FIX::Log *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_PostgreSQLLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__PostgreSQLLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_PostgreSQLLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v = 0;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__PostgreSQLLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_PostgreSQLLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "PostgreSQLLogFactory.create", 
    "    FIX::Log PostgreSQLLogFactory.create()\n"
    "    FIX::Log * PostgreSQLLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PostgreSQLLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::PostgreSQLLogFactory *arg1 = (FIX::PostgreSQLLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__PostgreSQLLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::PostgreSQLLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::PostgreSQLLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  {
    if(tryRubyException([&]() mutable 
        {
      (arg1)->destroy(arg2);
          return self;
        fail:
          return Qnil;
        }) == Qnil) 
    {
      SWIG_fail;
    }
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_PostgreSQLLogFactory(void *self) {
    FIX::PostgreSQLLogFactory *arg1 = (FIX::PostgreSQLLogFactory *)self;
    delete arg1;
}


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_IntArrayTo_p_int(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((int *)  ((IntArray *) x));
}
static void *_p_FIX__SSLSocketAcceptorTo_p_FIX__Acceptor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Acceptor *)  ((FIX::SSLSocketAcceptor *) x));
}
static void *_p_FIX__SocketAcceptorTo_p_FIX__Acceptor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Acceptor *)  ((FIX::SocketAcceptor *) x));
}
static void *_p_FIX__NullApplicationTo_p_FIX__Application(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Application *)  ((FIX::NullApplication *) x));
}
static void *_p_FIX__SynchronizedApplicationTo_p_FIX__Application(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Application *)  ((FIX::SynchronizedApplication *) x));
}
static void *_p_FIX__LocalDateTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::LocalDate *) x));
}
static void *_p_FIX__LocalTimeOnlyTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::LocalTimeOnly *) x));
}
static void *_p_FIX__LocalTimeStampTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::LocalTimeStamp *) x));
}
static void *_p_FIX__UtcDateTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::UtcDate *) x));
}
static void *_p_FIX__UtcTimeOnlyTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::UtcTimeOnly *) x));
}
static void *_p_FIX__UtcTimeStampTo_p_FIX__DateTime(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::DateTime *)  ((FIX::UtcTimeStamp *) x));
}
static void *_p_FIX__ConfigErrorTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::ConfigError *) x));
}
static void *_p_FIX__DataDictionaryNotFoundTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::DataDictionaryNotFound *) x));
}
static void *_p_FIX__DoNotSendTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::DoNotSend *) x));
}
static void *_p_FIX__DuplicateFieldNumberTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::DuplicateFieldNumber *) x));
}
static void *_p_FIX__FieldConvertErrorTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::FieldConvertError *) x));
}
static void *_p_FIX__FieldNotFoundTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::FieldNotFound *) x));
}
static void *_p_FIX__IOExceptionTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::IOException *) x));
}
static void *_p_FIX__IncorrectDataFormatTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectDataFormat *) x));
}
static void *_p_FIX__IncorrectMessageStructureTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectMessageStructure *) x));
}
static void *_p_FIX__IncorrectTagValueTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectTagValue *) x));
}
static void *_p_FIX__InvalidMessageTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidMessage *) x));
}
static void *_p_FIX__InvalidMessageTypeTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidMessageType *) x));
}
static void *_p_FIX__InvalidTagNumberTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidTagNumber *) x));
}
static void *_p_FIX__MessageParseErrorTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::MessageParseError *) x));
}
static void *_p_FIX__NoTagValueTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::NoTagValue *) x));
}
static void *_p_FIX__RejectLogonTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::RejectLogon *) x));
}
static void *_p_FIX__RepeatedTagTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::RepeatedTag *) x));
}
static void *_p_FIX__RepeatingGroupCountMismatchTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::RepeatingGroupCountMismatch *) x));
}
static void *_p_FIX__RequiredTagMissingTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::RequiredTagMissing *) x));
}
static void *_p_FIX__RuntimeErrorTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::RuntimeError *) x));
}
static void *_p_FIX__SessionNotFoundTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::SessionNotFound *) x));
}
static void *_p_FIX__SocketCloseFailedTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketCloseFailed *) x));
}
static void *_p_FIX__SocketExceptionTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::SocketException *) x));
}
static void *_p_FIX__SocketRecvFailedTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketRecvFailed *) x));
}
static void *_p_FIX__SocketSendFailedTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketSendFailed *) x));
}
static void *_p_FIX__TagNotDefinedForMessageTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::TagNotDefinedForMessage *) x));
}
static void *_p_FIX__TagOutOfOrderTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::TagOutOfOrder *) x));
}
static void *_p_FIX__UnsupportedMessageTypeTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::UnsupportedMessageType *) x));
}
static void *_p_FIX__UnsupportedVersionTo_p_FIX__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Exception *)  ((FIX::UnsupportedVersion *) x));
}
static void *_p_FIX__BeginStringTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::BeginString *) x));
}
static void *_p_FIX__BoolFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::BoolField *) x));
}
static void *_p_FIX__CharFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::CharField *) x));
}
static void *_p_FIX__CheckSumFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::CheckSumField *) x));
}
static void *_p_FIX__DoubleFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::DoubleField *) x));
}
static void *_p_FIX__IntFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::IntField *) x));
}
static void *_p_FIX__SenderCompIDTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SenderCompID *) x));
}
static void *_p_FIX__StringFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::StringField *) x));
}
static void *_p_FIX__TargetCompIDTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::TargetCompID *) x));
}
static void *_p_FIX__UtcDateFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcDateField *) x));
}
static void *_p_FIX__UtcTimeOnlyFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcTimeOnlyField *) x));
}
static void *_p_FIX__UtcTimeStampFieldTo_p_FIX__FieldBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcTimeStampField *) x));
}
static void *_p_FIX__GroupTo_p_FIX__FieldMap(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldMap *)  ((FIX::Group *) x));
}
static void *_p_FIX__HeaderTo_p_FIX__FieldMap(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldMap *)  ((FIX::Header *) x));
}
static void *_p_FIX__MessageTo_p_FIX__FieldMap(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldMap *)  ((FIX::Message *) x));
}
static void *_p_FIX__TrailerTo_p_FIX__FieldMap(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::FieldMap *)  ((FIX::Trailer *) x));
}
static void *_p_FIX__SSLSocketInitiatorTo_p_FIX__Initiator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Initiator *)  ((FIX::SSLSocketInitiator *) x));
}
static void *_p_FIX__SocketInitiatorTo_p_FIX__Initiator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Initiator *)  ((FIX::SocketInitiator *) x));
}
static void *_p_FIX__FileLogTo_p_FIX__Log(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Log *)  ((FIX::FileLog *) x));
}
static void *_p_FIX__MySQLLogTo_p_FIX__Log(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Log *)  ((FIX::MySQLLog *) x));
}
static void *_p_FIX__NullLogTo_p_FIX__Log(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Log *)  ((FIX::NullLog *) x));
}
static void *_p_FIX__PostgreSQLLogTo_p_FIX__Log(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Log *)  ((FIX::PostgreSQLLog *) x));
}
static void *_p_FIX__ScreenLogTo_p_FIX__Log(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::Log *)  ((FIX::ScreenLog *) x));
}
static void *_p_FIX__FileLogFactoryTo_p_FIX__LogFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::LogFactory *)  ((FIX::FileLogFactory *) x));
}
static void *_p_FIX__MySQLLogFactoryTo_p_FIX__LogFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::LogFactory *)  ((FIX::MySQLLogFactory *) x));
}
static void *_p_FIX__PostgreSQLLogFactoryTo_p_FIX__LogFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::LogFactory *)  ((FIX::PostgreSQLLogFactory *) x));
}
static void *_p_FIX__ScreenLogFactoryTo_p_FIX__LogFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::LogFactory *)  ((FIX::ScreenLogFactory *) x));
}
static void *_p_FIX__FileStoreTo_p_FIX__MessageStore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStore *)  ((FIX::FileStore *) x));
}
static void *_p_FIX__MemoryStoreTo_p_FIX__MessageStore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStore *)  ((FIX::MemoryStore *) x));
}
static void *_p_FIX__MySQLStoreTo_p_FIX__MessageStore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStore *)  ((FIX::MySQLStore *) x));
}
static void *_p_FIX__PostgreSQLStoreTo_p_FIX__MessageStore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStore *)  ((FIX::PostgreSQLStore *) x));
}
static void *_p_FIX__FileStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::FileStoreFactory *) x));
}
static void *_p_FIX__MemoryStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::MemoryStoreFactory *) x));
}
static void *_p_FIX__MySQLStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::MySQLStoreFactory *) x));
}
static void *_p_FIX__PostgreSQLStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::PostgreSQLStoreFactory *) x));
}
static void *_p_FIX__SocketCloseFailedTo_p_FIX__SocketException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketCloseFailed *) x));
}
static void *_p_FIX__SocketRecvFailedTo_p_FIX__SocketException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketRecvFailed *) x));
}
static void *_p_FIX__SocketSendFailedTo_p_FIX__SocketException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketSendFailed *) x));
}
static void *_p_FIX__BeginStringTo_p_FIX__StringField(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::StringField *)  ((FIX::BeginString *) x));
}
static void *_p_FIX__SenderCompIDTo_p_FIX__StringField(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::StringField *)  ((FIX::SenderCompID *) x));
}
static void *_p_FIX__TargetCompIDTo_p_FIX__StringField(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((FIX::StringField *)  ((FIX::TargetCompID *) x));
}
static void *_p_FIX__ConfigErrorTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::ConfigError *) x));
}
static void *_p_FIX__DataDictionaryNotFoundTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::DataDictionaryNotFound *) x));
}
static void *_p_FIX__DoNotSendTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::DoNotSend *) x));
}
static void *_p_FIX__DuplicateFieldNumberTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::DuplicateFieldNumber *) x));
}
static void *_p_FIX__ExceptionTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *)  ((FIX::Exception *) x));
}
static void *_p_FIX__FieldConvertErrorTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::FieldConvertError *) x));
}
static void *_p_FIX__FieldNotFoundTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::FieldNotFound *) x));
}
static void *_p_FIX__IOExceptionTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::IOException *) x));
}
static void *_p_FIX__IncorrectDataFormatTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::IncorrectDataFormat *) x));
}
static void *_p_FIX__IncorrectMessageStructureTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::IncorrectMessageStructure *) x));
}
static void *_p_FIX__IncorrectTagValueTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::IncorrectTagValue *) x));
}
static void *_p_FIX__InvalidMessageTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::InvalidMessage *) x));
}
static void *_p_FIX__InvalidMessageTypeTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::InvalidMessageType *) x));
}
static void *_p_FIX__InvalidTagNumberTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::InvalidTagNumber *) x));
}
static void *_p_FIX__MessageParseErrorTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::MessageParseError *) x));
}
static void *_p_FIX__NoTagValueTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::NoTagValue *) x));
}
static void *_p_FIX__RejectLogonTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::RejectLogon *) x));
}
static void *_p_FIX__RepeatedTagTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::RepeatedTag *) x));
}
static void *_p_FIX__RepeatingGroupCountMismatchTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::RepeatingGroupCountMismatch *) x));
}
static void *_p_FIX__RequiredTagMissingTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::RequiredTagMissing *) x));
}
static void *_p_FIX__RuntimeErrorTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::RuntimeError *) x));
}
static void *_p_FIX__SessionNotFoundTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::SessionNotFound *) x));
}
static void *_p_FIX__SocketCloseFailedTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *)(FIX::SocketException *) ((FIX::SocketCloseFailed *) x));
}
static void *_p_FIX__SocketExceptionTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::SocketException *) x));
}
static void *_p_FIX__SocketRecvFailedTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *)(FIX::SocketException *) ((FIX::SocketRecvFailed *) x));
}
static void *_p_FIX__SocketSendFailedTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *)(FIX::SocketException *) ((FIX::SocketSendFailed *) x));
}
static void *_p_FIX__TagNotDefinedForMessageTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::TagNotDefinedForMessage *) x));
}
static void *_p_FIX__TagOutOfOrderTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::TagOutOfOrder *) x));
}
static void *_p_FIX__UnsupportedMessageTypeTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::UnsupportedMessageType *) x));
}
static void *_p_FIX__UnsupportedVersionTo_p_std__logic_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::logic_error *) (FIX::Exception *) ((FIX::UnsupportedVersion *) x));
}
static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
}
static swig_type_info _swigt__p_ApplVerID = {"_p_ApplVerID", "ApplVerID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Application = {"_p_Application", "Application *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BeginString = {"_p_BeginString", "BeginString *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DOMDocumentPtr = {"_p_DOMDocumentPtr", "DOMDocumentPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Data = {"_p_Data", "Data *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DataDictionary = {"_p_DataDictionary", "DataDictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DataDictionaryProvider = {"_p_DataDictionaryProvider", "DataDictionaryProvider *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Dictionaries = {"_p_Dictionaries", "Dictionaries *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DoubleField = {"_p_DoubleField", "AmtField *|FloatField *|PercentageField *|PriceField *|PriceOffsetField *|QtyField *|DoubleField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Acceptor = {"_p_FIX__Acceptor", "FIX::Acceptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Application = {"_p_FIX__Application", "FIX::Application *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__BeginString = {"_p_FIX__BeginString", "FIX::BeginString *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__BoolField = {"_p_FIX__BoolField", "FIX::BoolField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CharField = {"_p_FIX__CharField", "FIX::CharField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CheckSumField = {"_p_FIX__CheckSumField", "FIX::CheckSumField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ConfigError = {"_p_FIX__ConfigError", "FIX::ConfigError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DataDictionary = {"_p_FIX__DataDictionary", "FIX::DataDictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DataDictionaryNotFound = {"_p_FIX__DataDictionaryNotFound", "FIX::DataDictionaryNotFound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DatabaseConnectionID = {"_p_FIX__DatabaseConnectionID", "FIX::DatabaseConnectionID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t = {"_p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t", "FIX::MySQLConnectionPool *|FIX::DatabaseConnectionPool< FIX::MySQLConnection > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t = {"_p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t", "FIX::PostgreSQLConnectionPool *|FIX::DatabaseConnectionPool< FIX::PostgreSQLConnection > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DateTime = {"_p_FIX__DateTime", "FIX::DateTime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Dictionary = {"_p_FIX__Dictionary", "FIX::Dictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DoNotSend = {"_p_FIX__DoNotSend", "FIX::DoNotSend *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DoubleField = {"_p_FIX__DoubleField", "FIX::AmtField *|FIX::FloatField *|FIX::PercentageField *|FIX::PriceField *|FIX::PriceOffsetField *|FIX::QtyField *|FIX::DoubleField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DuplicateFieldNumber = {"_p_FIX__DuplicateFieldNumber", "FIX::DuplicateFieldNumber *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Exception = {"_p_FIX__Exception", "FIX::Exception *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldBase = {"_p_FIX__FieldBase", "FIX::FieldBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldConvertError = {"_p_FIX__FieldConvertError", "FIX::FieldConvertError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldMap = {"_p_FIX__FieldMap", "FIX::FieldMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldNotFound = {"_p_FIX__FieldNotFound", "FIX::FieldNotFound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileLog = {"_p_FIX__FileLog", "FIX::FileLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileLogFactory = {"_p_FIX__FileLogFactory", "FIX::FileLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileStore = {"_p_FIX__FileStore", "FIX::FileStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileStoreFactory = {"_p_FIX__FileStoreFactory", "FIX::FileStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Group = {"_p_FIX__Group", "FIX::Group *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Header = {"_p_FIX__Header", "FIX::Header *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IOException = {"_p_FIX__IOException", "FIX::IOException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectDataFormat = {"_p_FIX__IncorrectDataFormat", "FIX::IncorrectDataFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectMessageStructure = {"_p_FIX__IncorrectMessageStructure", "FIX::IncorrectMessageStructure *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectTagValue = {"_p_FIX__IncorrectTagValue", "FIX::IncorrectTagValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Initiator = {"_p_FIX__Initiator", "FIX::Initiator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IntField = {"_p_FIX__IntField", "FIX::LengthField *|FIX::NumInGroupField *|FIX::SeqNumField *|FIX::TagNumField *|FIX::IntField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidMessage = {"_p_FIX__InvalidMessage", "FIX::InvalidMessage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidMessageType = {"_p_FIX__InvalidMessageType", "FIX::InvalidMessageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidTagNumber = {"_p_FIX__InvalidTagNumber", "FIX::InvalidTagNumber *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LocalDate = {"_p_FIX__LocalDate", "FIX::LocalDate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LocalTimeOnly = {"_p_FIX__LocalTimeOnly", "FIX::LocalTimeOnly *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LocalTimeStamp = {"_p_FIX__LocalTimeStamp", "FIX::LocalTimeStamp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Log = {"_p_FIX__Log", "FIX::Log *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LogFactory = {"_p_FIX__LogFactory", "FIX::LogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MemoryStore = {"_p_FIX__MemoryStore", "FIX::MemoryStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MemoryStoreFactory = {"_p_FIX__MemoryStoreFactory", "FIX::MemoryStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Message = {"_p_FIX__Message", "FIX::Message *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageParseError = {"_p_FIX__MessageParseError", "FIX::MessageParseError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStore = {"_p_FIX__MessageStore", "FIX::MessageStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreExceptionWrapper = {"_p_FIX__MessageStoreExceptionWrapper", "FIX::MessageStoreExceptionWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreFactory = {"_p_FIX__MessageStoreFactory", "FIX::MessageStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreFactoryExceptionWrapper = {"_p_FIX__MessageStoreFactoryExceptionWrapper", "FIX::MessageStoreFactoryExceptionWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLConnection = {"_p_FIX__MySQLConnection", "FIX::MySQLConnection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLLog = {"_p_FIX__MySQLLog", "FIX::MySQLLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLLogFactory = {"_p_FIX__MySQLLogFactory", "FIX::MySQLLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLQuery = {"_p_FIX__MySQLQuery", "FIX::MySQLQuery *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLStore = {"_p_FIX__MySQLStore", "FIX::MySQLStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MySQLStoreFactory = {"_p_FIX__MySQLStoreFactory", "FIX::MySQLStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__NoTagValue = {"_p_FIX__NoTagValue", "FIX::NoTagValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__NullApplication = {"_p_FIX__NullApplication", "FIX::NullApplication *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__NullLog = {"_p_FIX__NullLog", "FIX::NullLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLConnection = {"_p_FIX__PostgreSQLConnection", "FIX::PostgreSQLConnection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLLog = {"_p_FIX__PostgreSQLLog", "FIX::PostgreSQLLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLLogFactory = {"_p_FIX__PostgreSQLLogFactory", "FIX::PostgreSQLLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLQuery = {"_p_FIX__PostgreSQLQuery", "FIX::PostgreSQLQuery *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLStore = {"_p_FIX__PostgreSQLStore", "FIX::PostgreSQLStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PostgreSQLStoreFactory = {"_p_FIX__PostgreSQLStoreFactory", "FIX::PostgreSQLStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RejectLogon = {"_p_FIX__RejectLogon", "FIX::RejectLogon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RepeatedTag = {"_p_FIX__RepeatedTag", "FIX::RepeatedTag *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RepeatingGroupCountMismatch = {"_p_FIX__RepeatingGroupCountMismatch", "FIX::RepeatingGroupCountMismatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RequiredTagMissing = {"_p_FIX__RequiredTagMissing", "FIX::RequiredTagMissing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RuntimeError = {"_p_FIX__RuntimeError", "FIX::RuntimeError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SSLSocketAcceptor = {"_p_FIX__SSLSocketAcceptor", "FIX::SSLSocketAcceptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SSLSocketInitiator = {"_p_FIX__SSLSocketInitiator", "FIX::SSLSocketInitiator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ScreenLog = {"_p_FIX__ScreenLog", "FIX::ScreenLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ScreenLogFactory = {"_p_FIX__ScreenLogFactory", "FIX::ScreenLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SenderCompID = {"_p_FIX__SenderCompID", "FIX::SenderCompID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Session = {"_p_FIX__Session", "FIX::Session *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionID = {"_p_FIX__SessionID", "std::set< FIX::SessionID >::key_type *|std::set< FIX::SessionID >::value_type *|FIX::SessionID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionNotFound = {"_p_FIX__SessionNotFound", "FIX::SessionNotFound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionSettings = {"_p_FIX__SessionSettings", "FIX::SessionSettings *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketAcceptor = {"_p_FIX__SocketAcceptor", "FIX::SocketAcceptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketCloseFailed = {"_p_FIX__SocketCloseFailed", "FIX::SocketCloseFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketException = {"_p_FIX__SocketException", "FIX::SocketException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketInitiator = {"_p_FIX__SocketInitiator", "FIX::SocketInitiator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketRecvFailed = {"_p_FIX__SocketRecvFailed", "FIX::SocketRecvFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketSendFailed = {"_p_FIX__SocketSendFailed", "FIX::SocketSendFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__StringField = {"_p_FIX__StringField", "FIX::CountryField *|FIX::CurrencyField *|FIX::DataField *|FIX::DayOfMonthField *|FIX::ExchangeField *|FIX::LocalMktDateField *|FIX::MonthField *|FIX::MonthYearField *|FIX::MultipleCharValueField *|FIX::MultipleStringValueField *|FIX::MultipleValueStringField *|FIX::TzTimeOnlyField *|FIX::TzTimeStampField *|FIX::StringField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SynchronizedApplication = {"_p_FIX__SynchronizedApplication", "FIX::SynchronizedApplication *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TYPE__Type = {"_p_FIX__TYPE__Type", "FIX::TYPE::Type *|enum FIX::TYPE::Type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TagNotDefinedForMessage = {"_p_FIX__TagNotDefinedForMessage", "FIX::TagNotDefinedForMessage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TagOutOfOrder = {"_p_FIX__TagOutOfOrder", "FIX::TagOutOfOrder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TargetCompID = {"_p_FIX__TargetCompID", "FIX::TargetCompID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Trailer = {"_p_FIX__Trailer", "FIX::Trailer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnsupportedMessageType = {"_p_FIX__UnsupportedMessageType", "FIX::UnsupportedMessageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnsupportedVersion = {"_p_FIX__UnsupportedVersion", "FIX::UnsupportedVersion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcDate = {"_p_FIX__UtcDate", "FIX::UTCDATE *|FIX::UTCDATEONLY *|FIX::UtcDateOnly *|FIX::UtcDate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcDateField = {"_p_FIX__UtcDateField", "FIX::UtcDateOnlyField *|FIX::UtcDateField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeOnly = {"_p_FIX__UtcTimeOnly", "FIX::UTCTIMEONLY *|FIX::UtcTimeOnly *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeOnlyField = {"_p_FIX__UtcTimeOnlyField", "FIX::UtcTimeOnlyField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeStamp = {"_p_FIX__UtcTimeStamp", "FIX::UTCTIMESTAMP *|FIX::UtcTimeStamp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeStampField = {"_p_FIX__UtcTimeStampField", "FIX::UtcTimeStampField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Fields = {"_p_Fields", "Fields *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Group = {"_p_Group", "Group *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Groups = {"_p_Groups", "Groups *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntArray = {"_p_IntArray", "IntArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntField = {"_p_IntField", "LengthField *|NumInGroupField *|SeqNumField *|TagNumField *|IntField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Log = {"_p_Log", "Log *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LogFactory = {"_p_LogFactory", "LogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MYSQL = {"_p_MYSQL", "MYSQL *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MessageStore = {"_p_MessageStore", "MessageStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MessageStoreFactory = {"_p_MessageStoreFactory", "MessageStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MsgType = {"_p_MsgType", "MsgType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Mutex = {"_p_Mutex", "Mutex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PGconn = {"_p_PGconn", "PGconn *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RSA = {"_p_RSA", "RSA *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Responder = {"_p_Responder", "Responder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SessionID = {"_p_SessionID", "SessionID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SessionToPort = {"_p_SessionToPort", "SessionToPort *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StringField = {"_p_StringField", "CountryField *|CurrencyField *|DataField *|DayOfMonthField *|ExchangeField *|LanguageField *|LocalMktDateField *|LocalMktTimeField *|MonthField *|MonthYearField *|MultipleCharValueField *|MultipleStringValueField *|MultipleValueStringField *|QidField *|QidRefField *|TzTimeOnlyField *|TzTimeStampField *|StringField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimeRange = {"_p_TimeRange", "TimeRange *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcDateField = {"_p_UtcDateField", "UtcDateOnlyField *|UtcDateField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_X509 = {"_p_X509", "X509 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bool = {"_p_bool", "FIX::BOOLEAN *|bool *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "FIX::CHAR *|char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "FIX::AMT *|FIX::FLOAT *|FIX::PERCENTAGE *|FIX::PRICE *|FIX::PRICEOFFSET *|FIX::QTY *|double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_g_const_iterator = {"_p_g_const_iterator", "g_const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_g_iterator = {"_p_g_iterator", "g_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_g_value_type = {"_p_g_value_type", "g_value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "FIX::INT *|FIX::LENGTH *|FIX::NUMINGROUP *|FIX::SEQNUM *|FIX::TAGNUM *|int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int64_t = {"_p_int64_t", "int64_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_key_type = {"_p_key_type", "key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_message_order = {"_p_message_order", "message_order *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_FIX__DataDictionary = {"_p_p_FIX__DataDictionary", "FIX::DataDictionary **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ssize_t = {"_p_ssize_t", "ssize_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_FIX__UtcTimeStamp_fF_t = {"_p_std__functionT_FIX__UtcTimeStamp_fF_t", "std::function< FIX::UtcTimeStamp () > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__lessT_FIX__SessionID_t = {"_p_std__lessT_FIX__SessionID_t", "std::less< FIX::SessionID > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__logic_error = {"_p_std__logic_error", "std::logic_error *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_FIX__SessionID_uint16_t_t = {"_p_std__mapT_FIX__SessionID_uint16_t_t", "FIX::SocketAcceptor::SessionToPort *|std::map< FIX::SessionID,uint16_t > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t = {"_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t", "FIX::FieldMap::Groups *|std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator = {"_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator", "FIX::FieldMap::g_const_iterator *|std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator = {"_p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator", "FIX::FieldMap::g_iterator *|std::map< int,std::vector< FIX::FieldMap * >,std::less< int >,ALLOCATOR< std::pair< int const,std::vector< FIX::FieldMap * > > > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_std__string_t__const_iterator = {"_p_std__mapT_std__string_std__string_t__const_iterator", "FIX::Dictionary::iterator *|std::map< std::string,std::string >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t = {"_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t", "std::set< FIX::SessionID,std::less< FIX::SessionID >,std::allocator< FIX::SessionID > > *|std::set< FIX::SessionID > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "FIX::COUNTRY *|FIX::CURRENCY *|FIX::DATA *|FIX::DAYOFMONTH *|FIX::EXCHANGE *|FIX::LANGUAGE *|FIX::LOCALMKTDATE *|FIX::LOCALMKTTIME *|FIX::MONTHYEAR *|FIX::MULTIPLECHARVALUE *|FIX::MULTIPLESTRINGVALUE *|FIX::MULTIPLEVALUESTRING *|FIX::STRING *|FIX::TZTIMEONLY *|FIX::TZTIMESTAMP *|FIX::XID *|FIX::XIDREF *|FIX::XMLDATA *|std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string__size_type = {"_p_std__string__size_type", "std::string::size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t = {"_p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t", "FIX::MySQLConnectionPoolPtr *|std::unique_ptr< FIX::DatabaseConnectionPool< FIX::MySQLConnection > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t = {"_p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t", "FIX::PostgreSQLConnectionPoolPtr *|std::unique_ptr< FIX::DatabaseConnectionPool< FIX::PostgreSQLConnection > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator = {"_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator", "FIX::FieldMap::const_iterator *|std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator = {"_p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator", "FIX::FieldMap::iterator *|std::vector< FIX::FieldBase,ALLOCATOR< FIX::FieldBase > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_t = {"_p_std__vectorT_std__string_t", "std::vector< std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__ConstIterator = {"_p_swig__ConstIterator", "swig::ConstIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__GC_VALUE = {"_p_swig__GC_VALUE", "swig::GC_VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__Iterator = {"_p_swig__Iterator", "swig::Iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_tm = {"_p_tm", "tm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "VALUE|void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ApplVerID,
  &_swigt__p_Application,
  &_swigt__p_BeginString,
  &_swigt__p_DOMDocumentPtr,
  &_swigt__p_Data,
  &_swigt__p_DataDictionary,
  &_swigt__p_DataDictionaryProvider,
  &_swigt__p_Dictionaries,
  &_swigt__p_DoubleField,
  &_swigt__p_FIX__Acceptor,
  &_swigt__p_FIX__Application,
  &_swigt__p_FIX__BeginString,
  &_swigt__p_FIX__BoolField,
  &_swigt__p_FIX__CharField,
  &_swigt__p_FIX__CheckSumField,
  &_swigt__p_FIX__ConfigError,
  &_swigt__p_FIX__DataDictionary,
  &_swigt__p_FIX__DataDictionaryNotFound,
  &_swigt__p_FIX__DatabaseConnectionID,
  &_swigt__p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t,
  &_swigt__p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t,
  &_swigt__p_FIX__DateTime,
  &_swigt__p_FIX__Dictionary,
  &_swigt__p_FIX__DoNotSend,
  &_swigt__p_FIX__DoubleField,
  &_swigt__p_FIX__DuplicateFieldNumber,
  &_swigt__p_FIX__Exception,
  &_swigt__p_FIX__FieldBase,
  &_swigt__p_FIX__FieldConvertError,
  &_swigt__p_FIX__FieldMap,
  &_swigt__p_FIX__FieldNotFound,
  &_swigt__p_FIX__FileLog,
  &_swigt__p_FIX__FileLogFactory,
  &_swigt__p_FIX__FileStore,
  &_swigt__p_FIX__FileStoreFactory,
  &_swigt__p_FIX__Group,
  &_swigt__p_FIX__Header,
  &_swigt__p_FIX__IOException,
  &_swigt__p_FIX__IncorrectDataFormat,
  &_swigt__p_FIX__IncorrectMessageStructure,
  &_swigt__p_FIX__IncorrectTagValue,
  &_swigt__p_FIX__Initiator,
  &_swigt__p_FIX__IntField,
  &_swigt__p_FIX__InvalidMessage,
  &_swigt__p_FIX__InvalidMessageType,
  &_swigt__p_FIX__InvalidTagNumber,
  &_swigt__p_FIX__LocalDate,
  &_swigt__p_FIX__LocalTimeOnly,
  &_swigt__p_FIX__LocalTimeStamp,
  &_swigt__p_FIX__Log,
  &_swigt__p_FIX__LogFactory,
  &_swigt__p_FIX__MemoryStore,
  &_swigt__p_FIX__MemoryStoreFactory,
  &_swigt__p_FIX__Message,
  &_swigt__p_FIX__MessageParseError,
  &_swigt__p_FIX__MessageStore,
  &_swigt__p_FIX__MessageStoreExceptionWrapper,
  &_swigt__p_FIX__MessageStoreFactory,
  &_swigt__p_FIX__MessageStoreFactoryExceptionWrapper,
  &_swigt__p_FIX__MySQLConnection,
  &_swigt__p_FIX__MySQLLog,
  &_swigt__p_FIX__MySQLLogFactory,
  &_swigt__p_FIX__MySQLQuery,
  &_swigt__p_FIX__MySQLStore,
  &_swigt__p_FIX__MySQLStoreFactory,
  &_swigt__p_FIX__NoTagValue,
  &_swigt__p_FIX__NullApplication,
  &_swigt__p_FIX__NullLog,
  &_swigt__p_FIX__PostgreSQLConnection,
  &_swigt__p_FIX__PostgreSQLLog,
  &_swigt__p_FIX__PostgreSQLLogFactory,
  &_swigt__p_FIX__PostgreSQLQuery,
  &_swigt__p_FIX__PostgreSQLStore,
  &_swigt__p_FIX__PostgreSQLStoreFactory,
  &_swigt__p_FIX__RejectLogon,
  &_swigt__p_FIX__RepeatedTag,
  &_swigt__p_FIX__RepeatingGroupCountMismatch,
  &_swigt__p_FIX__RequiredTagMissing,
  &_swigt__p_FIX__RuntimeError,
  &_swigt__p_FIX__SSLSocketAcceptor,
  &_swigt__p_FIX__SSLSocketInitiator,
  &_swigt__p_FIX__ScreenLog,
  &_swigt__p_FIX__ScreenLogFactory,
  &_swigt__p_FIX__SenderCompID,
  &_swigt__p_FIX__Session,
  &_swigt__p_FIX__SessionID,
  &_swigt__p_FIX__SessionNotFound,
  &_swigt__p_FIX__SessionSettings,
  &_swigt__p_FIX__SocketAcceptor,
  &_swigt__p_FIX__SocketCloseFailed,
  &_swigt__p_FIX__SocketException,
  &_swigt__p_FIX__SocketInitiator,
  &_swigt__p_FIX__SocketRecvFailed,
  &_swigt__p_FIX__SocketSendFailed,
  &_swigt__p_FIX__StringField,
  &_swigt__p_FIX__SynchronizedApplication,
  &_swigt__p_FIX__TYPE__Type,
  &_swigt__p_FIX__TagNotDefinedForMessage,
  &_swigt__p_FIX__TagOutOfOrder,
  &_swigt__p_FIX__TargetCompID,
  &_swigt__p_FIX__Trailer,
  &_swigt__p_FIX__UnsupportedMessageType,
  &_swigt__p_FIX__UnsupportedVersion,
  &_swigt__p_FIX__UtcDate,
  &_swigt__p_FIX__UtcDateField,
  &_swigt__p_FIX__UtcTimeOnly,
  &_swigt__p_FIX__UtcTimeOnlyField,
  &_swigt__p_FIX__UtcTimeStamp,
  &_swigt__p_FIX__UtcTimeStampField,
  &_swigt__p_Fields,
  &_swigt__p_Group,
  &_swigt__p_Groups,
  &_swigt__p_IntArray,
  &_swigt__p_IntField,
  &_swigt__p_Log,
  &_swigt__p_LogFactory,
  &_swigt__p_MYSQL,
  &_swigt__p_MessageStore,
  &_swigt__p_MessageStoreFactory,
  &_swigt__p_MsgType,
  &_swigt__p_Mutex,
  &_swigt__p_PGconn,
  &_swigt__p_RSA,
  &_swigt__p_Responder,
  &_swigt__p_SessionID,
  &_swigt__p_SessionToPort,
  &_swigt__p_StringField,
  &_swigt__p_TimeRange,
  &_swigt__p_UtcDateField,
  &_swigt__p_X509,
  &_swigt__p_allocator_type,
  &_swigt__p_bool,
  &_swigt__p_char,
  &_swigt__p_const_iterator,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_g_const_iterator,
  &_swigt__p_g_iterator,
  &_swigt__p_g_value_type,
  &_swigt__p_int,
  &_swigt__p_int64_t,
  &_swigt__p_iterator,
  &_swigt__p_key_type,
  &_swigt__p_message_order,
  &_swigt__p_p_FIX__DataDictionary,
  &_swigt__p_size_type,
  &_swigt__p_ssize_t,
  &_swigt__p_std__functionT_FIX__UtcTimeStamp_fF_t,
  &_swigt__p_std__istream,
  &_swigt__p_std__lessT_FIX__SessionID_t,
  &_swigt__p_std__logic_error,
  &_swigt__p_std__mapT_FIX__SessionID_uint16_t_t,
  &_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t,
  &_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator,
  &_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator,
  &_swigt__p_std__mapT_std__string_std__string_t__const_iterator,
  &_swigt__p_std__ostream,
  &_swigt__p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t,
  &_swigt__p_std__string,
  &_swigt__p_std__string__size_type,
  &_swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t,
  &_swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t,
  &_swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator,
  &_swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator,
  &_swigt__p_std__vectorT_std__string_t,
  &_swigt__p_swig__ConstIterator,
  &_swigt__p_swig__GC_VALUE,
  &_swigt__p_swig__Iterator,
  &_swigt__p_tm,
  &_swigt__p_value_type,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_ApplVerID[] = {  {&_swigt__p_ApplVerID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Application[] = {  {&_swigt__p_Application, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BeginString[] = {  {&_swigt__p_BeginString, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DOMDocumentPtr[] = {  {&_swigt__p_DOMDocumentPtr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Data[] = {  {&_swigt__p_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DataDictionary[] = {  {&_swigt__p_DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DataDictionaryProvider[] = {  {&_swigt__p_DataDictionaryProvider, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Dictionaries[] = {  {&_swigt__p_Dictionaries, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DoubleField[] = {  {&_swigt__p_DoubleField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Acceptor[] = {  {&_swigt__p_FIX__Acceptor, 0, 0, 0},  {&_swigt__p_FIX__SSLSocketAcceptor, _p_FIX__SSLSocketAcceptorTo_p_FIX__Acceptor, 0, 0},  {&_swigt__p_FIX__SocketAcceptor, _p_FIX__SocketAcceptorTo_p_FIX__Acceptor, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Application[] = {  {&_swigt__p_FIX__Application, 0, 0, 0},  {&_swigt__p_FIX__NullApplication, _p_FIX__NullApplicationTo_p_FIX__Application, 0, 0},  {&_swigt__p_FIX__SynchronizedApplication, _p_FIX__SynchronizedApplicationTo_p_FIX__Application, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__BeginString[] = {  {&_swigt__p_FIX__BeginString, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__BoolField[] = {  {&_swigt__p_FIX__BoolField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CharField[] = {  {&_swigt__p_FIX__CharField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CheckSumField[] = {  {&_swigt__p_FIX__CheckSumField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ConfigError[] = {  {&_swigt__p_FIX__ConfigError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DataDictionary[] = {  {&_swigt__p_FIX__DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DataDictionaryNotFound[] = {  {&_swigt__p_FIX__DataDictionaryNotFound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DatabaseConnectionID[] = {  {&_swigt__p_FIX__DatabaseConnectionID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t[] = {  {&_swigt__p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t[] = {  {&_swigt__p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DateTime[] = {  {&_swigt__p_FIX__DateTime, 0, 0, 0},  {&_swigt__p_FIX__LocalDate, _p_FIX__LocalDateTo_p_FIX__DateTime, 0, 0},  {&_swigt__p_FIX__LocalTimeOnly, _p_FIX__LocalTimeOnlyTo_p_FIX__DateTime, 0, 0},  {&_swigt__p_FIX__LocalTimeStamp, _p_FIX__LocalTimeStampTo_p_FIX__DateTime, 0, 0},  {&_swigt__p_FIX__UtcDate, _p_FIX__UtcDateTo_p_FIX__DateTime, 0, 0},  {&_swigt__p_FIX__UtcTimeOnly, _p_FIX__UtcTimeOnlyTo_p_FIX__DateTime, 0, 0},  {&_swigt__p_FIX__UtcTimeStamp, _p_FIX__UtcTimeStampTo_p_FIX__DateTime, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Dictionary[] = {  {&_swigt__p_FIX__Dictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DoNotSend[] = {  {&_swigt__p_FIX__DoNotSend, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DoubleField[] = {  {&_swigt__p_FIX__DoubleField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DuplicateFieldNumber[] = {  {&_swigt__p_FIX__DuplicateFieldNumber, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Exception[] = {  {&_swigt__p_FIX__Exception, 0, 0, 0},  {&_swigt__p_FIX__ConfigError, _p_FIX__ConfigErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__DataDictionaryNotFound, _p_FIX__DataDictionaryNotFoundTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__DoNotSend, _p_FIX__DoNotSendTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__DuplicateFieldNumber, _p_FIX__DuplicateFieldNumberTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__FieldConvertError, _p_FIX__FieldConvertErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__FieldNotFound, _p_FIX__FieldNotFoundTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IOException, _p_FIX__IOExceptionTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectDataFormat, _p_FIX__IncorrectDataFormatTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectMessageStructure, _p_FIX__IncorrectMessageStructureTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectTagValue, _p_FIX__IncorrectTagValueTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidMessage, _p_FIX__InvalidMessageTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidMessageType, _p_FIX__InvalidMessageTypeTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidTagNumber, _p_FIX__InvalidTagNumberTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__MessageParseError, _p_FIX__MessageParseErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__NoTagValue, _p_FIX__NoTagValueTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RejectLogon, _p_FIX__RejectLogonTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RepeatedTag, _p_FIX__RepeatedTagTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RepeatingGroupCountMismatch, _p_FIX__RepeatingGroupCountMismatchTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RequiredTagMissing, _p_FIX__RequiredTagMissingTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RuntimeError, _p_FIX__RuntimeErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SessionNotFound, _p_FIX__SessionNotFoundTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketCloseFailed, _p_FIX__SocketCloseFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketException, _p_FIX__SocketExceptionTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketRecvFailed, _p_FIX__SocketRecvFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketSendFailed, _p_FIX__SocketSendFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__TagNotDefinedForMessage, _p_FIX__TagNotDefinedForMessageTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__TagOutOfOrder, _p_FIX__TagOutOfOrderTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__UnsupportedMessageType, _p_FIX__UnsupportedMessageTypeTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__UnsupportedVersion, _p_FIX__UnsupportedVersionTo_p_FIX__Exception, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldBase[] = {  {&_swigt__p_FIX__FieldBase, 0, 0, 0},  {&_swigt__p_FIX__BeginString, _p_FIX__BeginStringTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__BoolField, _p_FIX__BoolFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CharField, _p_FIX__CharFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CheckSumField, _p_FIX__CheckSumFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__DoubleField, _p_FIX__DoubleFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__IntField, _p_FIX__IntFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SenderCompID, _p_FIX__SenderCompIDTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__StringField, _p_FIX__StringFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TargetCompID, _p_FIX__TargetCompIDTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcDateField, _p_FIX__UtcDateFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcTimeOnlyField, _p_FIX__UtcTimeOnlyFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcTimeStampField, _p_FIX__UtcTimeStampFieldTo_p_FIX__FieldBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldConvertError[] = {  {&_swigt__p_FIX__FieldConvertError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldMap[] = {  {&_swigt__p_FIX__FieldMap, 0, 0, 0},  {&_swigt__p_FIX__Group, _p_FIX__GroupTo_p_FIX__FieldMap, 0, 0},  {&_swigt__p_FIX__Header, _p_FIX__HeaderTo_p_FIX__FieldMap, 0, 0},  {&_swigt__p_FIX__Message, _p_FIX__MessageTo_p_FIX__FieldMap, 0, 0},  {&_swigt__p_FIX__Trailer, _p_FIX__TrailerTo_p_FIX__FieldMap, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldNotFound[] = {  {&_swigt__p_FIX__FieldNotFound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileLog[] = {  {&_swigt__p_FIX__FileLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileLogFactory[] = {  {&_swigt__p_FIX__FileLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileStore[] = {  {&_swigt__p_FIX__FileStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileStoreFactory[] = {  {&_swigt__p_FIX__FileStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Group[] = {  {&_swigt__p_FIX__Group, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Header[] = {  {&_swigt__p_FIX__Header, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IOException[] = {  {&_swigt__p_FIX__IOException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectDataFormat[] = {  {&_swigt__p_FIX__IncorrectDataFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectMessageStructure[] = {  {&_swigt__p_FIX__IncorrectMessageStructure, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectTagValue[] = {  {&_swigt__p_FIX__IncorrectTagValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Initiator[] = {  {&_swigt__p_FIX__Initiator, 0, 0, 0},  {&_swigt__p_FIX__SSLSocketInitiator, _p_FIX__SSLSocketInitiatorTo_p_FIX__Initiator, 0, 0},  {&_swigt__p_FIX__SocketInitiator, _p_FIX__SocketInitiatorTo_p_FIX__Initiator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IntField[] = {  {&_swigt__p_FIX__IntField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidMessage[] = {  {&_swigt__p_FIX__InvalidMessage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidMessageType[] = {  {&_swigt__p_FIX__InvalidMessageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidTagNumber[] = {  {&_swigt__p_FIX__InvalidTagNumber, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LocalDate[] = {  {&_swigt__p_FIX__LocalDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LocalTimeOnly[] = {  {&_swigt__p_FIX__LocalTimeOnly, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LocalTimeStamp[] = {  {&_swigt__p_FIX__LocalTimeStamp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Log[] = {  {&_swigt__p_FIX__Log, 0, 0, 0},  {&_swigt__p_FIX__FileLog, _p_FIX__FileLogTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__MySQLLog, _p_FIX__MySQLLogTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__NullLog, _p_FIX__NullLogTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__PostgreSQLLog, _p_FIX__PostgreSQLLogTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__ScreenLog, _p_FIX__ScreenLogTo_p_FIX__Log, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LogFactory[] = {  {&_swigt__p_FIX__LogFactory, 0, 0, 0},  {&_swigt__p_FIX__FileLogFactory, _p_FIX__FileLogFactoryTo_p_FIX__LogFactory, 0, 0},  {&_swigt__p_FIX__MySQLLogFactory, _p_FIX__MySQLLogFactoryTo_p_FIX__LogFactory, 0, 0},  {&_swigt__p_FIX__PostgreSQLLogFactory, _p_FIX__PostgreSQLLogFactoryTo_p_FIX__LogFactory, 0, 0},  {&_swigt__p_FIX__ScreenLogFactory, _p_FIX__ScreenLogFactoryTo_p_FIX__LogFactory, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MemoryStore[] = {  {&_swigt__p_FIX__MemoryStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MemoryStoreFactory[] = {  {&_swigt__p_FIX__MemoryStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Message[] = {  {&_swigt__p_FIX__Message, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageParseError[] = {  {&_swigt__p_FIX__MessageParseError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStore[] = {  {&_swigt__p_FIX__MessageStore, 0, 0, 0},  {&_swigt__p_FIX__FileStore, _p_FIX__FileStoreTo_p_FIX__MessageStore, 0, 0},  {&_swigt__p_FIX__MemoryStore, _p_FIX__MemoryStoreTo_p_FIX__MessageStore, 0, 0},  {&_swigt__p_FIX__MySQLStore, _p_FIX__MySQLStoreTo_p_FIX__MessageStore, 0, 0},  {&_swigt__p_FIX__PostgreSQLStore, _p_FIX__PostgreSQLStoreTo_p_FIX__MessageStore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreExceptionWrapper[] = {  {&_swigt__p_FIX__MessageStoreExceptionWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreFactory[] = {  {&_swigt__p_FIX__MessageStoreFactory, 0, 0, 0},  {&_swigt__p_FIX__FileStoreFactory, _p_FIX__FileStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},  {&_swigt__p_FIX__MemoryStoreFactory, _p_FIX__MemoryStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},  {&_swigt__p_FIX__MySQLStoreFactory, _p_FIX__MySQLStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},  {&_swigt__p_FIX__PostgreSQLStoreFactory, _p_FIX__PostgreSQLStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreFactoryExceptionWrapper[] = {  {&_swigt__p_FIX__MessageStoreFactoryExceptionWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLConnection[] = {  {&_swigt__p_FIX__MySQLConnection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLLog[] = {  {&_swigt__p_FIX__MySQLLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLLogFactory[] = {  {&_swigt__p_FIX__MySQLLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLQuery[] = {  {&_swigt__p_FIX__MySQLQuery, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLStore[] = {  {&_swigt__p_FIX__MySQLStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MySQLStoreFactory[] = {  {&_swigt__p_FIX__MySQLStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__NoTagValue[] = {  {&_swigt__p_FIX__NoTagValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__NullApplication[] = {  {&_swigt__p_FIX__NullApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__NullLog[] = {  {&_swigt__p_FIX__NullLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLConnection[] = {  {&_swigt__p_FIX__PostgreSQLConnection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLLog[] = {  {&_swigt__p_FIX__PostgreSQLLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLLogFactory[] = {  {&_swigt__p_FIX__PostgreSQLLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLQuery[] = {  {&_swigt__p_FIX__PostgreSQLQuery, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLStore[] = {  {&_swigt__p_FIX__PostgreSQLStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PostgreSQLStoreFactory[] = {  {&_swigt__p_FIX__PostgreSQLStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RejectLogon[] = {  {&_swigt__p_FIX__RejectLogon, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RepeatedTag[] = {  {&_swigt__p_FIX__RepeatedTag, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RepeatingGroupCountMismatch[] = {  {&_swigt__p_FIX__RepeatingGroupCountMismatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RequiredTagMissing[] = {  {&_swigt__p_FIX__RequiredTagMissing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RuntimeError[] = {  {&_swigt__p_FIX__RuntimeError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SSLSocketAcceptor[] = {  {&_swigt__p_FIX__SSLSocketAcceptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SSLSocketInitiator[] = {  {&_swigt__p_FIX__SSLSocketInitiator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ScreenLog[] = {  {&_swigt__p_FIX__ScreenLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ScreenLogFactory[] = {  {&_swigt__p_FIX__ScreenLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SenderCompID[] = {  {&_swigt__p_FIX__SenderCompID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Session[] = {  {&_swigt__p_FIX__Session, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionID[] = {  {&_swigt__p_FIX__SessionID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionNotFound[] = {  {&_swigt__p_FIX__SessionNotFound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionSettings[] = {  {&_swigt__p_FIX__SessionSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketAcceptor[] = {  {&_swigt__p_FIX__SocketAcceptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketCloseFailed[] = {  {&_swigt__p_FIX__SocketCloseFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketException[] = {  {&_swigt__p_FIX__SocketException, 0, 0, 0},  {&_swigt__p_FIX__SocketCloseFailed, _p_FIX__SocketCloseFailedTo_p_FIX__SocketException, 0, 0},  {&_swigt__p_FIX__SocketRecvFailed, _p_FIX__SocketRecvFailedTo_p_FIX__SocketException, 0, 0},  {&_swigt__p_FIX__SocketSendFailed, _p_FIX__SocketSendFailedTo_p_FIX__SocketException, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketInitiator[] = {  {&_swigt__p_FIX__SocketInitiator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketRecvFailed[] = {  {&_swigt__p_FIX__SocketRecvFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketSendFailed[] = {  {&_swigt__p_FIX__SocketSendFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__StringField[] = {  {&_swigt__p_FIX__StringField, 0, 0, 0},  {&_swigt__p_FIX__BeginString, _p_FIX__BeginStringTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SenderCompID, _p_FIX__SenderCompIDTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__TargetCompID, _p_FIX__TargetCompIDTo_p_FIX__StringField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SynchronizedApplication[] = {  {&_swigt__p_FIX__SynchronizedApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TYPE__Type[] = {  {&_swigt__p_FIX__TYPE__Type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TagNotDefinedForMessage[] = {  {&_swigt__p_FIX__TagNotDefinedForMessage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TagOutOfOrder[] = {  {&_swigt__p_FIX__TagOutOfOrder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TargetCompID[] = {  {&_swigt__p_FIX__TargetCompID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Trailer[] = {  {&_swigt__p_FIX__Trailer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnsupportedMessageType[] = {  {&_swigt__p_FIX__UnsupportedMessageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnsupportedVersion[] = {  {&_swigt__p_FIX__UnsupportedVersion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcDate[] = {  {&_swigt__p_FIX__UtcDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcDateField[] = {  {&_swigt__p_FIX__UtcDateField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeOnly[] = {  {&_swigt__p_FIX__UtcTimeOnly, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeOnlyField[] = {  {&_swigt__p_FIX__UtcTimeOnlyField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeStamp[] = {  {&_swigt__p_FIX__UtcTimeStamp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeStampField[] = {  {&_swigt__p_FIX__UtcTimeStampField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Fields[] = {  {&_swigt__p_Fields, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Group[] = {  {&_swigt__p_Group, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Groups[] = {  {&_swigt__p_Groups, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntArray[] = {  {&_swigt__p_IntArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntField[] = {  {&_swigt__p_IntField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Log[] = {  {&_swigt__p_Log, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LogFactory[] = {  {&_swigt__p_LogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MYSQL[] = {  {&_swigt__p_MYSQL, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MessageStore[] = {  {&_swigt__p_MessageStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MessageStoreFactory[] = {  {&_swigt__p_MessageStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MsgType[] = {  {&_swigt__p_MsgType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Mutex[] = {  {&_swigt__p_Mutex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PGconn[] = {  {&_swigt__p_PGconn, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RSA[] = {  {&_swigt__p_RSA, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Responder[] = {  {&_swigt__p_Responder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SessionID[] = {  {&_swigt__p_SessionID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SessionToPort[] = {  {&_swigt__p_SessionToPort, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringField[] = {  {&_swigt__p_StringField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimeRange[] = {  {&_swigt__p_TimeRange, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcDateField[] = {  {&_swigt__p_UtcDateField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_X509[] = {  {&_swigt__p_X509, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bool[] = {  {&_swigt__p_bool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_g_const_iterator[] = {  {&_swigt__p_g_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_g_iterator[] = {  {&_swigt__p_g_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_g_value_type[] = {  {&_swigt__p_g_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},  {&_swigt__p_IntArray, _p_IntArrayTo_p_int, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int64_t[] = {  {&_swigt__p_int64_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_key_type[] = {  {&_swigt__p_key_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_message_order[] = {  {&_swigt__p_message_order, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_FIX__DataDictionary[] = {  {&_swigt__p_p_FIX__DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ssize_t[] = {  {&_swigt__p_ssize_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_FIX__UtcTimeStamp_fF_t[] = {  {&_swigt__p_std__functionT_FIX__UtcTimeStamp_fF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__lessT_FIX__SessionID_t[] = {  {&_swigt__p_std__lessT_FIX__SessionID_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__logic_error[] = {  {&_swigt__p_std__logic_error, 0, 0, 0},  {&_swigt__p_FIX__ConfigError, _p_FIX__ConfigErrorTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__DataDictionaryNotFound, _p_FIX__DataDictionaryNotFoundTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__DoNotSend, _p_FIX__DoNotSendTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__DuplicateFieldNumber, _p_FIX__DuplicateFieldNumberTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__Exception, _p_FIX__ExceptionTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__FieldConvertError, _p_FIX__FieldConvertErrorTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__FieldNotFound, _p_FIX__FieldNotFoundTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__IOException, _p_FIX__IOExceptionTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__IncorrectDataFormat, _p_FIX__IncorrectDataFormatTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__IncorrectMessageStructure, _p_FIX__IncorrectMessageStructureTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__IncorrectTagValue, _p_FIX__IncorrectTagValueTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__InvalidMessage, _p_FIX__InvalidMessageTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__InvalidMessageType, _p_FIX__InvalidMessageTypeTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__InvalidTagNumber, _p_FIX__InvalidTagNumberTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__MessageParseError, _p_FIX__MessageParseErrorTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__NoTagValue, _p_FIX__NoTagValueTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__RejectLogon, _p_FIX__RejectLogonTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__RepeatedTag, _p_FIX__RepeatedTagTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__RepeatingGroupCountMismatch, _p_FIX__RepeatingGroupCountMismatchTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__RequiredTagMissing, _p_FIX__RequiredTagMissingTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__RuntimeError, _p_FIX__RuntimeErrorTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__SessionNotFound, _p_FIX__SessionNotFoundTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__SocketCloseFailed, _p_FIX__SocketCloseFailedTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__SocketException, _p_FIX__SocketExceptionTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__SocketRecvFailed, _p_FIX__SocketRecvFailedTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__SocketSendFailed, _p_FIX__SocketSendFailedTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__TagNotDefinedForMessage, _p_FIX__TagNotDefinedForMessageTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__TagOutOfOrder, _p_FIX__TagOutOfOrderTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__UnsupportedMessageType, _p_FIX__UnsupportedMessageTypeTo_p_std__logic_error, 0, 0},  {&_swigt__p_FIX__UnsupportedVersion, _p_FIX__UnsupportedVersionTo_p_std__logic_error, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_FIX__SessionID_uint16_t_t[] = {  {&_swigt__p_std__mapT_FIX__SessionID_uint16_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t[] = {  {&_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator[] = {  {&_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_std__string_t__const_iterator[] = {  {&_swigt__p_std__mapT_std__string_std__string_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t[] = {  {&_swigt__p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string__size_type[] = {  {&_swigt__p_std__string__size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t[] = {  {&_swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t[] = {  {&_swigt__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator[] = {  {&_swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator[] = {  {&_swigt__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_t[] = {  {&_swigt__p_std__vectorT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&_swigt__p_swig__ConstIterator, 0, 0, 0},  {&_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__Iterator[] = {  {&_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tm[] = {  {&_swigt__p_tm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ApplVerID,
  _swigc__p_Application,
  _swigc__p_BeginString,
  _swigc__p_DOMDocumentPtr,
  _swigc__p_Data,
  _swigc__p_DataDictionary,
  _swigc__p_DataDictionaryProvider,
  _swigc__p_Dictionaries,
  _swigc__p_DoubleField,
  _swigc__p_FIX__Acceptor,
  _swigc__p_FIX__Application,
  _swigc__p_FIX__BeginString,
  _swigc__p_FIX__BoolField,
  _swigc__p_FIX__CharField,
  _swigc__p_FIX__CheckSumField,
  _swigc__p_FIX__ConfigError,
  _swigc__p_FIX__DataDictionary,
  _swigc__p_FIX__DataDictionaryNotFound,
  _swigc__p_FIX__DatabaseConnectionID,
  _swigc__p_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t,
  _swigc__p_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t,
  _swigc__p_FIX__DateTime,
  _swigc__p_FIX__Dictionary,
  _swigc__p_FIX__DoNotSend,
  _swigc__p_FIX__DoubleField,
  _swigc__p_FIX__DuplicateFieldNumber,
  _swigc__p_FIX__Exception,
  _swigc__p_FIX__FieldBase,
  _swigc__p_FIX__FieldConvertError,
  _swigc__p_FIX__FieldMap,
  _swigc__p_FIX__FieldNotFound,
  _swigc__p_FIX__FileLog,
  _swigc__p_FIX__FileLogFactory,
  _swigc__p_FIX__FileStore,
  _swigc__p_FIX__FileStoreFactory,
  _swigc__p_FIX__Group,
  _swigc__p_FIX__Header,
  _swigc__p_FIX__IOException,
  _swigc__p_FIX__IncorrectDataFormat,
  _swigc__p_FIX__IncorrectMessageStructure,
  _swigc__p_FIX__IncorrectTagValue,
  _swigc__p_FIX__Initiator,
  _swigc__p_FIX__IntField,
  _swigc__p_FIX__InvalidMessage,
  _swigc__p_FIX__InvalidMessageType,
  _swigc__p_FIX__InvalidTagNumber,
  _swigc__p_FIX__LocalDate,
  _swigc__p_FIX__LocalTimeOnly,
  _swigc__p_FIX__LocalTimeStamp,
  _swigc__p_FIX__Log,
  _swigc__p_FIX__LogFactory,
  _swigc__p_FIX__MemoryStore,
  _swigc__p_FIX__MemoryStoreFactory,
  _swigc__p_FIX__Message,
  _swigc__p_FIX__MessageParseError,
  _swigc__p_FIX__MessageStore,
  _swigc__p_FIX__MessageStoreExceptionWrapper,
  _swigc__p_FIX__MessageStoreFactory,
  _swigc__p_FIX__MessageStoreFactoryExceptionWrapper,
  _swigc__p_FIX__MySQLConnection,
  _swigc__p_FIX__MySQLLog,
  _swigc__p_FIX__MySQLLogFactory,
  _swigc__p_FIX__MySQLQuery,
  _swigc__p_FIX__MySQLStore,
  _swigc__p_FIX__MySQLStoreFactory,
  _swigc__p_FIX__NoTagValue,
  _swigc__p_FIX__NullApplication,
  _swigc__p_FIX__NullLog,
  _swigc__p_FIX__PostgreSQLConnection,
  _swigc__p_FIX__PostgreSQLLog,
  _swigc__p_FIX__PostgreSQLLogFactory,
  _swigc__p_FIX__PostgreSQLQuery,
  _swigc__p_FIX__PostgreSQLStore,
  _swigc__p_FIX__PostgreSQLStoreFactory,
  _swigc__p_FIX__RejectLogon,
  _swigc__p_FIX__RepeatedTag,
  _swigc__p_FIX__RepeatingGroupCountMismatch,
  _swigc__p_FIX__RequiredTagMissing,
  _swigc__p_FIX__RuntimeError,
  _swigc__p_FIX__SSLSocketAcceptor,
  _swigc__p_FIX__SSLSocketInitiator,
  _swigc__p_FIX__ScreenLog,
  _swigc__p_FIX__ScreenLogFactory,
  _swigc__p_FIX__SenderCompID,
  _swigc__p_FIX__Session,
  _swigc__p_FIX__SessionID,
  _swigc__p_FIX__SessionNotFound,
  _swigc__p_FIX__SessionSettings,
  _swigc__p_FIX__SocketAcceptor,
  _swigc__p_FIX__SocketCloseFailed,
  _swigc__p_FIX__SocketException,
  _swigc__p_FIX__SocketInitiator,
  _swigc__p_FIX__SocketRecvFailed,
  _swigc__p_FIX__SocketSendFailed,
  _swigc__p_FIX__StringField,
  _swigc__p_FIX__SynchronizedApplication,
  _swigc__p_FIX__TYPE__Type,
  _swigc__p_FIX__TagNotDefinedForMessage,
  _swigc__p_FIX__TagOutOfOrder,
  _swigc__p_FIX__TargetCompID,
  _swigc__p_FIX__Trailer,
  _swigc__p_FIX__UnsupportedMessageType,
  _swigc__p_FIX__UnsupportedVersion,
  _swigc__p_FIX__UtcDate,
  _swigc__p_FIX__UtcDateField,
  _swigc__p_FIX__UtcTimeOnly,
  _swigc__p_FIX__UtcTimeOnlyField,
  _swigc__p_FIX__UtcTimeStamp,
  _swigc__p_FIX__UtcTimeStampField,
  _swigc__p_Fields,
  _swigc__p_Group,
  _swigc__p_Groups,
  _swigc__p_IntArray,
  _swigc__p_IntField,
  _swigc__p_Log,
  _swigc__p_LogFactory,
  _swigc__p_MYSQL,
  _swigc__p_MessageStore,
  _swigc__p_MessageStoreFactory,
  _swigc__p_MsgType,
  _swigc__p_Mutex,
  _swigc__p_PGconn,
  _swigc__p_RSA,
  _swigc__p_Responder,
  _swigc__p_SessionID,
  _swigc__p_SessionToPort,
  _swigc__p_StringField,
  _swigc__p_TimeRange,
  _swigc__p_UtcDateField,
  _swigc__p_X509,
  _swigc__p_allocator_type,
  _swigc__p_bool,
  _swigc__p_char,
  _swigc__p_const_iterator,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_g_const_iterator,
  _swigc__p_g_iterator,
  _swigc__p_g_value_type,
  _swigc__p_int,
  _swigc__p_int64_t,
  _swigc__p_iterator,
  _swigc__p_key_type,
  _swigc__p_message_order,
  _swigc__p_p_FIX__DataDictionary,
  _swigc__p_size_type,
  _swigc__p_ssize_t,
  _swigc__p_std__functionT_FIX__UtcTimeStamp_fF_t,
  _swigc__p_std__istream,
  _swigc__p_std__lessT_FIX__SessionID_t,
  _swigc__p_std__logic_error,
  _swigc__p_std__mapT_FIX__SessionID_uint16_t_t,
  _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t,
  _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__const_iterator,
  _swigc__p_std__mapT_int_std__vectorT_FIX__FieldMap_p_t_std__lessT_int_t_ALLOCATORT_std__pairT_int_const_std__vectorT_FIX__FieldMap_p_t_t_t_t__iterator,
  _swigc__p_std__mapT_std__string_std__string_t__const_iterator,
  _swigc__p_std__ostream,
  _swigc__p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t,
  _swigc__p_std__string,
  _swigc__p_std__string__size_type,
  _swigc__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__MySQLConnection_t_t,
  _swigc__p_std__unique_ptrT_FIX__DatabaseConnectionPoolT_FIX__PostgreSQLConnection_t_t,
  _swigc__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__const_iterator,
  _swigc__p_std__vectorT_FIX__FieldBase_ALLOCATORT_FIX__FieldBase_t_t__iterator,
  _swigc__p_std__vectorT_std__string_t,
  _swigc__p_swig__ConstIterator,
  _swigc__p_swig__GC_VALUE,
  _swigc__p_swig__Iterator,
  _swigc__p_tm,
  _swigc__p_value_type,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_quickfix(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mQuickfix = rb_define_module("Quickfix");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  SwigClassGC_VALUE.klass = rb_define_class_under(mQuickfix, "GC_VALUE", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &SwigClassGC_VALUE);
  rb_undef_alloc_func(SwigClassGC_VALUE.klass);
  rb_define_method(SwigClassGC_VALUE.klass, "inspect", VALUEFUNC(_wrap_GC_VALUE_inspect), -1);
  rb_define_method(SwigClassGC_VALUE.klass, "to_s", VALUEFUNC(_wrap_GC_VALUE_to_s), -1);
  SwigClassGC_VALUE.mark = 0;
  SwigClassGC_VALUE.trackObjects = 0;
  
  swig::SwigGCReferences::initialize();
  
  
  SwigClassConstIterator.klass = rb_define_class_under(mQuickfix, "ConstIterator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &SwigClassConstIterator);
  rb_undef_alloc_func(SwigClassConstIterator.klass);
  rb_define_method(SwigClassConstIterator.klass, "value", VALUEFUNC(_wrap_ConstIterator_value), -1);
  rb_define_method(SwigClassConstIterator.klass, "dup", VALUEFUNC(_wrap_ConstIterator_dup), -1);
  rb_define_method(SwigClassConstIterator.klass, "inspect", VALUEFUNC(_wrap_ConstIterator_inspect), -1);
  rb_define_method(SwigClassConstIterator.klass, "to_s", VALUEFUNC(_wrap_ConstIterator_to_s), -1);
  rb_define_method(SwigClassConstIterator.klass, "next", VALUEFUNC(_wrap_ConstIterator_next), -1);
  rb_define_method(SwigClassConstIterator.klass, "previous", VALUEFUNC(_wrap_ConstIterator_previous), -1);
  rb_define_method(SwigClassConstIterator.klass, "==", VALUEFUNC(_wrap_ConstIterator___eq__), -1);
  rb_define_method(SwigClassConstIterator.klass, "+", VALUEFUNC(_wrap_ConstIterator___add__), -1);
  rb_define_method(SwigClassConstIterator.klass, "-", VALUEFUNC(_wrap_ConstIterator___sub__), -1);
  SwigClassConstIterator.mark = 0;
  SwigClassConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
  SwigClassConstIterator.trackObjects = 0;
  
  SwigClassIterator.klass = rb_define_class_under(mQuickfix, "Iterator", ((swig_class *) SWIGTYPE_p_swig__ConstIterator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &SwigClassIterator);
  rb_undef_alloc_func(SwigClassIterator.klass);
  rb_define_method(SwigClassIterator.klass, "value=", VALUEFUNC(_wrap_Iterator_valuee___), -1);
  rb_define_method(SwigClassIterator.klass, "dup", VALUEFUNC(_wrap_Iterator_dup), -1);
  rb_define_method(SwigClassIterator.klass, "next", VALUEFUNC(_wrap_Iterator_next), -1);
  rb_define_method(SwigClassIterator.klass, "previous", VALUEFUNC(_wrap_Iterator_previous), -1);
  rb_define_method(SwigClassIterator.klass, "inspect", VALUEFUNC(_wrap_Iterator_inspect), -1);
  rb_define_method(SwigClassIterator.klass, "to_s", VALUEFUNC(_wrap_Iterator_to_s), -1);
  rb_define_method(SwigClassIterator.klass, "==", VALUEFUNC(_wrap_Iterator___eq__), -1);
  rb_define_method(SwigClassIterator.klass, "+", VALUEFUNC(_wrap_Iterator___add__), -1);
  rb_define_method(SwigClassIterator.klass, "-", VALUEFUNC(_wrap_Iterator___sub__), -1);
  SwigClassIterator.mark = 0;
  SwigClassIterator.destroy = (void (*)(void *)) free_swig_Iterator;
  SwigClassIterator.trackObjects = 0;
  
  SwigClassIntArray.klass = rb_define_class_under(mQuickfix, "IntArray", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_IntArray, (void *) &SwigClassIntArray);
  rb_define_alloc_func(SwigClassIntArray.klass, _wrap_IntArray_allocate);
  rb_define_method(SwigClassIntArray.klass, "initialize", VALUEFUNC(_wrap_new_IntArray), -1);
  rb_define_method(SwigClassIntArray.klass, "[]", VALUEFUNC(_wrap_IntArray___getitem__), -1);
  rb_define_method(SwigClassIntArray.klass, "[]=", VALUEFUNC(_wrap_IntArray___setitem__), -1);
  rb_define_method(SwigClassIntArray.klass, "cast", VALUEFUNC(_wrap_IntArray_cast), -1);
  rb_define_singleton_method(SwigClassIntArray.klass, "frompointer", VALUEFUNC(_wrap_IntArray_frompointer), -1);
  SwigClassIntArray.mark = 0;
  SwigClassIntArray.destroy = (void (*)(void *)) free_IntArray;
  SwigClassIntArray.trackObjects = 0;
  
  SwigClassSessionIDSet.klass = rb_define_class_under(mQuickfix, "SessionIDSet", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__setT_FIX__SessionID_std__lessT_FIX__SessionID_t_std__allocatorT_FIX__SessionID_t_t, (void *) &SwigClassSessionIDSet);
  rb_include_module(SwigClassSessionIDSet.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassSessionIDSet.klass, _wrap_SessionIDSet_allocate);
  rb_define_method(SwigClassSessionIDSet.klass, "initialize", VALUEFUNC(_wrap_new_SessionIDSet), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "dup", VALUEFUNC(_wrap_SessionIDSet_dup), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "inspect", VALUEFUNC(_wrap_SessionIDSet_inspect), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "to_a", VALUEFUNC(_wrap_SessionIDSet_to_a), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "to_s", VALUEFUNC(_wrap_SessionIDSet_to_s), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "slice", VALUEFUNC(_wrap_SessionIDSet_slice), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "each", VALUEFUNC(_wrap_SessionIDSet_each), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "__delete2__", VALUEFUNC(_wrap_SessionIDSet___delete2__), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "select", VALUEFUNC(_wrap_SessionIDSet_select), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "delete_at", VALUEFUNC(_wrap_SessionIDSet_delete_at), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "reject!", VALUEFUNC(_wrap_SessionIDSet_rejectN___), -1);
  rb_define_alias(SwigClassSessionIDSet.klass, "delete_if", "reject!");
  rb_define_method(SwigClassSessionIDSet.klass, "push", VALUEFUNC(_wrap_SessionIDSet_push), -1);
  rb_define_alias(SwigClassSessionIDSet.klass, "<<", "push");
  rb_define_method(SwigClassSessionIDSet.klass, "include?", VALUEFUNC(_wrap_SessionIDSet_includeq___), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "[]", VALUEFUNC(_wrap_SessionIDSet___getitem__), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "empty?", VALUEFUNC(_wrap_SessionIDSet_emptyq___), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "size", VALUEFUNC(_wrap_SessionIDSet_size), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "clear", VALUEFUNC(_wrap_SessionIDSet_clear), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "swap", VALUEFUNC(_wrap_SessionIDSet_swap), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "count", VALUEFUNC(_wrap_SessionIDSet_count), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "begin", VALUEFUNC(_wrap_SessionIDSet_begin), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "end", VALUEFUNC(_wrap_SessionIDSet_end), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "rbegin", VALUEFUNC(_wrap_SessionIDSet_rbegin), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "rend", VALUEFUNC(_wrap_SessionIDSet_rend), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "erase", VALUEFUNC(_wrap_SessionIDSet_erase), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "find", VALUEFUNC(_wrap_SessionIDSet_find), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "lower_bound", VALUEFUNC(_wrap_SessionIDSet_lower_bound), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "upper_bound", VALUEFUNC(_wrap_SessionIDSet_upper_bound), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "equal_range", VALUEFUNC(_wrap_SessionIDSet_equal_range), -1);
  rb_define_method(SwigClassSessionIDSet.klass, "insert", VALUEFUNC(_wrap_SessionIDSet_insert), -1);
  SwigClassSessionIDSet.mark = 0;
  SwigClassSessionIDSet.destroy = (void (*)(void *)) free_std_set_Sl_FIX_SessionID_Sg_;
  SwigClassSessionIDSet.trackObjects = 0;
  
#ifdef SWIGPYTHON
  PyDateTime_IMPORT;
#endif
  
  
  SwigClassException.klass = rb_define_class_under(mQuickfix, "Exception", rb_eRuntimeError);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Exception, (void *) &SwigClassException);
  rb_define_alloc_func(SwigClassException.klass, _wrap_Exception_allocate);
  rb_define_method(SwigClassException.klass, "initialize", VALUEFUNC(_wrap_new_Exception), -1);
  rb_define_method(SwigClassException.klass, "type=", VALUEFUNC(_wrap_Exception_type_set), -1);
  rb_define_method(SwigClassException.klass, "type", VALUEFUNC(_wrap_Exception_type_get), -1);
  rb_define_method(SwigClassException.klass, "detail=", VALUEFUNC(_wrap_Exception_detail_set), -1);
  rb_define_method(SwigClassException.klass, "detail", VALUEFUNC(_wrap_Exception_detail_get), -1);
  rb_define_method(SwigClassException.klass, "to_s", VALUEFUNC(_wrap_Exception___str__), -1);
  SwigClassException.mark = 0;
  SwigClassException.destroy = (void (*)(void *)) free_FIX_Exception;
  SwigClassException.trackObjects = 0;
  
  SwigClassDataDictionaryNotFound.klass = rb_define_class_under(mQuickfix, "DataDictionaryNotFound", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DataDictionaryNotFound, (void *) &SwigClassDataDictionaryNotFound);
  rb_define_alloc_func(SwigClassDataDictionaryNotFound.klass, _wrap_DataDictionaryNotFound_allocate);
  rb_define_method(SwigClassDataDictionaryNotFound.klass, "initialize", VALUEFUNC(_wrap_new_DataDictionaryNotFound), -1);
  rb_define_method(SwigClassDataDictionaryNotFound.klass, "version=", VALUEFUNC(_wrap_DataDictionaryNotFound_version_set), -1);
  rb_define_method(SwigClassDataDictionaryNotFound.klass, "version", VALUEFUNC(_wrap_DataDictionaryNotFound_version_get), -1);
  SwigClassDataDictionaryNotFound.mark = 0;
  SwigClassDataDictionaryNotFound.destroy = (void (*)(void *)) free_FIX_DataDictionaryNotFound;
  SwigClassDataDictionaryNotFound.trackObjects = 0;
  
  SwigClassFieldNotFound.klass = rb_define_class_under(mQuickfix, "FieldNotFound", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldNotFound, (void *) &SwigClassFieldNotFound);
  rb_define_alloc_func(SwigClassFieldNotFound.klass, _wrap_FieldNotFound_allocate);
  rb_define_method(SwigClassFieldNotFound.klass, "initialize", VALUEFUNC(_wrap_new_FieldNotFound), -1);
  rb_define_method(SwigClassFieldNotFound.klass, "field=", VALUEFUNC(_wrap_FieldNotFound_field_set), -1);
  rb_define_method(SwigClassFieldNotFound.klass, "field", VALUEFUNC(_wrap_FieldNotFound_field_get), -1);
  SwigClassFieldNotFound.mark = 0;
  SwigClassFieldNotFound.destroy = (void (*)(void *)) free_FIX_FieldNotFound;
  SwigClassFieldNotFound.trackObjects = 0;
  
  SwigClassFieldConvertError.klass = rb_define_class_under(mQuickfix, "FieldConvertError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldConvertError, (void *) &SwigClassFieldConvertError);
  rb_define_alloc_func(SwigClassFieldConvertError.klass, _wrap_FieldConvertError_allocate);
  rb_define_method(SwigClassFieldConvertError.klass, "initialize", VALUEFUNC(_wrap_new_FieldConvertError), -1);
  SwigClassFieldConvertError.mark = 0;
  SwigClassFieldConvertError.destroy = (void (*)(void *)) free_FIX_FieldConvertError;
  SwigClassFieldConvertError.trackObjects = 0;
  
  SwigClassMessageParseError.klass = rb_define_class_under(mQuickfix, "MessageParseError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageParseError, (void *) &SwigClassMessageParseError);
  rb_define_alloc_func(SwigClassMessageParseError.klass, _wrap_MessageParseError_allocate);
  rb_define_method(SwigClassMessageParseError.klass, "initialize", VALUEFUNC(_wrap_new_MessageParseError), -1);
  SwigClassMessageParseError.mark = 0;
  SwigClassMessageParseError.destroy = (void (*)(void *)) free_FIX_MessageParseError;
  SwigClassMessageParseError.trackObjects = 0;
  
  SwigClassInvalidMessage.klass = rb_define_class_under(mQuickfix, "InvalidMessage", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidMessage, (void *) &SwigClassInvalidMessage);
  rb_define_alloc_func(SwigClassInvalidMessage.klass, _wrap_InvalidMessage_allocate);
  rb_define_method(SwigClassInvalidMessage.klass, "initialize", VALUEFUNC(_wrap_new_InvalidMessage), -1);
  SwigClassInvalidMessage.mark = 0;
  SwigClassInvalidMessage.destroy = (void (*)(void *)) free_FIX_InvalidMessage;
  SwigClassInvalidMessage.trackObjects = 0;
  
  SwigClassConfigError.klass = rb_define_class_under(mQuickfix, "ConfigError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ConfigError, (void *) &SwigClassConfigError);
  rb_define_alloc_func(SwigClassConfigError.klass, _wrap_ConfigError_allocate);
  rb_define_method(SwigClassConfigError.klass, "initialize", VALUEFUNC(_wrap_new_ConfigError), -1);
  SwigClassConfigError.mark = 0;
  SwigClassConfigError.destroy = (void (*)(void *)) free_FIX_ConfigError;
  SwigClassConfigError.trackObjects = 0;
  
  SwigClassRuntimeError.klass = rb_define_class_under(mQuickfix, "RuntimeError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RuntimeError, (void *) &SwigClassRuntimeError);
  rb_define_alloc_func(SwigClassRuntimeError.klass, _wrap_RuntimeError_allocate);
  rb_define_method(SwigClassRuntimeError.klass, "initialize", VALUEFUNC(_wrap_new_RuntimeError), -1);
  SwigClassRuntimeError.mark = 0;
  SwigClassRuntimeError.destroy = (void (*)(void *)) free_FIX_RuntimeError;
  SwigClassRuntimeError.trackObjects = 0;
  
  SwigClassInvalidTagNumber.klass = rb_define_class_under(mQuickfix, "InvalidTagNumber", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidTagNumber, (void *) &SwigClassInvalidTagNumber);
  rb_define_alloc_func(SwigClassInvalidTagNumber.klass, _wrap_InvalidTagNumber_allocate);
  rb_define_method(SwigClassInvalidTagNumber.klass, "initialize", VALUEFUNC(_wrap_new_InvalidTagNumber), -1);
  rb_define_method(SwigClassInvalidTagNumber.klass, "field=", VALUEFUNC(_wrap_InvalidTagNumber_field_set), -1);
  rb_define_method(SwigClassInvalidTagNumber.klass, "field", VALUEFUNC(_wrap_InvalidTagNumber_field_get), -1);
  SwigClassInvalidTagNumber.mark = 0;
  SwigClassInvalidTagNumber.destroy = (void (*)(void *)) free_FIX_InvalidTagNumber;
  SwigClassInvalidTagNumber.trackObjects = 0;
  
  SwigClassRequiredTagMissing.klass = rb_define_class_under(mQuickfix, "RequiredTagMissing", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RequiredTagMissing, (void *) &SwigClassRequiredTagMissing);
  rb_define_alloc_func(SwigClassRequiredTagMissing.klass, _wrap_RequiredTagMissing_allocate);
  rb_define_method(SwigClassRequiredTagMissing.klass, "initialize", VALUEFUNC(_wrap_new_RequiredTagMissing), -1);
  rb_define_method(SwigClassRequiredTagMissing.klass, "field=", VALUEFUNC(_wrap_RequiredTagMissing_field_set), -1);
  rb_define_method(SwigClassRequiredTagMissing.klass, "field", VALUEFUNC(_wrap_RequiredTagMissing_field_get), -1);
  SwigClassRequiredTagMissing.mark = 0;
  SwigClassRequiredTagMissing.destroy = (void (*)(void *)) free_FIX_RequiredTagMissing;
  SwigClassRequiredTagMissing.trackObjects = 0;
  
  SwigClassTagNotDefinedForMessage.klass = rb_define_class_under(mQuickfix, "TagNotDefinedForMessage", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TagNotDefinedForMessage, (void *) &SwigClassTagNotDefinedForMessage);
  rb_define_alloc_func(SwigClassTagNotDefinedForMessage.klass, _wrap_TagNotDefinedForMessage_allocate);
  rb_define_method(SwigClassTagNotDefinedForMessage.klass, "initialize", VALUEFUNC(_wrap_new_TagNotDefinedForMessage), -1);
  rb_define_method(SwigClassTagNotDefinedForMessage.klass, "field=", VALUEFUNC(_wrap_TagNotDefinedForMessage_field_set), -1);
  rb_define_method(SwigClassTagNotDefinedForMessage.klass, "field", VALUEFUNC(_wrap_TagNotDefinedForMessage_field_get), -1);
  SwigClassTagNotDefinedForMessage.mark = 0;
  SwigClassTagNotDefinedForMessage.destroy = (void (*)(void *)) free_FIX_TagNotDefinedForMessage;
  SwigClassTagNotDefinedForMessage.trackObjects = 0;
  
  SwigClassNoTagValue.klass = rb_define_class_under(mQuickfix, "NoTagValue", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__NoTagValue, (void *) &SwigClassNoTagValue);
  rb_define_alloc_func(SwigClassNoTagValue.klass, _wrap_NoTagValue_allocate);
  rb_define_method(SwigClassNoTagValue.klass, "initialize", VALUEFUNC(_wrap_new_NoTagValue), -1);
  rb_define_method(SwigClassNoTagValue.klass, "field=", VALUEFUNC(_wrap_NoTagValue_field_set), -1);
  rb_define_method(SwigClassNoTagValue.klass, "field", VALUEFUNC(_wrap_NoTagValue_field_get), -1);
  SwigClassNoTagValue.mark = 0;
  SwigClassNoTagValue.destroy = (void (*)(void *)) free_FIX_NoTagValue;
  SwigClassNoTagValue.trackObjects = 0;
  
  SwigClassIncorrectTagValue.klass = rb_define_class_under(mQuickfix, "IncorrectTagValue", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectTagValue, (void *) &SwigClassIncorrectTagValue);
  rb_define_alloc_func(SwigClassIncorrectTagValue.klass, _wrap_IncorrectTagValue_allocate);
  rb_define_method(SwigClassIncorrectTagValue.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectTagValue), -1);
  rb_define_method(SwigClassIncorrectTagValue.klass, "field=", VALUEFUNC(_wrap_IncorrectTagValue_field_set), -1);
  rb_define_method(SwigClassIncorrectTagValue.klass, "field", VALUEFUNC(_wrap_IncorrectTagValue_field_get), -1);
  SwigClassIncorrectTagValue.mark = 0;
  SwigClassIncorrectTagValue.destroy = (void (*)(void *)) free_FIX_IncorrectTagValue;
  SwigClassIncorrectTagValue.trackObjects = 0;
  
  SwigClassIncorrectDataFormat.klass = rb_define_class_under(mQuickfix, "IncorrectDataFormat", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectDataFormat, (void *) &SwigClassIncorrectDataFormat);
  rb_define_alloc_func(SwigClassIncorrectDataFormat.klass, _wrap_IncorrectDataFormat_allocate);
  rb_define_method(SwigClassIncorrectDataFormat.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectDataFormat), -1);
  rb_define_method(SwigClassIncorrectDataFormat.klass, "field=", VALUEFUNC(_wrap_IncorrectDataFormat_field_set), -1);
  rb_define_method(SwigClassIncorrectDataFormat.klass, "field", VALUEFUNC(_wrap_IncorrectDataFormat_field_get), -1);
  SwigClassIncorrectDataFormat.mark = 0;
  SwigClassIncorrectDataFormat.destroy = (void (*)(void *)) free_FIX_IncorrectDataFormat;
  SwigClassIncorrectDataFormat.trackObjects = 0;
  
  SwigClassIncorrectMessageStructure.klass = rb_define_class_under(mQuickfix, "IncorrectMessageStructure", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectMessageStructure, (void *) &SwigClassIncorrectMessageStructure);
  rb_define_alloc_func(SwigClassIncorrectMessageStructure.klass, _wrap_IncorrectMessageStructure_allocate);
  rb_define_method(SwigClassIncorrectMessageStructure.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectMessageStructure), -1);
  SwigClassIncorrectMessageStructure.mark = 0;
  SwigClassIncorrectMessageStructure.destroy = (void (*)(void *)) free_FIX_IncorrectMessageStructure;
  SwigClassIncorrectMessageStructure.trackObjects = 0;
  
  SwigClassDuplicateFieldNumber.klass = rb_define_class_under(mQuickfix, "DuplicateFieldNumber", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DuplicateFieldNumber, (void *) &SwigClassDuplicateFieldNumber);
  rb_define_alloc_func(SwigClassDuplicateFieldNumber.klass, _wrap_DuplicateFieldNumber_allocate);
  rb_define_method(SwigClassDuplicateFieldNumber.klass, "initialize", VALUEFUNC(_wrap_new_DuplicateFieldNumber), -1);
  SwigClassDuplicateFieldNumber.mark = 0;
  SwigClassDuplicateFieldNumber.destroy = (void (*)(void *)) free_FIX_DuplicateFieldNumber;
  SwigClassDuplicateFieldNumber.trackObjects = 0;
  
  SwigClassInvalidMessageType.klass = rb_define_class_under(mQuickfix, "InvalidMessageType", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidMessageType, (void *) &SwigClassInvalidMessageType);
  rb_define_alloc_func(SwigClassInvalidMessageType.klass, _wrap_InvalidMessageType_allocate);
  rb_define_method(SwigClassInvalidMessageType.klass, "initialize", VALUEFUNC(_wrap_new_InvalidMessageType), -1);
  SwigClassInvalidMessageType.mark = 0;
  SwigClassInvalidMessageType.destroy = (void (*)(void *)) free_FIX_InvalidMessageType;
  SwigClassInvalidMessageType.trackObjects = 0;
  
  SwigClassUnsupportedMessageType.klass = rb_define_class_under(mQuickfix, "UnsupportedMessageType", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnsupportedMessageType, (void *) &SwigClassUnsupportedMessageType);
  rb_define_alloc_func(SwigClassUnsupportedMessageType.klass, _wrap_UnsupportedMessageType_allocate);
  rb_define_method(SwigClassUnsupportedMessageType.klass, "initialize", VALUEFUNC(_wrap_new_UnsupportedMessageType), -1);
  SwigClassUnsupportedMessageType.mark = 0;
  SwigClassUnsupportedMessageType.destroy = (void (*)(void *)) free_FIX_UnsupportedMessageType;
  SwigClassUnsupportedMessageType.trackObjects = 0;
  
  SwigClassUnsupportedVersion.klass = rb_define_class_under(mQuickfix, "UnsupportedVersion", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnsupportedVersion, (void *) &SwigClassUnsupportedVersion);
  rb_define_alloc_func(SwigClassUnsupportedVersion.klass, _wrap_UnsupportedVersion_allocate);
  rb_define_method(SwigClassUnsupportedVersion.klass, "initialize", VALUEFUNC(_wrap_new_UnsupportedVersion), -1);
  SwigClassUnsupportedVersion.mark = 0;
  SwigClassUnsupportedVersion.destroy = (void (*)(void *)) free_FIX_UnsupportedVersion;
  SwigClassUnsupportedVersion.trackObjects = 0;
  
  SwigClassTagOutOfOrder.klass = rb_define_class_under(mQuickfix, "TagOutOfOrder", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TagOutOfOrder, (void *) &SwigClassTagOutOfOrder);
  rb_define_alloc_func(SwigClassTagOutOfOrder.klass, _wrap_TagOutOfOrder_allocate);
  rb_define_method(SwigClassTagOutOfOrder.klass, "initialize", VALUEFUNC(_wrap_new_TagOutOfOrder), -1);
  rb_define_method(SwigClassTagOutOfOrder.klass, "field=", VALUEFUNC(_wrap_TagOutOfOrder_field_set), -1);
  rb_define_method(SwigClassTagOutOfOrder.klass, "field", VALUEFUNC(_wrap_TagOutOfOrder_field_get), -1);
  SwigClassTagOutOfOrder.mark = 0;
  SwigClassTagOutOfOrder.destroy = (void (*)(void *)) free_FIX_TagOutOfOrder;
  SwigClassTagOutOfOrder.trackObjects = 0;
  
  SwigClassRepeatedTag.klass = rb_define_class_under(mQuickfix, "RepeatedTag", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RepeatedTag, (void *) &SwigClassRepeatedTag);
  rb_define_alloc_func(SwigClassRepeatedTag.klass, _wrap_RepeatedTag_allocate);
  rb_define_method(SwigClassRepeatedTag.klass, "initialize", VALUEFUNC(_wrap_new_RepeatedTag), -1);
  rb_define_method(SwigClassRepeatedTag.klass, "field=", VALUEFUNC(_wrap_RepeatedTag_field_set), -1);
  rb_define_method(SwigClassRepeatedTag.klass, "field", VALUEFUNC(_wrap_RepeatedTag_field_get), -1);
  SwigClassRepeatedTag.mark = 0;
  SwigClassRepeatedTag.destroy = (void (*)(void *)) free_FIX_RepeatedTag;
  SwigClassRepeatedTag.trackObjects = 0;
  
  SwigClassRepeatingGroupCountMismatch.klass = rb_define_class_under(mQuickfix, "RepeatingGroupCountMismatch", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, (void *) &SwigClassRepeatingGroupCountMismatch);
  rb_define_alloc_func(SwigClassRepeatingGroupCountMismatch.klass, _wrap_RepeatingGroupCountMismatch_allocate);
  rb_define_method(SwigClassRepeatingGroupCountMismatch.klass, "initialize", VALUEFUNC(_wrap_new_RepeatingGroupCountMismatch), -1);
  rb_define_method(SwigClassRepeatingGroupCountMismatch.klass, "field=", VALUEFUNC(_wrap_RepeatingGroupCountMismatch_field_set), -1);
  rb_define_method(SwigClassRepeatingGroupCountMismatch.klass, "field", VALUEFUNC(_wrap_RepeatingGroupCountMismatch_field_get), -1);
  SwigClassRepeatingGroupCountMismatch.mark = 0;
  SwigClassRepeatingGroupCountMismatch.destroy = (void (*)(void *)) free_FIX_RepeatingGroupCountMismatch;
  SwigClassRepeatingGroupCountMismatch.trackObjects = 0;
  
  SwigClassDoNotSend.klass = rb_define_class_under(mQuickfix, "DoNotSend", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DoNotSend, (void *) &SwigClassDoNotSend);
  rb_define_alloc_func(SwigClassDoNotSend.klass, _wrap_DoNotSend_allocate);
  rb_define_method(SwigClassDoNotSend.klass, "initialize", VALUEFUNC(_wrap_new_DoNotSend), -1);
  SwigClassDoNotSend.mark = 0;
  SwigClassDoNotSend.destroy = (void (*)(void *)) free_FIX_DoNotSend;
  SwigClassDoNotSend.trackObjects = 0;
  
  SwigClassRejectLogon.klass = rb_define_class_under(mQuickfix, "RejectLogon", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RejectLogon, (void *) &SwigClassRejectLogon);
  rb_define_alloc_func(SwigClassRejectLogon.klass, _wrap_RejectLogon_allocate);
  rb_define_method(SwigClassRejectLogon.klass, "initialize", VALUEFUNC(_wrap_new_RejectLogon), -1);
  SwigClassRejectLogon.mark = 0;
  SwigClassRejectLogon.destroy = (void (*)(void *)) free_FIX_RejectLogon;
  SwigClassRejectLogon.trackObjects = 0;
  
  SwigClassSessionNotFound.klass = rb_define_class_under(mQuickfix, "SessionNotFound", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionNotFound, (void *) &SwigClassSessionNotFound);
  rb_define_alloc_func(SwigClassSessionNotFound.klass, _wrap_SessionNotFound_allocate);
  rb_define_method(SwigClassSessionNotFound.klass, "initialize", VALUEFUNC(_wrap_new_SessionNotFound), -1);
  SwigClassSessionNotFound.mark = 0;
  SwigClassSessionNotFound.destroy = (void (*)(void *)) free_FIX_SessionNotFound;
  SwigClassSessionNotFound.trackObjects = 0;
  
  SwigClassIOException.klass = rb_define_class_under(mQuickfix, "IOException", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IOException, (void *) &SwigClassIOException);
  rb_define_alloc_func(SwigClassIOException.klass, _wrap_IOException_allocate);
  rb_define_method(SwigClassIOException.klass, "initialize", VALUEFUNC(_wrap_new_IOException), -1);
  SwigClassIOException.mark = 0;
  SwigClassIOException.destroy = (void (*)(void *)) free_FIX_IOException;
  SwigClassIOException.trackObjects = 0;
  
  SwigClassSocketException.klass = rb_define_class_under(mQuickfix, "SocketException", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketException, (void *) &SwigClassSocketException);
  rb_define_alloc_func(SwigClassSocketException.klass, _wrap_SocketException_allocate);
  rb_define_method(SwigClassSocketException.klass, "initialize", VALUEFUNC(_wrap_new_SocketException), -1);
  rb_define_singleton_method(SwigClassSocketException.klass, "errorToWhat", VALUEFUNC(_wrap_SocketException_errorToWhat), -1);
  SwigClassSocketException.mark = 0;
  SwigClassSocketException.destroy = (void (*)(void *)) free_FIX_SocketException;
  SwigClassSocketException.trackObjects = 0;
  
  SwigClassSocketSendFailed.klass = rb_define_class_under(mQuickfix, "SocketSendFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketSendFailed, (void *) &SwigClassSocketSendFailed);
  rb_define_alloc_func(SwigClassSocketSendFailed.klass, _wrap_SocketSendFailed_allocate);
  rb_define_method(SwigClassSocketSendFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketSendFailed), -1);
  SwigClassSocketSendFailed.mark = 0;
  SwigClassSocketSendFailed.destroy = (void (*)(void *)) free_FIX_SocketSendFailed;
  SwigClassSocketSendFailed.trackObjects = 0;
  
  SwigClassSocketRecvFailed.klass = rb_define_class_under(mQuickfix, "SocketRecvFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketRecvFailed, (void *) &SwigClassSocketRecvFailed);
  rb_define_alloc_func(SwigClassSocketRecvFailed.klass, _wrap_SocketRecvFailed_allocate);
  rb_define_method(SwigClassSocketRecvFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketRecvFailed), -1);
  SwigClassSocketRecvFailed.mark = 0;
  SwigClassSocketRecvFailed.destroy = (void (*)(void *)) free_FIX_SocketRecvFailed;
  SwigClassSocketRecvFailed.trackObjects = 0;
  
  SwigClassSocketCloseFailed.klass = rb_define_class_under(mQuickfix, "SocketCloseFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketCloseFailed, (void *) &SwigClassSocketCloseFailed);
  rb_define_alloc_func(SwigClassSocketCloseFailed.klass, _wrap_SocketCloseFailed_allocate);
  rb_define_method(SwigClassSocketCloseFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketCloseFailed), -1);
  SwigClassSocketCloseFailed.mark = 0;
  SwigClassSocketCloseFailed.destroy = (void (*)(void *)) free_FIX_SocketCloseFailed;
  SwigClassSocketCloseFailed.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "PRECISION_FACTOR", VALUEFUNC(_wrap_PRECISION_FACTOR_get), 0);
  
  SwigClassDateTime.klass = rb_define_class_under(mQuickfix, "DateTime", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DateTime, (void *) &SwigClassDateTime);
  rb_define_alloc_func(SwigClassDateTime.klass, _wrap_DateTime_allocate);
  rb_define_method(SwigClassDateTime.klass, "initialize", VALUEFUNC(_wrap_new_DateTime), -1);
  rb_define_method(SwigClassDateTime.klass, "m_date=", VALUEFUNC(_wrap_DateTime_m_date_set), -1);
  rb_define_method(SwigClassDateTime.klass, "m_date", VALUEFUNC(_wrap_DateTime_m_date_get), -1);
  rb_define_method(SwigClassDateTime.klass, "m_time=", VALUEFUNC(_wrap_DateTime_m_time_set), -1);
  rb_define_method(SwigClassDateTime.klass, "m_time", VALUEFUNC(_wrap_DateTime_m_time_get), -1);
  rb_define_method(SwigClassDateTime.klass, "getYear", VALUEFUNC(_wrap_DateTime_getYear), -1);
  rb_define_method(SwigClassDateTime.klass, "getMonth", VALUEFUNC(_wrap_DateTime_getMonth), -1);
  rb_define_method(SwigClassDateTime.klass, "getDay", VALUEFUNC(_wrap_DateTime_getDay), -1);
  rb_define_method(SwigClassDateTime.klass, "getDate", VALUEFUNC(_wrap_DateTime_getDate), -1);
  rb_define_method(SwigClassDateTime.klass, "getJulianDate", VALUEFUNC(_wrap_DateTime_getJulianDate), -1);
  rb_define_method(SwigClassDateTime.klass, "getHour", VALUEFUNC(_wrap_DateTime_getHour), -1);
  rb_define_method(SwigClassDateTime.klass, "getMinute", VALUEFUNC(_wrap_DateTime_getMinute), -1);
  rb_define_method(SwigClassDateTime.klass, "getSecond", VALUEFUNC(_wrap_DateTime_getSecond), -1);
  rb_define_method(SwigClassDateTime.klass, "getMillisecond", VALUEFUNC(_wrap_DateTime_getMillisecond), -1);
  rb_define_method(SwigClassDateTime.klass, "getMicrosecond", VALUEFUNC(_wrap_DateTime_getMicrosecond), -1);
  rb_define_method(SwigClassDateTime.klass, "getNanosecond", VALUEFUNC(_wrap_DateTime_getNanosecond), -1);
  rb_define_method(SwigClassDateTime.klass, "getFraction", VALUEFUNC(_wrap_DateTime_getFraction), -1);
  rb_define_method(SwigClassDateTime.klass, "getWeekDay", VALUEFUNC(_wrap_DateTime_getWeekDay), -1);
  rb_define_method(SwigClassDateTime.klass, "getTimeT", VALUEFUNC(_wrap_DateTime_getTimeT), -1);
  rb_define_method(SwigClassDateTime.klass, "getTmUtc", VALUEFUNC(_wrap_DateTime_getTmUtc), -1);
  rb_define_method(SwigClassDateTime.klass, "setYMD", VALUEFUNC(_wrap_DateTime_setYMD), -1);
  rb_define_method(SwigClassDateTime.klass, "setHMS", VALUEFUNC(_wrap_DateTime_setHMS), -1);
  rb_define_method(SwigClassDateTime.klass, "setHour", VALUEFUNC(_wrap_DateTime_setHour), -1);
  rb_define_method(SwigClassDateTime.klass, "setMinute", VALUEFUNC(_wrap_DateTime_setMinute), -1);
  rb_define_method(SwigClassDateTime.klass, "setSecond", VALUEFUNC(_wrap_DateTime_setSecond), -1);
  rb_define_method(SwigClassDateTime.klass, "setMillisecond", VALUEFUNC(_wrap_DateTime_setMillisecond), -1);
  rb_define_method(SwigClassDateTime.klass, "setMicrosecond", VALUEFUNC(_wrap_DateTime_setMicrosecond), -1);
  rb_define_method(SwigClassDateTime.klass, "setNanosecond", VALUEFUNC(_wrap_DateTime_setNanosecond), -1);
  rb_define_method(SwigClassDateTime.klass, "setFraction", VALUEFUNC(_wrap_DateTime_setFraction), -1);
  rb_define_method(SwigClassDateTime.klass, "clearDate", VALUEFUNC(_wrap_DateTime_clearDate), -1);
  rb_define_method(SwigClassDateTime.klass, "clearTime", VALUEFUNC(_wrap_DateTime_clearTime), -1);
  rb_define_method(SwigClassDateTime.klass, "set", VALUEFUNC(_wrap_DateTime_set), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "convertToNanos", VALUEFUNC(_wrap_DateTime_convertToNanos), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "makeHMS", VALUEFUNC(_wrap_DateTime_makeHMS), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "nowUtc", VALUEFUNC(_wrap_DateTime_nowUtc), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "nowLocal", VALUEFUNC(_wrap_DateTime_nowLocal), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "fromUtcTimeT", VALUEFUNC(_wrap_DateTime_fromUtcTimeT), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "fromLocalTimeT", VALUEFUNC(_wrap_DateTime_fromLocalTimeT), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "fromTm", VALUEFUNC(_wrap_DateTime_fromTm), -1);
  rb_define_singleton_method(SwigClassDateTime.klass, "julianDate", VALUEFUNC(_wrap_DateTime_julianDate), -1);
  SwigClassDateTime.mark = 0;
  SwigClassDateTime.destroy = (void (*)(void *)) free_FIX_DateTime;
  SwigClassDateTime.trackObjects = 0;
  rb_define_module_function(mQuickfix, "-", VALUEFUNC(_wrap___sub__), -1);
  
  SwigClassUtcTimeStamp.klass = rb_define_class_under(mQuickfix, "UtcTimeStamp", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeStamp, (void *) &SwigClassUtcTimeStamp);
  rb_define_alloc_func(SwigClassUtcTimeStamp.klass, _wrap_UtcTimeStamp_allocate);
  rb_define_method(SwigClassUtcTimeStamp.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeStamp), -1);
  rb_define_singleton_method(SwigClassUtcTimeStamp.klass, "now", VALUEFUNC(_wrap_UtcTimeStamp_now), -1);
  rb_define_method(SwigClassUtcTimeStamp.klass, "setCurrent", VALUEFUNC(_wrap_UtcTimeStamp_setCurrent), -1);
  SwigClassUtcTimeStamp.mark = 0;
  SwigClassUtcTimeStamp.destroy = (void (*)(void *)) free_FIX_UtcTimeStamp;
  SwigClassUtcTimeStamp.trackObjects = 0;
  
  SwigClassLocalTimeStamp.klass = rb_define_class_under(mQuickfix, "LocalTimeStamp", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LocalTimeStamp, (void *) &SwigClassLocalTimeStamp);
  rb_define_alloc_func(SwigClassLocalTimeStamp.klass, _wrap_LocalTimeStamp_allocate);
  rb_define_method(SwigClassLocalTimeStamp.klass, "initialize", VALUEFUNC(_wrap_new_LocalTimeStamp), -1);
  rb_define_method(SwigClassLocalTimeStamp.klass, "setCurrent", VALUEFUNC(_wrap_LocalTimeStamp_setCurrent), -1);
  SwigClassLocalTimeStamp.mark = 0;
  SwigClassLocalTimeStamp.destroy = (void (*)(void *)) free_FIX_LocalTimeStamp;
  SwigClassLocalTimeStamp.trackObjects = 0;
  
  SwigClassUtcTimeOnly.klass = rb_define_class_under(mQuickfix, "UtcTimeOnly", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeOnly, (void *) &SwigClassUtcTimeOnly);
  rb_define_alloc_func(SwigClassUtcTimeOnly.klass, _wrap_UtcTimeOnly_allocate);
  rb_define_method(SwigClassUtcTimeOnly.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeOnly), -1);
  rb_define_method(SwigClassUtcTimeOnly.klass, "setCurrent", VALUEFUNC(_wrap_UtcTimeOnly_setCurrent), -1);
  SwigClassUtcTimeOnly.mark = 0;
  SwigClassUtcTimeOnly.destroy = (void (*)(void *)) free_FIX_UtcTimeOnly;
  SwigClassUtcTimeOnly.trackObjects = 0;
  
  SwigClassLocalTimeOnly.klass = rb_define_class_under(mQuickfix, "LocalTimeOnly", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LocalTimeOnly, (void *) &SwigClassLocalTimeOnly);
  rb_define_alloc_func(SwigClassLocalTimeOnly.klass, _wrap_LocalTimeOnly_allocate);
  rb_define_method(SwigClassLocalTimeOnly.klass, "initialize", VALUEFUNC(_wrap_new_LocalTimeOnly), -1);
  rb_define_method(SwigClassLocalTimeOnly.klass, "setCurrent", VALUEFUNC(_wrap_LocalTimeOnly_setCurrent), -1);
  SwigClassLocalTimeOnly.mark = 0;
  SwigClassLocalTimeOnly.destroy = (void (*)(void *)) free_FIX_LocalTimeOnly;
  SwigClassLocalTimeOnly.trackObjects = 0;
  
  SwigClassUtcDate.klass = rb_define_class_under(mQuickfix, "UtcDate", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcDate, (void *) &SwigClassUtcDate);
  rb_define_alloc_func(SwigClassUtcDate.klass, _wrap_UtcDate_allocate);
  rb_define_method(SwigClassUtcDate.klass, "initialize", VALUEFUNC(_wrap_new_UtcDate), -1);
  rb_define_method(SwigClassUtcDate.klass, "setCurrent", VALUEFUNC(_wrap_UtcDate_setCurrent), -1);
  SwigClassUtcDate.mark = 0;
  SwigClassUtcDate.destroy = (void (*)(void *)) free_FIX_UtcDate;
  SwigClassUtcDate.trackObjects = 0;
  
  SwigClassLocalDate.klass = rb_define_class_under(mQuickfix, "LocalDate", ((swig_class *) SWIGTYPE_p_FIX__DateTime->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LocalDate, (void *) &SwigClassLocalDate);
  rb_define_alloc_func(SwigClassLocalDate.klass, _wrap_LocalDate_allocate);
  rb_define_method(SwigClassLocalDate.klass, "initialize", VALUEFUNC(_wrap_new_LocalDate), -1);
  rb_define_method(SwigClassLocalDate.klass, "setCurrent", VALUEFUNC(_wrap_LocalDate_setCurrent), -1);
  SwigClassLocalDate.mark = 0;
  SwigClassLocalDate.destroy = (void (*)(void *)) free_FIX_LocalDate;
  SwigClassLocalDate.trackObjects = 0;
  rb_define_const(mQuickfix, "EnumUnknown", SWIG_From_int(static_cast< int >(FIX::TYPE::Unknown)));
  rb_define_const(mQuickfix, "EnumString", SWIG_From_int(static_cast< int >(FIX::TYPE::String)));
  rb_define_const(mQuickfix, "EnumChar", SWIG_From_int(static_cast< int >(FIX::TYPE::Char)));
  rb_define_const(mQuickfix, "EnumPrice", SWIG_From_int(static_cast< int >(FIX::TYPE::Price)));
  rb_define_const(mQuickfix, "EnumInt", SWIG_From_int(static_cast< int >(FIX::TYPE::Int)));
  rb_define_const(mQuickfix, "EnumAmt", SWIG_From_int(static_cast< int >(FIX::TYPE::Amt)));
  rb_define_const(mQuickfix, "EnumQty", SWIG_From_int(static_cast< int >(FIX::TYPE::Qty)));
  rb_define_const(mQuickfix, "EnumCurrency", SWIG_From_int(static_cast< int >(FIX::TYPE::Currency)));
  rb_define_const(mQuickfix, "EnumMultipleValueString", SWIG_From_int(static_cast< int >(FIX::TYPE::MultipleValueString)));
  rb_define_const(mQuickfix, "EnumMultipleStringValue", SWIG_From_int(static_cast< int >(FIX::TYPE::MultipleStringValue)));
  rb_define_const(mQuickfix, "EnumMultipleCharValue", SWIG_From_int(static_cast< int >(FIX::TYPE::MultipleCharValue)));
  rb_define_const(mQuickfix, "EnumExchange", SWIG_From_int(static_cast< int >(FIX::TYPE::Exchange)));
  rb_define_const(mQuickfix, "EnumUtcTimeStamp", SWIG_From_int(static_cast< int >(FIX::TYPE::UtcTimeStamp)));
  rb_define_const(mQuickfix, "EnumBoolean", SWIG_From_int(static_cast< int >(FIX::TYPE::Boolean)));
  rb_define_const(mQuickfix, "EnumLocalMktTime", SWIG_From_int(static_cast< int >(FIX::TYPE::LocalMktTime)));
  rb_define_const(mQuickfix, "EnumLocalMktDate", SWIG_From_int(static_cast< int >(FIX::TYPE::LocalMktDate)));
  rb_define_const(mQuickfix, "EnumData", SWIG_From_int(static_cast< int >(FIX::TYPE::Data)));
  rb_define_const(mQuickfix, "EnumFloat", SWIG_From_int(static_cast< int >(FIX::TYPE::Float)));
  rb_define_const(mQuickfix, "EnumPriceOffset", SWIG_From_int(static_cast< int >(FIX::TYPE::PriceOffset)));
  rb_define_const(mQuickfix, "EnumMonthYear", SWIG_From_int(static_cast< int >(FIX::TYPE::MonthYear)));
  rb_define_const(mQuickfix, "EnumDayOfMonth", SWIG_From_int(static_cast< int >(FIX::TYPE::DayOfMonth)));
  rb_define_const(mQuickfix, "EnumUtcDate", SWIG_From_int(static_cast< int >(FIX::TYPE::UtcDate)));
  rb_define_const(mQuickfix, "EnumUtcDateOnly", SWIG_From_int(static_cast< int >(FIX::TYPE::UtcDateOnly)));
  rb_define_const(mQuickfix, "EnumUtcTimeOnly", SWIG_From_int(static_cast< int >(FIX::TYPE::UtcTimeOnly)));
  rb_define_const(mQuickfix, "EnumNumInGroup", SWIG_From_int(static_cast< int >(FIX::TYPE::NumInGroup)));
  rb_define_const(mQuickfix, "EnumPercentage", SWIG_From_int(static_cast< int >(FIX::TYPE::Percentage)));
  rb_define_const(mQuickfix, "EnumSeqNum", SWIG_From_int(static_cast< int >(FIX::TYPE::SeqNum)));
  rb_define_const(mQuickfix, "EnumTagNum", SWIG_From_int(static_cast< int >(FIX::TYPE::TagNum)));
  rb_define_const(mQuickfix, "EnumLength", SWIG_From_int(static_cast< int >(FIX::TYPE::Length)));
  rb_define_const(mQuickfix, "EnumCountry", SWIG_From_int(static_cast< int >(FIX::TYPE::Country)));
  rb_define_const(mQuickfix, "EnumTzTimeOnly", SWIG_From_int(static_cast< int >(FIX::TYPE::TzTimeOnly)));
  rb_define_const(mQuickfix, "EnumTzTimeStamp", SWIG_From_int(static_cast< int >(FIX::TYPE::TzTimeStamp)));
  rb_define_const(mQuickfix, "EnumXmlData", SWIG_From_int(static_cast< int >(FIX::TYPE::XmlData)));
  rb_define_const(mQuickfix, "EnumLanguage", SWIG_From_int(static_cast< int >(FIX::TYPE::Language)));
  rb_define_const(mQuickfix, "EnumXid", SWIG_From_int(static_cast< int >(FIX::TYPE::Xid)));
  rb_define_const(mQuickfix, "EnumXidRef", SWIG_From_int(static_cast< int >(FIX::TYPE::XidRef)));
  
  SwigClassFieldBase.klass = rb_define_class_under(mQuickfix, "FieldBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldBase, (void *) &SwigClassFieldBase);
  rb_define_alloc_func(SwigClassFieldBase.klass, _wrap_FieldBase_allocate);
  rb_define_method(SwigClassFieldBase.klass, "initialize", VALUEFUNC(_wrap_new_FieldBase), -1);
  rb_define_method(SwigClassFieldBase.klass, "swap", VALUEFUNC(_wrap_FieldBase_swap), -1);
  rb_define_method(SwigClassFieldBase.klass, "setTag", VALUEFUNC(_wrap_FieldBase_setTag), -1);
  rb_define_method(SwigClassFieldBase.klass, "setField", VALUEFUNC(_wrap_FieldBase_setField), -1);
  rb_define_method(SwigClassFieldBase.klass, "setString", VALUEFUNC(_wrap_FieldBase_setString), -1);
  rb_define_method(SwigClassFieldBase.klass, "getTag", VALUEFUNC(_wrap_FieldBase_getTag), -1);
  rb_define_method(SwigClassFieldBase.klass, "getField", VALUEFUNC(_wrap_FieldBase_getField), -1);
  rb_define_method(SwigClassFieldBase.klass, "getString", VALUEFUNC(_wrap_FieldBase_getString), -1);
  rb_define_method(SwigClassFieldBase.klass, "getFixString", VALUEFUNC(_wrap_FieldBase_getFixString), -1);
  rb_define_method(SwigClassFieldBase.klass, "getLength", VALUEFUNC(_wrap_FieldBase_getLength), -1);
  rb_define_method(SwigClassFieldBase.klass, "getTotal", VALUEFUNC(_wrap_FieldBase_getTotal), -1);
  rb_define_method(SwigClassFieldBase.klass, "<", VALUEFUNC(_wrap_FieldBase___lt__), -1);
  rb_define_method(SwigClassFieldBase.klass, "to_s", VALUEFUNC(_wrap_FieldBase___str__), -1);
  SwigClassFieldBase.mark = 0;
  SwigClassFieldBase.destroy = (void (*)(void *)) free_FIX_FieldBase;
  SwigClassFieldBase.trackObjects = 0;
  rb_define_module_function(mQuickfix, "swap", VALUEFUNC(_wrap_swap), -1);
  
  SwigClassStringField.klass = rb_define_class_under(mQuickfix, "StringField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__StringField, (void *) &SwigClassStringField);
  rb_define_alloc_func(SwigClassStringField.klass, _wrap_StringField_allocate);
  rb_define_method(SwigClassStringField.klass, "initialize", VALUEFUNC(_wrap_new_StringField), -1);
  rb_define_method(SwigClassStringField.klass, "setValue", VALUEFUNC(_wrap_StringField_setValue), -1);
  rb_define_method(SwigClassStringField.klass, "getValue", VALUEFUNC(_wrap_StringField_getValue), -1);
  rb_define_method(SwigClassStringField.klass, "<", VALUEFUNC(_wrap_StringField___lt__), -1);
  rb_define_method(SwigClassStringField.klass, ">", VALUEFUNC(_wrap_StringField___gt__), -1);
  rb_define_method(SwigClassStringField.klass, "==", VALUEFUNC(_wrap_StringField___eq__), -1);
  rb_define_method(SwigClassStringField.klass, "<=", VALUEFUNC(_wrap_StringField___le__), -1);
  rb_define_method(SwigClassStringField.klass, ">=", VALUEFUNC(_wrap_StringField___ge__), -1);
  SwigClassStringField.mark = 0;
  SwigClassStringField.destroy = (void (*)(void *)) free_FIX_StringField;
  SwigClassStringField.trackObjects = 0;
  rb_define_module_function(mQuickfix, ">", VALUEFUNC(_wrap___gt__), -1);
  rb_define_module_function(mQuickfix, "<=", VALUEFUNC(_wrap___le__), -1);
  rb_define_module_function(mQuickfix, ">=", VALUEFUNC(_wrap___ge__), -1);
  
  SwigClassCharField.klass = rb_define_class_under(mQuickfix, "CharField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CharField, (void *) &SwigClassCharField);
  rb_define_alloc_func(SwigClassCharField.klass, _wrap_CharField_allocate);
  rb_define_method(SwigClassCharField.klass, "initialize", VALUEFUNC(_wrap_new_CharField), -1);
  rb_define_method(SwigClassCharField.klass, "setValue", VALUEFUNC(_wrap_CharField_setValue), -1);
  rb_define_method(SwigClassCharField.klass, "getValue", VALUEFUNC(_wrap_CharField_getValue), -1);
  SwigClassCharField.mark = 0;
  SwigClassCharField.destroy = (void (*)(void *)) free_FIX_CharField;
  SwigClassCharField.trackObjects = 0;
  
  SwigClassDoubleField.klass = rb_define_class_under(mQuickfix, "DoubleField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DoubleField, (void *) &SwigClassDoubleField);
  rb_define_alloc_func(SwigClassDoubleField.klass, _wrap_DoubleField_allocate);
  rb_define_method(SwigClassDoubleField.klass, "initialize", VALUEFUNC(_wrap_new_DoubleField), -1);
  rb_define_method(SwigClassDoubleField.klass, "setValue", VALUEFUNC(_wrap_DoubleField_setValue), -1);
  rb_define_method(SwigClassDoubleField.klass, "getValue", VALUEFUNC(_wrap_DoubleField_getValue), -1);
  SwigClassDoubleField.mark = 0;
  SwigClassDoubleField.destroy = (void (*)(void *)) free_FIX_DoubleField;
  SwigClassDoubleField.trackObjects = 0;
  
  SwigClassIntField.klass = rb_define_class_under(mQuickfix, "IntField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IntField, (void *) &SwigClassIntField);
  rb_define_alloc_func(SwigClassIntField.klass, _wrap_IntField_allocate);
  rb_define_method(SwigClassIntField.klass, "initialize", VALUEFUNC(_wrap_new_IntField), -1);
  rb_define_method(SwigClassIntField.klass, "setValue", VALUEFUNC(_wrap_IntField_setValue), -1);
  rb_define_method(SwigClassIntField.klass, "getValue", VALUEFUNC(_wrap_IntField_getValue), -1);
  SwigClassIntField.mark = 0;
  SwigClassIntField.destroy = (void (*)(void *)) free_FIX_IntField;
  SwigClassIntField.trackObjects = 0;
  
  SwigClassBoolField.klass = rb_define_class_under(mQuickfix, "BoolField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__BoolField, (void *) &SwigClassBoolField);
  rb_define_alloc_func(SwigClassBoolField.klass, _wrap_BoolField_allocate);
  rb_define_method(SwigClassBoolField.klass, "initialize", VALUEFUNC(_wrap_new_BoolField), -1);
  rb_define_method(SwigClassBoolField.klass, "setValue", VALUEFUNC(_wrap_BoolField_setValue), -1);
  rb_define_method(SwigClassBoolField.klass, "getValue", VALUEFUNC(_wrap_BoolField_getValue), -1);
  SwigClassBoolField.mark = 0;
  SwigClassBoolField.destroy = (void (*)(void *)) free_FIX_BoolField;
  SwigClassBoolField.trackObjects = 0;
  
  SwigClassUtcTimeStampField.klass = rb_define_class_under(mQuickfix, "UtcTimeStampField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeStampField, (void *) &SwigClassUtcTimeStampField);
  rb_define_alloc_func(SwigClassUtcTimeStampField.klass, _wrap_UtcTimeStampField_allocate);
  rb_define_method(SwigClassUtcTimeStampField.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeStampField), -1);
  rb_define_method(SwigClassUtcTimeStampField.klass, "setValue", VALUEFUNC(_wrap_UtcTimeStampField_setValue), -1);
  rb_define_method(SwigClassUtcTimeStampField.klass, "getValue", VALUEFUNC(_wrap_UtcTimeStampField_getValue), -1);
  rb_define_method(SwigClassUtcTimeStampField.klass, "<", VALUEFUNC(_wrap_UtcTimeStampField___lt__), -1);
  rb_define_method(SwigClassUtcTimeStampField.klass, "==", VALUEFUNC(_wrap_UtcTimeStampField___eq__), -1);
  SwigClassUtcTimeStampField.mark = 0;
  SwigClassUtcTimeStampField.destroy = (void (*)(void *)) free_FIX_UtcTimeStampField;
  SwigClassUtcTimeStampField.trackObjects = 0;
  
  SwigClassUtcDateField.klass = rb_define_class_under(mQuickfix, "UtcDateField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcDateField, (void *) &SwigClassUtcDateField);
  rb_define_alloc_func(SwigClassUtcDateField.klass, _wrap_UtcDateField_allocate);
  rb_define_method(SwigClassUtcDateField.klass, "initialize", VALUEFUNC(_wrap_new_UtcDateField), -1);
  rb_define_method(SwigClassUtcDateField.klass, "setValue", VALUEFUNC(_wrap_UtcDateField_setValue), -1);
  rb_define_method(SwigClassUtcDateField.klass, "getValue", VALUEFUNC(_wrap_UtcDateField_getValue), -1);
  rb_define_method(SwigClassUtcDateField.klass, "<", VALUEFUNC(_wrap_UtcDateField___lt__), -1);
  rb_define_method(SwigClassUtcDateField.klass, "==", VALUEFUNC(_wrap_UtcDateField___eq__), -1);
  SwigClassUtcDateField.mark = 0;
  SwigClassUtcDateField.destroy = (void (*)(void *)) free_FIX_UtcDateField;
  SwigClassUtcDateField.trackObjects = 0;
  
  SwigClassUtcTimeOnlyField.klass = rb_define_class_under(mQuickfix, "UtcTimeOnlyField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeOnlyField, (void *) &SwigClassUtcTimeOnlyField);
  rb_define_alloc_func(SwigClassUtcTimeOnlyField.klass, _wrap_UtcTimeOnlyField_allocate);
  rb_define_method(SwigClassUtcTimeOnlyField.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeOnlyField), -1);
  rb_define_method(SwigClassUtcTimeOnlyField.klass, "setValue", VALUEFUNC(_wrap_UtcTimeOnlyField_setValue), -1);
  rb_define_method(SwigClassUtcTimeOnlyField.klass, "getValue", VALUEFUNC(_wrap_UtcTimeOnlyField_getValue), -1);
  rb_define_method(SwigClassUtcTimeOnlyField.klass, "<", VALUEFUNC(_wrap_UtcTimeOnlyField___lt__), -1);
  rb_define_method(SwigClassUtcTimeOnlyField.klass, "==", VALUEFUNC(_wrap_UtcTimeOnlyField___eq__), -1);
  SwigClassUtcTimeOnlyField.mark = 0;
  SwigClassUtcTimeOnlyField.destroy = (void (*)(void *)) free_FIX_UtcTimeOnlyField;
  SwigClassUtcTimeOnlyField.trackObjects = 0;
  
  SwigClassCheckSumField.klass = rb_define_class_under(mQuickfix, "CheckSumField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CheckSumField, (void *) &SwigClassCheckSumField);
  rb_define_alloc_func(SwigClassCheckSumField.klass, _wrap_CheckSumField_allocate);
  rb_define_method(SwigClassCheckSumField.klass, "initialize", VALUEFUNC(_wrap_new_CheckSumField), -1);
  rb_define_method(SwigClassCheckSumField.klass, "setValue", VALUEFUNC(_wrap_CheckSumField_setValue), -1);
  rb_define_method(SwigClassCheckSumField.klass, "getValue", VALUEFUNC(_wrap_CheckSumField_getValue), -1);
  SwigClassCheckSumField.mark = 0;
  SwigClassCheckSumField.destroy = (void (*)(void *)) free_FIX_CheckSumField;
  SwigClassCheckSumField.trackObjects = 0;
  
  SwigClassFieldMap.klass = rb_define_class_under(mQuickfix, "FieldMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldMap, (void *) &SwigClassFieldMap);
  rb_define_alloc_func(SwigClassFieldMap.klass, _wrap_FieldMap_allocate);
  rb_define_method(SwigClassFieldMap.klass, "initialize", VALUEFUNC(_wrap_new_FieldMap), -1);
  rb_define_method(SwigClassFieldMap.klass, "setField", VALUEFUNC(_wrap_FieldMap_setField), -1);
  rb_define_method(SwigClassFieldMap.klass, "getFieldIfSet", VALUEFUNC(_wrap_FieldMap_getFieldIfSet), -1);
  rb_define_method(SwigClassFieldMap.klass, "getField", VALUEFUNC(_wrap_FieldMap_getField), -1);
  rb_define_method(SwigClassFieldMap.klass, "getFieldRef", VALUEFUNC(_wrap_FieldMap_getFieldRef), -1);
  rb_define_method(SwigClassFieldMap.klass, "getFieldPtr", VALUEFUNC(_wrap_FieldMap_getFieldPtr), -1);
  rb_define_method(SwigClassFieldMap.klass, "isSetField", VALUEFUNC(_wrap_FieldMap_isSetField), -1);
  rb_define_method(SwigClassFieldMap.klass, "removeField", VALUEFUNC(_wrap_FieldMap_removeField), -1);
  rb_define_method(SwigClassFieldMap.klass, "addGroup", VALUEFUNC(_wrap_FieldMap_addGroup), -1);
  rb_define_method(SwigClassFieldMap.klass, "addGroupPtr", VALUEFUNC(_wrap_FieldMap_addGroupPtr), -1);
  rb_define_method(SwigClassFieldMap.klass, "replaceGroup", VALUEFUNC(_wrap_FieldMap_replaceGroup), -1);
  rb_define_method(SwigClassFieldMap.klass, "getGroup", VALUEFUNC(_wrap_FieldMap_getGroup), -1);
  rb_define_method(SwigClassFieldMap.klass, "getGroupRef", VALUEFUNC(_wrap_FieldMap_getGroupRef), -1);
  rb_define_method(SwigClassFieldMap.klass, "getGroupPtr", VALUEFUNC(_wrap_FieldMap_getGroupPtr), -1);
  rb_define_method(SwigClassFieldMap.klass, "groups", VALUEFUNC(_wrap_FieldMap_groups), -1);
  rb_define_method(SwigClassFieldMap.klass, "removeGroup", VALUEFUNC(_wrap_FieldMap_removeGroup), -1);
  rb_define_method(SwigClassFieldMap.klass, "hasGroup", VALUEFUNC(_wrap_FieldMap_hasGroup), -1);
  rb_define_method(SwigClassFieldMap.klass, "groupCount", VALUEFUNC(_wrap_FieldMap_groupCount), -1);
  rb_define_method(SwigClassFieldMap.klass, "clear", VALUEFUNC(_wrap_FieldMap_clear), -1);
  rb_define_method(SwigClassFieldMap.klass, "isEmpty", VALUEFUNC(_wrap_FieldMap_isEmpty), -1);
  rb_define_method(SwigClassFieldMap.klass, "totalFields", VALUEFUNC(_wrap_FieldMap_totalFields), -1);
  rb_define_method(SwigClassFieldMap.klass, "calculateString", VALUEFUNC(_wrap_FieldMap_calculateString), -1);
  rb_define_method(SwigClassFieldMap.klass, "calculateLength", VALUEFUNC(_wrap_FieldMap_calculateLength), -1);
  rb_define_method(SwigClassFieldMap.klass, "calculateTotal", VALUEFUNC(_wrap_FieldMap_calculateTotal), -1);
  rb_define_method(SwigClassFieldMap.klass, "begin", VALUEFUNC(_wrap_FieldMap_begin), -1);
  rb_define_method(SwigClassFieldMap.klass, "end", VALUEFUNC(_wrap_FieldMap_end), -1);
  rb_define_method(SwigClassFieldMap.klass, "g_begin", VALUEFUNC(_wrap_FieldMap_g_begin), -1);
  rb_define_method(SwigClassFieldMap.klass, "g_end", VALUEFUNC(_wrap_FieldMap_g_end), -1);
  SwigClassFieldMap.mark = 0;
  SwigClassFieldMap.destroy = (void (*)(void *)) free_FIX_FieldMap;
  SwigClassFieldMap.trackObjects = 0;
  
  SwigClassHeader.klass = rb_define_class_under(mQuickfix, "Header", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Header, (void *) &SwigClassHeader);
  rb_define_alloc_func(SwigClassHeader.klass, _wrap_Header_allocate);
  rb_define_method(SwigClassHeader.klass, "initialize", VALUEFUNC(_wrap_new_Header), -1);
  rb_define_method(SwigClassHeader.klass, "addGroup", VALUEFUNC(_wrap_Header_addGroup), -1);
  rb_define_method(SwigClassHeader.klass, "replaceGroup", VALUEFUNC(_wrap_Header_replaceGroup), -1);
  rb_define_method(SwigClassHeader.klass, "getGroup", VALUEFUNC(_wrap_Header_getGroup), -1);
  rb_define_method(SwigClassHeader.klass, "removeGroup", VALUEFUNC(_wrap_Header_removeGroup), -1);
  rb_define_method(SwigClassHeader.klass, "hasGroup", VALUEFUNC(_wrap_Header_hasGroup), -1);
  SwigClassHeader.mark = 0;
  SwigClassHeader.destroy = (void (*)(void *)) free_FIX_Header;
  SwigClassHeader.trackObjects = 0;
  
  SwigClassTrailer.klass = rb_define_class_under(mQuickfix, "Trailer", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Trailer, (void *) &SwigClassTrailer);
  rb_define_alloc_func(SwigClassTrailer.klass, _wrap_Trailer_allocate);
  rb_define_method(SwigClassTrailer.klass, "initialize", VALUEFUNC(_wrap_new_Trailer), -1);
  rb_define_method(SwigClassTrailer.klass, "addGroup", VALUEFUNC(_wrap_Trailer_addGroup), -1);
  rb_define_method(SwigClassTrailer.klass, "replaceGroup", VALUEFUNC(_wrap_Trailer_replaceGroup), -1);
  rb_define_method(SwigClassTrailer.klass, "getGroup", VALUEFUNC(_wrap_Trailer_getGroup), -1);
  rb_define_method(SwigClassTrailer.klass, "removeGroup", VALUEFUNC(_wrap_Trailer_removeGroup), -1);
  rb_define_method(SwigClassTrailer.klass, "hasGroup", VALUEFUNC(_wrap_Trailer_hasGroup), -1);
  SwigClassTrailer.mark = 0;
  SwigClassTrailer.destroy = (void (*)(void *)) free_FIX_Trailer;
  SwigClassTrailer.trackObjects = 0;
  
  SwigClassMessage.klass = rb_define_class_under(mQuickfix, "Message", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Message, (void *) &SwigClassMessage);
  rb_define_alloc_func(SwigClassMessage.klass, _wrap_Message_allocate);
  rb_define_method(SwigClassMessage.klass, "initialize", VALUEFUNC(_wrap_new_Message), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "InitializeXML", VALUEFUNC(_wrap_Message_InitializeXML), -1);
  rb_define_method(SwigClassMessage.klass, "addGroup", VALUEFUNC(_wrap_Message_addGroup), -1);
  rb_define_method(SwigClassMessage.klass, "replaceGroup", VALUEFUNC(_wrap_Message_replaceGroup), -1);
  rb_define_method(SwigClassMessage.klass, "getGroup", VALUEFUNC(_wrap_Message_getGroup), -1);
  rb_define_method(SwigClassMessage.klass, "removeGroup", VALUEFUNC(_wrap_Message_removeGroup), -1);
  rb_define_method(SwigClassMessage.klass, "hasGroup", VALUEFUNC(_wrap_Message_hasGroup), -1);
  rb_define_method(SwigClassMessage.klass, "toString", VALUEFUNC(_wrap_Message_toString), -1);
  rb_define_method(SwigClassMessage.klass, "toXML", VALUEFUNC(_wrap_Message_toXML), -1);
  rb_define_method(SwigClassMessage.klass, "reverseRoute", VALUEFUNC(_wrap_Message_reverseRoute), -1);
  rb_define_method(SwigClassMessage.klass, "setString", VALUEFUNC(_wrap_Message_setString), -1);
  rb_define_method(SwigClassMessage.klass, "setGroup", VALUEFUNC(_wrap_Message_setGroup), -1);
  rb_define_method(SwigClassMessage.klass, "setStringHeader", VALUEFUNC(_wrap_Message_setStringHeader), -1);
  rb_define_method(SwigClassMessage.klass, "getHeader", VALUEFUNC(_wrap_Message_getHeader), -1);
  rb_define_method(SwigClassMessage.klass, "getTrailer", VALUEFUNC(_wrap_Message_getTrailer), -1);
  rb_define_method(SwigClassMessage.klass, "hasValidStructure", VALUEFUNC(_wrap_Message_hasValidStructure), -1);
  rb_define_method(SwigClassMessage.klass, "bodyLength", VALUEFUNC(_wrap_Message_bodyLength), -1);
  rb_define_method(SwigClassMessage.klass, "checkSum", VALUEFUNC(_wrap_Message_checkSum), -1);
  rb_define_method(SwigClassMessage.klass, "isAdmin", VALUEFUNC(_wrap_Message_isAdmin), -1);
  rb_define_method(SwigClassMessage.klass, "isApp", VALUEFUNC(_wrap_Message_isApp), -1);
  rb_define_method(SwigClassMessage.klass, "isEmpty", VALUEFUNC(_wrap_Message_isEmpty), -1);
  rb_define_method(SwigClassMessage.klass, "clear", VALUEFUNC(_wrap_Message_clear), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "isAdminMsgType", VALUEFUNC(_wrap_Message_isAdminMsgType), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "toApplVerID", VALUEFUNC(_wrap_Message_toApplVerID), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "toBeginString", VALUEFUNC(_wrap_Message_toBeginString), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "isHeaderField", VALUEFUNC(_wrap_Message_isHeaderField), -1);
  rb_define_singleton_method(SwigClassMessage.klass, "isTrailerField", VALUEFUNC(_wrap_Message_isTrailerField), -1);
  rb_define_method(SwigClassMessage.klass, "getSessionID", VALUEFUNC(_wrap_Message_getSessionID), -1);
  rb_define_method(SwigClassMessage.klass, "setSessionID", VALUEFUNC(_wrap_Message_setSessionID), -1);
  rb_define_method(SwigClassMessage.klass, "to_s", VALUEFUNC(_wrap_Message___str__), -1);
  SwigClassMessage.mark = 0;
  SwigClassMessage.destroy = (void (*)(void *)) free_FIX_Message;
  SwigClassMessage.trackObjects = 0;
  rb_define_module_function(mQuickfix, "identifyType", VALUEFUNC(_wrap_identifyType), -1);
  
  SwigClassGroup.klass = rb_define_class_under(mQuickfix, "Group", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Group, (void *) &SwigClassGroup);
  rb_define_alloc_func(SwigClassGroup.klass, _wrap_Group_allocate);
  rb_define_method(SwigClassGroup.klass, "initialize", VALUEFUNC(_wrap_new_Group), -1);
  rb_define_method(SwigClassGroup.klass, "field", VALUEFUNC(_wrap_Group_field), -1);
  rb_define_method(SwigClassGroup.klass, "delim", VALUEFUNC(_wrap_Group_delim), -1);
  rb_define_method(SwigClassGroup.klass, "addGroup", VALUEFUNC(_wrap_Group_addGroup), -1);
  rb_define_method(SwigClassGroup.klass, "replaceGroup", VALUEFUNC(_wrap_Group_replaceGroup), -1);
  rb_define_method(SwigClassGroup.klass, "getGroup", VALUEFUNC(_wrap_Group_getGroup), -1);
  rb_define_method(SwigClassGroup.klass, "removeGroup", VALUEFUNC(_wrap_Group_removeGroup), -1);
  rb_define_method(SwigClassGroup.klass, "hasGroup", VALUEFUNC(_wrap_Group_hasGroup), -1);
  SwigClassGroup.mark = 0;
  SwigClassGroup.destroy = (void (*)(void *)) free_FIX_Group;
  SwigClassGroup.trackObjects = 0;
  
  SwigClassBeginString.klass = rb_define_class_under(mQuickfix, "BeginString", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__BeginString, (void *) &SwigClassBeginString);
  rb_define_alloc_func(SwigClassBeginString.klass, _wrap_BeginString_allocate);
  rb_define_method(SwigClassBeginString.klass, "initialize", VALUEFUNC(_wrap_new_BeginString), -1);
  rb_define_const(SwigClassBeginString.klass, "Tag", SWIG_From_int(static_cast< int >(FIX::BeginString::tag)));
  SwigClassBeginString.mark = 0;
  SwigClassBeginString.destroy = (void (*)(void *)) free_FIX_BeginString;
  SwigClassBeginString.trackObjects = 0;
  
  SwigClassSenderCompID.klass = rb_define_class_under(mQuickfix, "SenderCompID", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SenderCompID, (void *) &SwigClassSenderCompID);
  rb_define_alloc_func(SwigClassSenderCompID.klass, _wrap_SenderCompID_allocate);
  rb_define_method(SwigClassSenderCompID.klass, "initialize", VALUEFUNC(_wrap_new_SenderCompID), -1);
  rb_define_const(SwigClassSenderCompID.klass, "Tag", SWIG_From_int(static_cast< int >(FIX::SenderCompID::tag)));
  SwigClassSenderCompID.mark = 0;
  SwigClassSenderCompID.destroy = (void (*)(void *)) free_FIX_SenderCompID;
  SwigClassSenderCompID.trackObjects = 0;
  
  SwigClassTargetCompID.klass = rb_define_class_under(mQuickfix, "TargetCompID", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TargetCompID, (void *) &SwigClassTargetCompID);
  rb_define_alloc_func(SwigClassTargetCompID.klass, _wrap_TargetCompID_allocate);
  rb_define_method(SwigClassTargetCompID.klass, "initialize", VALUEFUNC(_wrap_new_TargetCompID), -1);
  rb_define_const(SwigClassTargetCompID.klass, "Tag", SWIG_From_int(static_cast< int >(FIX::TargetCompID::tag)));
  SwigClassTargetCompID.mark = 0;
  SwigClassTargetCompID.destroy = (void (*)(void *)) free_FIX_TargetCompID;
  SwigClassTargetCompID.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "BeginString_FIXT11", VALUEFUNC(_wrap_BeginString_FIXT11_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX50", VALUEFUNC(_wrap_BeginString_FIX50_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX44", VALUEFUNC(_wrap_BeginString_FIX44_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX43", VALUEFUNC(_wrap_BeginString_FIX43_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX42", VALUEFUNC(_wrap_BeginString_FIX42_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX41", VALUEFUNC(_wrap_BeginString_FIX41_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX40", VALUEFUNC(_wrap_BeginString_FIX40_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_TAG_NUMBER_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INVALID_TAG_NUMBER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REQUIRED_TAG_MISSING_TEXT", VALUEFUNC(_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_UNDEFINED_TAG_TEXT", VALUEFUNC(_wrap_SessionRejectReason_UNDEFINED_TAG_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_VALUE_IS_INCORRECT_TEXT", VALUEFUNC(_wrap_SessionRejectReason_VALUE_IS_INCORRECT_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_DECRYPTION_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_DECRYPTION_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SIGNATURE_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_SIGNATURE_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_COMPID_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_COMPID_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_MSGTYPE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INVALID_MSGTYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_OTHER_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_OTHER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_ID_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_ID_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_SECURITY_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_SECURITY_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_NOT_AUTHORIZED_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_NOT_AUTHORIZED_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Heartbeat", VALUEFUNC(_wrap_MsgType_Heartbeat_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TestRequest", VALUEFUNC(_wrap_MsgType_TestRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ResendRequest", VALUEFUNC(_wrap_MsgType_ResendRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Reject", VALUEFUNC(_wrap_MsgType_Reject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SequenceReset", VALUEFUNC(_wrap_MsgType_SequenceReset_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Logout", VALUEFUNC(_wrap_MsgType_Logout_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Logon", VALUEFUNC(_wrap_MsgType_Logon_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_XMLnonFIX", VALUEFUNC(_wrap_MsgType_XMLnonFIX_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_IOI", VALUEFUNC(_wrap_MsgType_IOI_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Advertisement", VALUEFUNC(_wrap_MsgType_Advertisement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ExecutionReport", VALUEFUNC(_wrap_MsgType_ExecutionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelReject", VALUEFUNC(_wrap_MsgType_OrderCancelReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_News", VALUEFUNC(_wrap_MsgType_News_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Email", VALUEFUNC(_wrap_MsgType_Email_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderSingle", VALUEFUNC(_wrap_MsgType_NewOrderSingle_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderList", VALUEFUNC(_wrap_MsgType_NewOrderList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelRequest", VALUEFUNC(_wrap_MsgType_OrderCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_OrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderStatusRequest", VALUEFUNC(_wrap_MsgType_OrderStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Allocation", VALUEFUNC(_wrap_MsgType_Allocation_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListCancelRequest", VALUEFUNC(_wrap_MsgType_ListCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListExecute", VALUEFUNC(_wrap_MsgType_ListExecute_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStatusRequest", VALUEFUNC(_wrap_MsgType_ListStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStatus", VALUEFUNC(_wrap_MsgType_ListStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstructionAck", VALUEFUNC(_wrap_MsgType_AllocationInstructionAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DontKnowTrade", VALUEFUNC(_wrap_MsgType_DontKnowTrade_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteRequest", VALUEFUNC(_wrap_MsgType_QuoteRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Quote", VALUEFUNC(_wrap_MsgType_Quote_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SettlementInstructions", VALUEFUNC(_wrap_MsgType_SettlementInstructions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataRequest", VALUEFUNC(_wrap_MsgType_MarketDataRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataSnapshotFullRefresh", VALUEFUNC(_wrap_MsgType_MarketDataSnapshotFullRefresh_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataIncrementalRefresh", VALUEFUNC(_wrap_MsgType_MarketDataIncrementalRefresh_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataRequestReject", VALUEFUNC(_wrap_MsgType_MarketDataRequestReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteCancel", VALUEFUNC(_wrap_MsgType_QuoteCancel_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteStatusRequest", VALUEFUNC(_wrap_MsgType_QuoteStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteAcknowledgement", VALUEFUNC(_wrap_MsgType_QuoteAcknowledgement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityDefinitionRequest", VALUEFUNC(_wrap_MsgType_SecurityDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityDefinition", VALUEFUNC(_wrap_MsgType_SecurityDefinition_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityStatusRequest", VALUEFUNC(_wrap_MsgType_SecurityStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityStatus", VALUEFUNC(_wrap_MsgType_SecurityStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionStatusRequest", VALUEFUNC(_wrap_MsgType_TradingSessionStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionStatus", VALUEFUNC(_wrap_MsgType_TradingSessionStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassQuote", VALUEFUNC(_wrap_MsgType_MassQuote_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BusinessMessageReject", VALUEFUNC(_wrap_MsgType_BusinessMessageReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BidRequest", VALUEFUNC(_wrap_MsgType_BidRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BidResponse", VALUEFUNC(_wrap_MsgType_BidResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStrikePrice", VALUEFUNC(_wrap_MsgType_ListStrikePrice_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationAck", VALUEFUNC(_wrap_MsgType_AllocationAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassQuoteAcknowledgement", VALUEFUNC(_wrap_MsgType_MassQuoteAcknowledgement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RegistrationInstructions", VALUEFUNC(_wrap_MsgType_RegistrationInstructions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RegistrationInstructionsResponse", VALUEFUNC(_wrap_MsgType_RegistrationInstructionsResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassCancelRequest", VALUEFUNC(_wrap_MsgType_OrderMassCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassCancelReport", VALUEFUNC(_wrap_MsgType_OrderMassCancelReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderCross", VALUEFUNC(_wrap_MsgType_NewOrderCross_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossOrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_CrossOrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossOrderCancelRequest", VALUEFUNC(_wrap_MsgType_CrossOrderCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityTypeRequest", VALUEFUNC(_wrap_MsgType_SecurityTypeRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityTypes", VALUEFUNC(_wrap_MsgType_SecurityTypes_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityListRequest", VALUEFUNC(_wrap_MsgType_SecurityListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityList", VALUEFUNC(_wrap_MsgType_SecurityList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DerivativeSecurityListRequest", VALUEFUNC(_wrap_MsgType_DerivativeSecurityListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DerivativeSecurityList", VALUEFUNC(_wrap_MsgType_DerivativeSecurityList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderMultileg", VALUEFUNC(_wrap_MsgType_NewOrderMultileg_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MultilegOrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_MultilegOrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportRequest", VALUEFUNC(_wrap_MsgType_TradeCaptureReportRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReport", VALUEFUNC(_wrap_MsgType_TradeCaptureReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassStatusRequest", VALUEFUNC(_wrap_MsgType_OrderMassStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteRequestReject", VALUEFUNC(_wrap_MsgType_QuoteRequestReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RFQRequest", VALUEFUNC(_wrap_MsgType_RFQRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteStatusReport", VALUEFUNC(_wrap_MsgType_QuoteStatusReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstruction", VALUEFUNC(_wrap_MsgType_AllocationInstruction_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MultilegOrderCancelReplace", VALUEFUNC(_wrap_MsgType_MultilegOrderCancelReplace_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteResponse", VALUEFUNC(_wrap_MsgType_QuoteResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Confirmation", VALUEFUNC(_wrap_MsgType_Confirmation_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionMaintenanceRequest", VALUEFUNC(_wrap_MsgType_PositionMaintenanceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionMaintenanceReport", VALUEFUNC(_wrap_MsgType_PositionMaintenanceReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RequestForPositions", VALUEFUNC(_wrap_MsgType_RequestForPositions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RequestForPositionsAck", VALUEFUNC(_wrap_MsgType_RequestForPositionsAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionReport", VALUEFUNC(_wrap_MsgType_PositionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportRequestAck", VALUEFUNC(_wrap_MsgType_TradeCaptureReportRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportAck", VALUEFUNC(_wrap_MsgType_TradeCaptureReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationReport", VALUEFUNC(_wrap_MsgType_AllocationReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationReportAck", VALUEFUNC(_wrap_MsgType_AllocationReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ConfirmationAck", VALUEFUNC(_wrap_MsgType_ConfirmationAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SettlementInstructionRequest", VALUEFUNC(_wrap_MsgType_SettlementInstructionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AssignmentReport", VALUEFUNC(_wrap_MsgType_AssignmentReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralRequest", VALUEFUNC(_wrap_MsgType_CollateralRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralAssignment", VALUEFUNC(_wrap_MsgType_CollateralAssignment_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralResponse", VALUEFUNC(_wrap_MsgType_CollateralResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralReport", VALUEFUNC(_wrap_MsgType_CollateralReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralInquiry", VALUEFUNC(_wrap_MsgType_CollateralInquiry_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NetworkCounterpartySystemStatusRequest", VALUEFUNC(_wrap_MsgType_NetworkCounterpartySystemStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NetworkCounterpartySystemStatusResponse", VALUEFUNC(_wrap_MsgType_NetworkCounterpartySystemStatusResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_UserRequest", VALUEFUNC(_wrap_MsgType_UserRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_UserResponse", VALUEFUNC(_wrap_MsgType_UserResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralInquiryAck", VALUEFUNC(_wrap_MsgType_CollateralInquiryAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ConfirmationRequest", VALUEFUNC(_wrap_MsgType_ConfirmationRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ContraryIntentionReport", VALUEFUNC(_wrap_MsgType_ContraryIntentionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityDefinitionUpdateReport", VALUEFUNC(_wrap_MsgType_SecurityDefinitionUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityListUpdateReport", VALUEFUNC(_wrap_MsgType_SecurityListUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AdjustedPositionReport", VALUEFUNC(_wrap_MsgType_AdjustedPositionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstructionAlert", VALUEFUNC(_wrap_MsgType_AllocationInstructionAlert_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ExecutionAcknowledgement", VALUEFUNC(_wrap_MsgType_ExecutionAcknowledgement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionList", VALUEFUNC(_wrap_MsgType_TradingSessionList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionListRequest", VALUEFUNC(_wrap_MsgType_TradingSessionListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SettlementObligationReport", VALUEFUNC(_wrap_MsgType_SettlementObligationReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DerivativeSecurityListUpdateReport", VALUEFUNC(_wrap_MsgType_DerivativeSecurityListUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionListUpdateReport", VALUEFUNC(_wrap_MsgType_TradingSessionListUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDefinitionRequest", VALUEFUNC(_wrap_MsgType_MarketDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDefinition", VALUEFUNC(_wrap_MsgType_MarketDefinition_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDefinitionUpdateReport", VALUEFUNC(_wrap_MsgType_MarketDefinitionUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_UserNotification", VALUEFUNC(_wrap_MsgType_UserNotification_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassActionReport", VALUEFUNC(_wrap_MsgType_OrderMassActionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassActionRequest", VALUEFUNC(_wrap_MsgType_OrderMassActionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ApplicationMessageRequest", VALUEFUNC(_wrap_MsgType_ApplicationMessageRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ApplicationMessageRequestAck", VALUEFUNC(_wrap_MsgType_ApplicationMessageRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ApplicationMessageReport", VALUEFUNC(_wrap_MsgType_ApplicationMessageReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassQuoteAck", VALUEFUNC(_wrap_MsgType_MassQuoteAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ExecutionAck", VALUEFUNC(_wrap_MsgType_ExecutionAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_StreamAssignmentRequest", VALUEFUNC(_wrap_MsgType_StreamAssignmentRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_StreamAssignmentReport", VALUEFUNC(_wrap_MsgType_StreamAssignmentReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_StreamAssignmentReportACK", VALUEFUNC(_wrap_MsgType_StreamAssignmentReportACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarginRequirementInquiry", VALUEFUNC(_wrap_MsgType_MarginRequirementInquiry_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarginRequirementInquiryAck", VALUEFUNC(_wrap_MsgType_MarginRequirementInquiryAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarginRequirementReport", VALUEFUNC(_wrap_MsgType_MarginRequirementReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyDetailsListRequest", VALUEFUNC(_wrap_MsgType_PartyDetailsListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyDetailsListReport", VALUEFUNC(_wrap_MsgType_PartyDetailsListReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyDetailsListUpdateReport", VALUEFUNC(_wrap_MsgType_PartyDetailsListUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsRequest", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsReport", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityMassStatusRequest", VALUEFUNC(_wrap_MsgType_SecurityMassStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityMassStatus", VALUEFUNC(_wrap_MsgType_SecurityMassStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AccountSummaryReport", VALUEFUNC(_wrap_MsgType_AccountSummaryReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsUpdateReport", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsDefinitionRequest", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsDefinitionRequestAck", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsDefinitionRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyEntitlementsRequest", VALUEFUNC(_wrap_MsgType_PartyEntitlementsRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyEntitlementsReport", VALUEFUNC(_wrap_MsgType_PartyEntitlementsReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteAck", VALUEFUNC(_wrap_MsgType_QuoteAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyDetailsDefinitionRequest", VALUEFUNC(_wrap_MsgType_PartyDetailsDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyDetailsDefinitionRequestAck", VALUEFUNC(_wrap_MsgType_PartyDetailsDefinitionRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyEntitlementsUpdateReport", VALUEFUNC(_wrap_MsgType_PartyEntitlementsUpdateReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyEntitlementsDefinitionRequest", VALUEFUNC(_wrap_MsgType_PartyEntitlementsDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyEntitlementsDefinitionRequestAck", VALUEFUNC(_wrap_MsgType_PartyEntitlementsDefinitionRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeMatchReport", VALUEFUNC(_wrap_MsgType_TradeMatchReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeMatchReportAck", VALUEFUNC(_wrap_MsgType_TradeMatchReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitsReportAck", VALUEFUNC(_wrap_MsgType_PartyRiskLimitsReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitCheckRequest", VALUEFUNC(_wrap_MsgType_PartyRiskLimitCheckRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyRiskLimitCheckRequestAck", VALUEFUNC(_wrap_MsgType_PartyRiskLimitCheckRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyActionRequest", VALUEFUNC(_wrap_MsgType_PartyActionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PartyActionReport", VALUEFUNC(_wrap_MsgType_PartyActionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassOrder", VALUEFUNC(_wrap_MsgType_MassOrder_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassOrderAck", VALUEFUNC(_wrap_MsgType_MassOrderAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionTransferInstruction", VALUEFUNC(_wrap_MsgType_PositionTransferInstruction_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionTransferInstructionAck", VALUEFUNC(_wrap_MsgType_PositionTransferInstructionAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionTransferReport", VALUEFUNC(_wrap_MsgType_PositionTransferReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataStatisticsRequest", VALUEFUNC(_wrap_MsgType_MarketDataStatisticsRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataStatisticsReport", VALUEFUNC(_wrap_MsgType_MarketDataStatisticsReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralReportAck", VALUEFUNC(_wrap_MsgType_CollateralReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataReport", VALUEFUNC(_wrap_MsgType_MarketDataReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossRequest", VALUEFUNC(_wrap_MsgType_CrossRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossRequestAck", VALUEFUNC(_wrap_MsgType_CrossRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstructionAlertRequest", VALUEFUNC(_wrap_MsgType_AllocationInstructionAlertRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstructionAlertRequestAck", VALUEFUNC(_wrap_MsgType_AllocationInstructionAlertRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeAggregationRequest", VALUEFUNC(_wrap_MsgType_TradeAggregationRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeAggregationReport", VALUEFUNC(_wrap_MsgType_TradeAggregationReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PayManagementReport", VALUEFUNC(_wrap_MsgType_PayManagementReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PayManagementReportAck", VALUEFUNC(_wrap_MsgType_PayManagementReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PayManagementRequest", VALUEFUNC(_wrap_MsgType_PayManagementRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PayManagementRequestAck", VALUEFUNC(_wrap_MsgType_PayManagementRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "PossDupFlag_NO", VALUEFUNC(_wrap_PossDupFlag_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "PossDupFlag_YES", VALUEFUNC(_wrap_PossDupFlag_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "PossResend_NO", VALUEFUNC(_wrap_PossResend_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "PossResend_YES", VALUEFUNC(_wrap_PossResend_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_NONE_OTHER", VALUEFUNC(_wrap_EncryptMethod_NONE_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PKCS", VALUEFUNC(_wrap_EncryptMethod_PKCS_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_DES", VALUEFUNC(_wrap_EncryptMethod_DES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PKCSDES", VALUEFUNC(_wrap_EncryptMethod_PKCSDES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PGPDES", VALUEFUNC(_wrap_EncryptMethod_PGPDES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PGPDESMD5", VALUEFUNC(_wrap_EncryptMethod_PGPDESMD5_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PEMDESMD5", VALUEFUNC(_wrap_EncryptMethod_PEMDESMD5_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_NONE", VALUEFUNC(_wrap_EncryptMethod_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PEM", VALUEFUNC(_wrap_EncryptMethod_PEM_get), 0);
  rb_define_singleton_method(mQuickfix, "GapFillFlag_NO", VALUEFUNC(_wrap_GapFillFlag_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "GapFillFlag_YES", VALUEFUNC(_wrap_GapFillFlag_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "ResetSeqNumFlag_NO", VALUEFUNC(_wrap_ResetSeqNumFlag_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ResetSeqNumFlag_YES", VALUEFUNC(_wrap_ResetSeqNumFlag_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_EUCJP", VALUEFUNC(_wrap_MessageEncoding_EUCJP_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_ISO2022_JP", VALUEFUNC(_wrap_MessageEncoding_ISO2022_JP_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_SHIFT_JIS", VALUEFUNC(_wrap_MessageEncoding_SHIFT_JIS_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_UTF8", VALUEFUNC(_wrap_MessageEncoding_UTF8_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_TAG_NUMBER", VALUEFUNC(_wrap_SessionRejectReason_INVALID_TAG_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REQUIRED_TAG_MISSING", VALUEFUNC(_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE", VALUEFUNC(_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_UNDEFINED_TAG", VALUEFUNC(_wrap_SessionRejectReason_UNDEFINED_TAG_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_VALUE_IS_INCORRECT", VALUEFUNC(_wrap_SessionRejectReason_VALUE_IS_INCORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_DECRYPTION_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_DECRYPTION_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SIGNATURE_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_SIGNATURE_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_COMPID_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_COMPID_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_MSGTYPE", VALUEFUNC(_wrap_SessionRejectReason_INVALID_MSGTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_XML_VALIDATION_ERROR", VALUEFUNC(_wrap_SessionRejectReason_XML_VALIDATION_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE", VALUEFUNC(_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER", VALUEFUNC(_wrap_SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER", VALUEFUNC(_wrap_SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_UNSUPPORTED_APPLICATION_VERSION", VALUEFUNC(_wrap_SessionRejectReason_INVALID_UNSUPPORTED_APPLICATION_VERSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_OTHER", VALUEFUNC(_wrap_SessionRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SENDING_TIME_ACCURACY_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_SENDING_TIME_ACCURACY_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_MSG_TYPE", VALUEFUNC(_wrap_SessionRejectReason_INVALID_MSG_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_COMP_ID_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_COMP_ID_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_NON", VALUEFUNC(_wrap_SessionRejectReason_NON_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_NUM_IN_GROUP_COUNT_FOR_REPEATING_GROUP", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_NUM_IN_GROUP_COUNT_FOR_REPEATING_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "TestMessageIndicator_NO", VALUEFUNC(_wrap_TestMessageIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "TestMessageIndicator_YES", VALUEFUNC(_wrap_TestMessageIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX27", VALUEFUNC(_wrap_ApplVerID_FIX27_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX30", VALUEFUNC(_wrap_ApplVerID_FIX30_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX40", VALUEFUNC(_wrap_ApplVerID_FIX40_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX41", VALUEFUNC(_wrap_ApplVerID_FIX41_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX42", VALUEFUNC(_wrap_ApplVerID_FIX42_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX43", VALUEFUNC(_wrap_ApplVerID_FIX43_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX44", VALUEFUNC(_wrap_ApplVerID_FIX44_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX50", VALUEFUNC(_wrap_ApplVerID_FIX50_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX50_SP1", VALUEFUNC(_wrap_ApplVerID_FIX50_SP1_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplVerID_FIX50_SP2", VALUEFUNC(_wrap_ApplVerID_FIX50_SP2_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_SESSION_ACTIVE", VALUEFUNC(_wrap_SessionStatus_SESSION_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_SESSION_PASSWORD_CHANGED", VALUEFUNC(_wrap_SessionStatus_SESSION_PASSWORD_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_SESSION_PASSWORD_DUE_TO_EXPIRE", VALUEFUNC(_wrap_SessionStatus_SESSION_PASSWORD_DUE_TO_EXPIRE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_NEW_SESSION_PASSWORD_DOES_NOT_COMPLY_WITH_POLICY", VALUEFUNC(_wrap_SessionStatus_NEW_SESSION_PASSWORD_DOES_NOT_COMPLY_WITH_POLICY_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_SESSION_LOGOUT_COMPLETE", VALUEFUNC(_wrap_SessionStatus_SESSION_LOGOUT_COMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_INVALID_USERNAME_OR_PASSWORD", VALUEFUNC(_wrap_SessionStatus_INVALID_USERNAME_OR_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_ACCOUNT_LOCKED", VALUEFUNC(_wrap_SessionStatus_ACCOUNT_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_LOGONS_ARE_NOT_ALLOWED_AT_THIS_TIME", VALUEFUNC(_wrap_SessionStatus_LOGONS_ARE_NOT_ALLOWED_AT_THIS_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionStatus_PASSWORD_EXPIRED", VALUEFUNC(_wrap_SessionStatus_PASSWORD_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_BUY", VALUEFUNC(_wrap_AdvSide_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_SELL", VALUEFUNC(_wrap_AdvSide_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_TRADE", VALUEFUNC(_wrap_AdvSide_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_CROSS", VALUEFUNC(_wrap_AdvSide_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_CANCEL", VALUEFUNC(_wrap_AdvTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_NEW", VALUEFUNC(_wrap_AdvTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_REPLACE", VALUEFUNC(_wrap_AdvTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PER_UNIT", VALUEFUNC(_wrap_CommType_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENT", VALUEFUNC(_wrap_CommType_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_ABSOLUTE", VALUEFUNC(_wrap_CommType_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_POINTS_PER_BOND_OR_CONTRACT", VALUEFUNC(_wrap_CommType_POINTS_PER_BOND_OR_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS", VALUEFUNC(_wrap_CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT", VALUEFUNC(_wrap_CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_BASIS_POINTS", VALUEFUNC(_wrap_CommType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_AMOUNT_PER_CONTRACT", VALUEFUNC(_wrap_CommType_AMOUNT_PER_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STAY_ON_OFFER_SIDE", VALUEFUNC(_wrap_ExecInst_STAY_ON_OFFER_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NOT_HELD", VALUEFUNC(_wrap_ExecInst_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_WORK", VALUEFUNC(_wrap_ExecInst_WORK_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_GO_ALONG", VALUEFUNC(_wrap_ExecInst_GO_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OVER_THE_DAY", VALUEFUNC(_wrap_ExecInst_OVER_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_HELD", VALUEFUNC(_wrap_ExecInst_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PARTICIPATE_DO_NOT_INITIATE", VALUEFUNC(_wrap_ExecInst_PARTICIPATE_DO_NOT_INITIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STRICT_SCALE", VALUEFUNC(_wrap_ExecInst_STRICT_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRY_TO_SCALE", VALUEFUNC(_wrap_ExecInst_TRY_TO_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STAY_ON_BID_SIDE", VALUEFUNC(_wrap_ExecInst_STAY_ON_BID_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NO_CROSS", VALUEFUNC(_wrap_ExecInst_NO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OK_TO_CROSS", VALUEFUNC(_wrap_ExecInst_OK_TO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CALL_FIRST", VALUEFUNC(_wrap_ExecInst_CALL_FIRST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PERCENT_OF_VOLUME", VALUEFUNC(_wrap_ExecInst_PERCENT_OF_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_DO_NOT_INCREASE", VALUEFUNC(_wrap_ExecInst_DO_NOT_INCREASE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_DO_NOT_REDUCE", VALUEFUNC(_wrap_ExecInst_DO_NOT_REDUCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_ALL_OR_NONE", VALUEFUNC(_wrap_ExecInst_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_INSTITUTIONS_ONLY", VALUEFUNC(_wrap_ExecInst_INSTITUTIONS_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_LAST_PEG", VALUEFUNC(_wrap_ExecInst_LAST_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_MID_PRICE_PEG", VALUEFUNC(_wrap_ExecInst_MID_PRICE_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NON_NEGOTIABLE", VALUEFUNC(_wrap_ExecInst_NON_NEGOTIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OPENING_PEG", VALUEFUNC(_wrap_ExecInst_OPENING_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_MARKET_PEG", VALUEFUNC(_wrap_ExecInst_MARKET_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PRIMARY_PEG", VALUEFUNC(_wrap_ExecInst_PRIMARY_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SUSPEND", VALUEFUNC(_wrap_ExecInst_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CUSTOMER_DISPLAY_INSTRUCTION", VALUEFUNC(_wrap_ExecInst_CUSTOMER_DISPLAY_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NETTING", VALUEFUNC(_wrap_ExecInst_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER", VALUEFUNC(_wrap_ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PEG_TO_VWAP", VALUEFUNC(_wrap_ExecInst_PEG_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRY_TO_STOP", VALUEFUNC(_wrap_ExecInst_TRY_TO_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecInst_CANCEL_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRADE_ALONG", VALUEFUNC(_wrap_ExecInst_TRADE_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_REINSTATE_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecInst_REINSTATE_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_REINSTATE_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecInst_REINSTATE_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecInst_CANCEL_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_IF_NOT_BEST", VALUEFUNC(_wrap_ExecInst_CANCEL_IF_NOT_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRAILING_STOP_PEG", VALUEFUNC(_wrap_ExecInst_TRAILING_STOP_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STRICT_LIMIT", VALUEFUNC(_wrap_ExecInst_STRICT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_IGNORE_PRICE_VALIDITY_CHECKS", VALUEFUNC(_wrap_ExecInst_IGNORE_PRICE_VALIDITY_CHECKS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PEG_TO_LIMIT_PRICE", VALUEFUNC(_wrap_ExecInst_PEG_TO_LIMIT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_WORK_TO_TARGET_STRATEGY", VALUEFUNC(_wrap_ExecInst_WORK_TO_TARGET_STRATEGY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_INTERMARKET_SWEEP", VALUEFUNC(_wrap_ExecInst_INTERMARKET_SWEEP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_EXTERNAL_ROUTING_ALLOWED", VALUEFUNC(_wrap_ExecInst_EXTERNAL_ROUTING_ALLOWED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_EXTERNAL_ROUTING_NOT_ALLOWED", VALUEFUNC(_wrap_ExecInst_EXTERNAL_ROUTING_NOT_ALLOWED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_IMBALANCE_ONLY", VALUEFUNC(_wrap_ExecInst_IMBALANCE_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SINGLE_EXECUTION_REQUESTED_FOR_BLOCK_TRADE", VALUEFUNC(_wrap_ExecInst_SINGLE_EXECUTION_REQUESTED_FOR_BLOCK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_BEST_EXECUTION", VALUEFUNC(_wrap_ExecInst_BEST_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SUSPEND_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecInst_SUSPEND_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SUSPEND_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecInst_SUSPEND_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_REINSTATE_ON_CONNECTION_LOSS", VALUEFUNC(_wrap_ExecInst_REINSTATE_ON_CONNECTION_LOSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_ON_CONNECTION_LOSS", VALUEFUNC(_wrap_ExecInst_CANCEL_ON_CONNECTION_LOSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SUSPEND_ON_CONNECTION_LOSS", VALUEFUNC(_wrap_ExecInst_SUSPEND_ON_CONNECTION_LOSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_RELEASE_FROM_SUSPENSION", VALUEFUNC(_wrap_ExecInst_RELEASE_FROM_SUSPENSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_EXECUTE_AS_DELTA_NEUTRAL", VALUEFUNC(_wrap_ExecInst_EXECUTE_AS_DELTA_NEUTRAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_EXECUTE_AS_DURATION_NEUTRAL", VALUEFUNC(_wrap_ExecInst_EXECUTE_AS_DURATION_NEUTRAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_EXECUTE_AS_FX_NEUTRAL", VALUEFUNC(_wrap_ExecInst_EXECUTE_AS_FX_NEUTRAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_RELEASE", VALUEFUNC(_wrap_ExecInst_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_MIN_GUARANTEED_FILL_ELIGIBLE", VALUEFUNC(_wrap_ExecInst_MIN_GUARANTEED_FILL_ELIGIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_BYPASS_NON_DISPLAY_LIQUIDITY", VALUEFUNC(_wrap_ExecInst_BYPASS_NON_DISPLAY_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_LOCK", VALUEFUNC(_wrap_ExecInst_LOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_IGNORE_NOTIONAL_VALUE_CHECKS", VALUEFUNC(_wrap_ExecInst_IGNORE_NOTIONAL_VALUE_CHECKS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRD_AT_REF_PX", VALUEFUNC(_wrap_ExecInst_TRD_AT_REF_PX_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_ALLOW_FACILITATION", VALUEFUNC(_wrap_ExecInst_ALLOW_FACILITATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_NEW", VALUEFUNC(_wrap_ExecTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_CANCEL", VALUEFUNC(_wrap_ExecTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_CORRECT", VALUEFUNC(_wrap_ExecTransType_CORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_STATUS", VALUEFUNC(_wrap_ExecTransType_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_AUTOMATED_EXECUTION_NO_INTERVENTION", VALUEFUNC(_wrap_HandlInst_AUTOMATED_EXECUTION_NO_INTERVENTION_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_AUTOMATED_EXECUTION_INTERVENTION_OK", VALUEFUNC(_wrap_HandlInst_AUTOMATED_EXECUTION_INTERVENTION_OK_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_MANUAL_ORDER", VALUEFUNC(_wrap_HandlInst_MANUAL_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_CUSIP", VALUEFUNC(_wrap_IDSource_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_SEDOL", VALUEFUNC(_wrap_IDSource_SEDOL_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_QUIK", VALUEFUNC(_wrap_IDSource_QUIK_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISIN_NUMBER", VALUEFUNC(_wrap_IDSource_ISIN_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_RIC_CODE", VALUEFUNC(_wrap_IDSource_RIC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_IDSource_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_IDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_EXCHANGE_SYMBOL", VALUEFUNC(_wrap_IDSource_EXCHANGE_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_CONSOLIDATED_TAPE_ASSOCIATION", VALUEFUNC(_wrap_IDSource_CONSOLIDATED_TAPE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIOthSvc_AUTEX", VALUEFUNC(_wrap_IOIOthSvc_AUTEX_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIOthSvc_BRIDGE", VALUEFUNC(_wrap_IOIOthSvc_BRIDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_HIGH", VALUEFUNC(_wrap_IOIQltyInd_HIGH_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_LOW", VALUEFUNC(_wrap_IOIQltyInd_LOW_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_MEDIUM", VALUEFUNC(_wrap_IOIQltyInd_MEDIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_LARGE", VALUEFUNC(_wrap_IOIShares_LARGE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_MEDIUM", VALUEFUNC(_wrap_IOIShares_MEDIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_SMALL", VALUEFUNC(_wrap_IOIShares_SMALL_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_CANCEL", VALUEFUNC(_wrap_IOITransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_NEW", VALUEFUNC(_wrap_IOITransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_REPLACE", VALUEFUNC(_wrap_IOITransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_AGENT", VALUEFUNC(_wrap_LastCapacity_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_CROSS_AS_AGENT", VALUEFUNC(_wrap_LastCapacity_CROSS_AS_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_CROSS_AS_PRINCIPAL", VALUEFUNC(_wrap_LastCapacity_CROSS_AS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_PRINCIPAL", VALUEFUNC(_wrap_LastCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_LastCapacity_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_NEW", VALUEFUNC(_wrap_OrdStatus_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PARTIALLY_FILLED", VALUEFUNC(_wrap_OrdStatus_PARTIALLY_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_FILLED", VALUEFUNC(_wrap_OrdStatus_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_DONE_FOR_DAY", VALUEFUNC(_wrap_OrdStatus_DONE_FOR_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_CANCELED", VALUEFUNC(_wrap_OrdStatus_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_REPLACED", VALUEFUNC(_wrap_OrdStatus_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_CANCEL", VALUEFUNC(_wrap_OrdStatus_PENDING_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_STOPPED", VALUEFUNC(_wrap_OrdStatus_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_REJECTED", VALUEFUNC(_wrap_OrdStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_SUSPENDED", VALUEFUNC(_wrap_OrdStatus_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_NEW", VALUEFUNC(_wrap_OrdStatus_PENDING_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_CALCULATED", VALUEFUNC(_wrap_OrdStatus_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_EXPIRED", VALUEFUNC(_wrap_OrdStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_ACCEPTED_FOR_BIDDING", VALUEFUNC(_wrap_OrdStatus_ACCEPTED_FOR_BIDDING_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_REPLACE", VALUEFUNC(_wrap_OrdStatus_PENDING_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET", VALUEFUNC(_wrap_OrdType_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT", VALUEFUNC(_wrap_OrdType_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP", VALUEFUNC(_wrap_OrdType_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP_LIMIT", VALUEFUNC(_wrap_OrdType_STOP_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_ON_CLOSE", VALUEFUNC(_wrap_OrdType_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_WITH_OR_WITHOUT", VALUEFUNC(_wrap_OrdType_WITH_OR_WITHOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_OR_BETTER", VALUEFUNC(_wrap_OrdType_LIMIT_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_WITH_OR_WITHOUT", VALUEFUNC(_wrap_OrdType_LIMIT_WITH_OR_WITHOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_ON_BASIS", VALUEFUNC(_wrap_OrdType_ON_BASIS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_ON_CLOSE", VALUEFUNC(_wrap_OrdType_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_ON_CLOSE", VALUEFUNC(_wrap_OrdType_LIMIT_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_MARKET", VALUEFUNC(_wrap_OrdType_FOREX_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUSLY_QUOTED", VALUEFUNC(_wrap_OrdType_PREVIOUSLY_QUOTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUSLY_INDICATED", VALUEFUNC(_wrap_OrdType_PREVIOUSLY_INDICATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PEGGED", VALUEFUNC(_wrap_OrdType_PEGGED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_LIMIT", VALUEFUNC(_wrap_OrdType_FOREX_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_SWAP", VALUEFUNC(_wrap_OrdType_FOREX_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_PREVIOUSLY_QUOTED", VALUEFUNC(_wrap_OrdType_FOREX_PREVIOUSLY_QUOTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FUNARI", VALUEFUNC(_wrap_OrdType_FUNARI_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_IF_TOUCHED", VALUEFUNC(_wrap_OrdType_MARKET_IF_TOUCHED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_WITH_LEFT_OVER_AS_LIMIT", VALUEFUNC(_wrap_OrdType_MARKET_WITH_LEFT_OVER_AS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUS_FUND_VALUATION_POINT", VALUEFUNC(_wrap_OrdType_PREVIOUS_FUND_VALUATION_POINT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_NEXT_FUND_VALUATION_POINT", VALUEFUNC(_wrap_OrdType_NEXT_FUND_VALUATION_POINT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_COUNTER_ORDER_SELECTION", VALUEFUNC(_wrap_OrdType_COUNTER_ORDER_SELECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP_ON_BID_OR_OFFER", VALUEFUNC(_wrap_OrdType_STOP_ON_BID_OR_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP_LIMIT_ON_BID_OR_OFFER", VALUEFUNC(_wrap_OrdType_STOP_LIMIT_ON_BID_OR_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENCY_SINGLE_ORDER", VALUEFUNC(_wrap_Rule80A_AGENCY_SINGLE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROPRIETARY_NON_ALGO", VALUEFUNC(_wrap_Rule80A_PROPRIETARY_NON_ALGO_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_MEMBER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_INDIVIDUAL_INVESTOR", VALUEFUNC(_wrap_Rule80A_INDIVIDUAL_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROPRIETARY_ALGO", VALUEFUNC(_wrap_Rule80A_PROPRIETARY_ALGO_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENCY_ALGO", VALUEFUNC(_wrap_Rule80A_AGENCY_ALGO_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENT_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_AGENT_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENCY_INDEX_ARB", VALUEFUNC(_wrap_Rule80A_AGENCY_INDEX_ARB_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENCY_NON_ALGO", VALUEFUNC(_wrap_Rule80A_AGENCY_NON_ALGO_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_A_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_A_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_W_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_W_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_I_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_I_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_AFFLIATED", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_AFFLIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROPRIETARY_TRANSACTION_AFFILIATED", VALUEFUNC(_wrap_Rule80A_PROPRIETARY_TRANSACTION_AFFILIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PRINCIPAL", VALUEFUNC(_wrap_Rule80A_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_TRANSACTION_NON_MEMBER", VALUEFUNC(_wrap_Rule80A_TRANSACTION_NON_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SPECIALIST_TRADES", VALUEFUNC(_wrap_Rule80A_SPECIALIST_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_TRANSACTION_UNAFFILIATED_MEMBER", VALUEFUNC(_wrap_Rule80A_TRANSACTION_UNAFFILIATED_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_NOT_AFFLIATED", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_MEMBER_NOT_AFFLIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_NON_MEMBER", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_NON_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BUY", VALUEFUNC(_wrap_Side_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL", VALUEFUNC(_wrap_Side_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BUY_MINUS", VALUEFUNC(_wrap_Side_BUY_MINUS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_PLUS", VALUEFUNC(_wrap_Side_SELL_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_SHORT", VALUEFUNC(_wrap_Side_SELL_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_SHORT_EXEMPT", VALUEFUNC(_wrap_Side_SELL_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_UNDISCLOSED", VALUEFUNC(_wrap_Side_UNDISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS", VALUEFUNC(_wrap_Side_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS_SHORT", VALUEFUNC(_wrap_Side_CROSS_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_AS_DEFINED", VALUEFUNC(_wrap_Side_AS_DEFINED_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_OPPOSITE", VALUEFUNC(_wrap_Side_OPPOSITE_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS_SHORT_EXEMPT", VALUEFUNC(_wrap_Side_CROSS_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SUBSCRIBE", VALUEFUNC(_wrap_Side_SUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_REDEEM", VALUEFUNC(_wrap_Side_REDEEM_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_LEND", VALUEFUNC(_wrap_Side_LEND_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BORROW", VALUEFUNC(_wrap_Side_BORROW_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_UNDISCLOSED", VALUEFUNC(_wrap_Side_SELL_UNDISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_DAY", VALUEFUNC(_wrap_TimeInForce_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_CANCEL", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_AT_THE_OPENING", VALUEFUNC(_wrap_TimeInForce_AT_THE_OPENING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_IMMEDIATE_OR_CANCEL", VALUEFUNC(_wrap_TimeInForce_IMMEDIATE_OR_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_FILL_OR_KILL", VALUEFUNC(_wrap_TimeInForce_FILL_OR_KILL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_CROSSING", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_CROSSING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_DATE", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_AT_THE_CLOSE", VALUEFUNC(_wrap_TimeInForce_AT_THE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_THROUGH_CROSSING", VALUEFUNC(_wrap_TimeInForce_GOOD_THROUGH_CROSSING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_AT_CROSSING", VALUEFUNC(_wrap_TimeInForce_AT_CROSSING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_FOR_TIME", VALUEFUNC(_wrap_TimeInForce_GOOD_FOR_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_FOR_AUCTION", VALUEFUNC(_wrap_TimeInForce_GOOD_FOR_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_FOR_MONTH", VALUEFUNC(_wrap_TimeInForce_GOOD_FOR_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_NORMAL", VALUEFUNC(_wrap_Urgency_NORMAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_FLASH", VALUEFUNC(_wrap_Urgency_FLASH_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_BACKGROUND", VALUEFUNC(_wrap_Urgency_BACKGROUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_REGULAR", VALUEFUNC(_wrap_SettlmntTyp_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_CASH", VALUEFUNC(_wrap_SettlmntTyp_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_NEXT_DAY", VALUEFUNC(_wrap_SettlmntTyp_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS2", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS2_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS3", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS3_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS4", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS4_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_FUTURE", VALUEFUNC(_wrap_SettlmntTyp_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_WHEN_AND_IF_ISSUED", VALUEFUNC(_wrap_SettlmntTyp_WHEN_AND_IF_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_SELLERS_OPTION", VALUEFUNC(_wrap_SettlmntTyp_SELLERS_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS5", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS5_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T1", VALUEFUNC(_wrap_SettlmntTyp_T1_get), 0);
  rb_define_singleton_method(mQuickfix, "SymbolSfx_EUCP_WITH_LUMP_SUM_INTEREST", VALUEFUNC(_wrap_SymbolSfx_EUCP_WITH_LUMP_SUM_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "SymbolSfx_WHEN_ISSUED", VALUEFUNC(_wrap_SymbolSfx_WHEN_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_NEW", VALUEFUNC(_wrap_AllocTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_REPLACE", VALUEFUNC(_wrap_AllocTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_CANCEL", VALUEFUNC(_wrap_AllocTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_PRELIMINARY", VALUEFUNC(_wrap_AllocTransType_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_CALCULATED", VALUEFUNC(_wrap_AllocTransType_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_CALCULATED_WITHOUT_PRELIMINARY", VALUEFUNC(_wrap_AllocTransType_CALCULATED_WITHOUT_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_REVERSAL", VALUEFUNC(_wrap_AllocTransType_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenClose_CLOSE", VALUEFUNC(_wrap_OpenClose_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenClose_OPEN", VALUEFUNC(_wrap_OpenClose_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_REGULAR", VALUEFUNC(_wrap_ProcessCode_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_STEP_IN", VALUEFUNC(_wrap_ProcessCode_STEP_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_STEP_OUT", VALUEFUNC(_wrap_ProcessCode_STEP_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR_STEP_IN", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_STEP_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR_STEP_OUT", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_STEP_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_PLAN_SPONSOR", VALUEFUNC(_wrap_ProcessCode_PLAN_SPONSOR_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_ACCEPTED", VALUEFUNC(_wrap_AllocStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_BLOCK_LEVEL_REJECT", VALUEFUNC(_wrap_AllocStatus_BLOCK_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_ACCOUNT_LEVEL_REJECT", VALUEFUNC(_wrap_AllocStatus_ACCOUNT_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_RECEIVED", VALUEFUNC(_wrap_AllocStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_INCOMPLETE", VALUEFUNC(_wrap_AllocStatus_INCOMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_REJECTED_BY_INTERMEDIARY", VALUEFUNC(_wrap_AllocStatus_REJECTED_BY_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_ALLOCATION_PENDING", VALUEFUNC(_wrap_AllocStatus_ALLOCATION_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_REVERSED", VALUEFUNC(_wrap_AllocStatus_REVERSED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_CANCELLED_BY_INTERMEDIARY", VALUEFUNC(_wrap_AllocStatus_CANCELLED_BY_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_CLAIMED", VALUEFUNC(_wrap_AllocStatus_CLAIMED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_REFUSED", VALUEFUNC(_wrap_AllocStatus_REFUSED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_PENDING_GIVE_UP_APPROVAL", VALUEFUNC(_wrap_AllocStatus_PENDING_GIVE_UP_APPROVAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_CANCELLED", VALUEFUNC(_wrap_AllocStatus_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_PENDING_TAKE_UP_APPROVAL", VALUEFUNC(_wrap_AllocStatus_PENDING_TAKE_UP_APPROVAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_REVERSAL_PENDING", VALUEFUNC(_wrap_AllocStatus_REVERSAL_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_QUANTITY", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_AVERAGEG_PRICE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_AVERAGEG_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_COMMISSION_DIFFERENCE", VALUEFUNC(_wrap_AllocRejCode_COMMISSION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_ORDER_ID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_ORDER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_LIST_ID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_LIST_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_OTHER_SEE_TEXT", VALUEFUNC(_wrap_AllocRejCode_OTHER_SEE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_ALLOCATED_QUANTITY", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_ALLOCATED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_CALCULATION_DIFFERENCE", VALUEFUNC(_wrap_AllocRejCode_CALCULATION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_OR_STALE_EXEC_ID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_OR_STALE_EXEC_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_MISMATCHED_DATA", VALUEFUNC(_wrap_AllocRejCode_MISMATCHED_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_CL_ORD_ID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_CL_ORD_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_WAREHOUSE_REQUEST_REJECTED", VALUEFUNC(_wrap_AllocRejCode_WAREHOUSE_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_AVERAGE_PRICE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_DUPLICATE_OR_MISSING_INDIVIDUAL_ALLOC_ID", VALUEFUNC(_wrap_AllocRejCode_DUPLICATE_OR_MISSING_INDIVIDUAL_ALLOC_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_TRADE_NOT_RECOGNIZED", VALUEFUNC(_wrap_AllocRejCode_TRADE_NOT_RECOGNIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_DUPLICATE_TRADE", VALUEFUNC(_wrap_AllocRejCode_DUPLICATE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_INSTRUMENT", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_SETTL_DATE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_SETTL_INSTRUCTIONS", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_FEES", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_TAX", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_OR_MISSING_PARTY", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_OR_MISSING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_SIDE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_NET_MONEY", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_NET_MONEY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_TRADE_DATE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_OR_MISSING_PROCESS_CODE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_OR_MISSING_PROCESS_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_OTHER", VALUEFUNC(_wrap_AllocRejCode_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_NEW", VALUEFUNC(_wrap_EmailType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_REPLY", VALUEFUNC(_wrap_EmailType_REPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_ADMIN_REPLY", VALUEFUNC(_wrap_EmailType_ADMIN_REPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestination_NONE", VALUEFUNC(_wrap_ExDestination_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestination_POSIT", VALUEFUNC(_wrap_ExDestination_POSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_TOO_LATE_TO_CANCEL", VALUEFUNC(_wrap_CxlRejReason_TOO_LATE_TO_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_UNKNOWN_ORDER", VALUEFUNC(_wrap_CxlRejReason_UNKNOWN_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_BROKER_CREDIT", VALUEFUNC(_wrap_CxlRejReason_BROKER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_ORDER_ALREADY_IN_PENDING_STATUS", VALUEFUNC(_wrap_CxlRejReason_ORDER_ALREADY_IN_PENDING_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_DUPLICATE_CL_ORD_ID", VALUEFUNC(_wrap_CxlRejReason_DUPLICATE_CL_ORD_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_ORIG_ORD_MOD_TIME", VALUEFUNC(_wrap_CxlRejReason_ORIG_ORD_MOD_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST", VALUEFUNC(_wrap_CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_OTHER", VALUEFUNC(_wrap_CxlRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_INVALID_PRICE_INCREMENT", VALUEFUNC(_wrap_CxlRejReason_INVALID_PRICE_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE", VALUEFUNC(_wrap_CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND", VALUEFUNC(_wrap_CxlRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_BROKER_CREDIT", VALUEFUNC(_wrap_OrdRejReason_BROKER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_OrdRejReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_ORDER_EXCEEDS_LIMIT", VALUEFUNC(_wrap_OrdRejReason_ORDER_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_OrdRejReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_ORDER", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_DUPLICATE_ORDER", VALUEFUNC(_wrap_OrdRejReason_DUPLICATE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER", VALUEFUNC(_wrap_OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_STALE_ORDER", VALUEFUNC(_wrap_OrdRejReason_STALE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_TRADE_ALONG_REQUIRED", VALUEFUNC(_wrap_OrdRejReason_TRADE_ALONG_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INVALID_INVESTOR_ID", VALUEFUNC(_wrap_OrdRejReason_INVALID_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC", VALUEFUNC(_wrap_OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SURVEILLENCE_OPTION", VALUEFUNC(_wrap_OrdRejReason_SURVEILLENCE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INCORRECT_QUANTITY", VALUEFUNC(_wrap_OrdRejReason_INCORRECT_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INCORRECT_ALLOCATED_QUANTITY", VALUEFUNC(_wrap_OrdRejReason_INCORRECT_ALLOCATED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_OTHER", VALUEFUNC(_wrap_OrdRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INVALID_PRICE_INCREMENT", VALUEFUNC(_wrap_OrdRejReason_INVALID_PRICE_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND", VALUEFUNC(_wrap_OrdRejReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SURVEILLANCE_OPTION", VALUEFUNC(_wrap_OrdRejReason_SURVEILLANCE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_REFERENCE_PRICE_NOT_AVAILABLE", VALUEFUNC(_wrap_OrdRejReason_REFERENCE_PRICE_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD", VALUEFUNC(_wrap_OrdRejReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_ALGORITHM_RISK_THRESHOLD_BREACHED", VALUEFUNC(_wrap_OrdRejReason_ALGORITHM_RISK_THRESHOLD_BREACHED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SHORT_SELL_NOT_PERMITTED", VALUEFUNC(_wrap_OrdRejReason_SHORT_SELL_NOT_PERMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SHORT_SELL_SECURITY_PRE_BORROW_RESTRICTION", VALUEFUNC(_wrap_OrdRejReason_SHORT_SELL_SECURITY_PRE_BORROW_RESTRICTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SHORT_SELL_ACCOUNT_PRE_BORROW_RESTRICTION", VALUEFUNC(_wrap_OrdRejReason_SHORT_SELL_ACCOUNT_PRE_BORROW_RESTRICTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INSUFFICIENT_CREDIT_LIMIT", VALUEFUNC(_wrap_OrdRejReason_INSUFFICIENT_CREDIT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCEEDED_CLIP_SIZE_LIMIT", VALUEFUNC(_wrap_OrdRejReason_EXCEEDED_CLIP_SIZE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT", VALUEFUNC(_wrap_OrdRejReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCEEDED_DV01_PV01_LIMIT", VALUEFUNC(_wrap_OrdRejReason_EXCEEDED_DV01_PV01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCEEDED_CS01_LIMIT", VALUEFUNC(_wrap_OrdRejReason_EXCEEDED_CS01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_ALL_OR_NONE", VALUEFUNC(_wrap_IOIQualifier_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_CLOSE", VALUEFUNC(_wrap_IOIQualifier_AT_THE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_IN_TOUCH_WITH", VALUEFUNC(_wrap_IOIQualifier_IN_TOUCH_WITH_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_LIMIT", VALUEFUNC(_wrap_IOIQualifier_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_MORE_BEHIND", VALUEFUNC(_wrap_IOIQualifier_MORE_BEHIND_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_OPEN", VALUEFUNC(_wrap_IOIQualifier_AT_THE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_TAKING_A_POSITION", VALUEFUNC(_wrap_IOIQualifier_TAKING_A_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_MARKET", VALUEFUNC(_wrap_IOIQualifier_AT_THE_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_PORTFOLIO_SHOWN", VALUEFUNC(_wrap_IOIQualifier_PORTFOLIO_SHOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_THROUGH_THE_DAY", VALUEFUNC(_wrap_IOIQualifier_THROUGH_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_VERSUS", VALUEFUNC(_wrap_IOIQualifier_VERSUS_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_INDICATION", VALUEFUNC(_wrap_IOIQualifier_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_CROSSING_OPPORTUNITY", VALUEFUNC(_wrap_IOIQualifier_CROSSING_OPPORTUNITY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_MIDPOINT", VALUEFUNC(_wrap_IOIQualifier_AT_THE_MIDPOINT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_PRE_OPEN", VALUEFUNC(_wrap_IOIQualifier_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_READY_TO_TRADE", VALUEFUNC(_wrap_IOIQualifier_READY_TO_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_VWAP", VALUEFUNC(_wrap_IOIQualifier_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_MARKET_ON_CLOSE", VALUEFUNC(_wrap_IOIQualifier_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AXE", VALUEFUNC(_wrap_IOIQualifier_AXE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AXE_ON_BID", VALUEFUNC(_wrap_IOIQualifier_AXE_ON_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AXE_ON_OFFER", VALUEFUNC(_wrap_IOIQualifier_AXE_ON_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_CLIENT_NATURAL_WORKING", VALUEFUNC(_wrap_IOIQualifier_CLIENT_NATURAL_WORKING_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_POSITION_WANTED", VALUEFUNC(_wrap_IOIQualifier_POSITION_WANTED_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_MARKET_MAKING", VALUEFUNC(_wrap_IOIQualifier_MARKET_MAKING_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_CLIENT_NATURAL_BLOCK", VALUEFUNC(_wrap_IOIQualifier_CLIENT_NATURAL_BLOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_UNWIND", VALUEFUNC(_wrap_IOIQualifier_UNWIND_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_QUANTITY_NEGOTIABLE", VALUEFUNC(_wrap_IOIQualifier_QUANTITY_NEGOTIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_ALLOW_LATE_BIDS", VALUEFUNC(_wrap_IOIQualifier_ALLOW_LATE_BIDS_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_IMMEDIATE_OR_COUNTER", VALUEFUNC(_wrap_IOIQualifier_IMMEDIATE_OR_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AUTO_TRADE", VALUEFUNC(_wrap_IOIQualifier_AUTO_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AUTOMATIC_SPOT", VALUEFUNC(_wrap_IOIQualifier_AUTOMATIC_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_PLATFORM_CALCULATED_SPOT", VALUEFUNC(_wrap_IOIQualifier_PLATFORM_CALCULATED_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_OUTSIDE_SPREAD", VALUEFUNC(_wrap_IOIQualifier_OUTSIDE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_DEFERRED_SPOT", VALUEFUNC(_wrap_IOIQualifier_DEFERRED_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_NEGOTIATED_SPOT", VALUEFUNC(_wrap_IOIQualifier_NEGOTIATED_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "ReportToExch_NO", VALUEFUNC(_wrap_ReportToExch_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ReportToExch_YES", VALUEFUNC(_wrap_ReportToExch_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "LocateReqd_NO", VALUEFUNC(_wrap_LocateReqd_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "LocateReqd_YES", VALUEFUNC(_wrap_LocateReqd_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "ForexReq_NO", VALUEFUNC(_wrap_ForexReq_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ForexReq_YES", VALUEFUNC(_wrap_ForexReq_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlType_FULL_REMAINING_QUANTITY", VALUEFUNC(_wrap_CxlType_FULL_REMAINING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlType_PARTIAL_CANCEL", VALUEFUNC(_wrap_CxlType_PARTIAL_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_DKReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_WRONG_SIDE", VALUEFUNC(_wrap_DKReason_WRONG_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_QUANTITY_EXCEEDS_ORDER", VALUEFUNC(_wrap_DKReason_QUANTITY_EXCEEDS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_NO_MATCHING_ORDER", VALUEFUNC(_wrap_DKReason_NO_MATCHING_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_PRICE_EXCEEDS_LIMIT", VALUEFUNC(_wrap_DKReason_PRICE_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_OTHER", VALUEFUNC(_wrap_DKReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_CALCULATION_DIFFERENCE", VALUEFUNC(_wrap_DKReason_CALCULATION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_NO_MATCHING_EXECUTION_REPORT", VALUEFUNC(_wrap_DKReason_NO_MATCHING_EXECUTION_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOINaturalFlag_NO", VALUEFUNC(_wrap_IOINaturalFlag_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "IOINaturalFlag_YES", VALUEFUNC(_wrap_IOINaturalFlag_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_REGULATORY", VALUEFUNC(_wrap_MiscFeeType_REGULATORY_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TAX", VALUEFUNC(_wrap_MiscFeeType_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_LOCAL_COMMISSION", VALUEFUNC(_wrap_MiscFeeType_LOCAL_COMMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_EXCHANGE_FEES", VALUEFUNC(_wrap_MiscFeeType_EXCHANGE_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_STAMP", VALUEFUNC(_wrap_MiscFeeType_STAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_LEVY", VALUEFUNC(_wrap_MiscFeeType_LEVY_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_OTHER", VALUEFUNC(_wrap_MiscFeeType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_MARKUP", VALUEFUNC(_wrap_MiscFeeType_MARKUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_CONSUMPTION_TAX", VALUEFUNC(_wrap_MiscFeeType_CONSUMPTION_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_PER_TRANSACTION", VALUEFUNC(_wrap_MiscFeeType_PER_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_CONVERSION", VALUEFUNC(_wrap_MiscFeeType_CONVERSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_AGENT", VALUEFUNC(_wrap_MiscFeeType_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TRANSFER_FEE", VALUEFUNC(_wrap_MiscFeeType_TRANSFER_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_SECURITY_LENDING", VALUEFUNC(_wrap_MiscFeeType_SECURITY_LENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TRADE_REPORTING", VALUEFUNC(_wrap_MiscFeeType_TRADE_REPORTING_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TAX_ON_PRINCIPAL_AMOUNT", VALUEFUNC(_wrap_MiscFeeType_TAX_ON_PRINCIPAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TAX_ON_ACCRUED_INTEREST_AMOUNT", VALUEFUNC(_wrap_MiscFeeType_TAX_ON_ACCRUED_INTEREST_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_NEW_ISSUANCE_FEE", VALUEFUNC(_wrap_MiscFeeType_NEW_ISSUANCE_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_SERVICE_FEE", VALUEFUNC(_wrap_MiscFeeType_SERVICE_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_ODD_LOT_FEE", VALUEFUNC(_wrap_MiscFeeType_ODD_LOT_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_AUCTION_FEE", VALUEFUNC(_wrap_MiscFeeType_AUCTION_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_VALUE_ADDED_TAX", VALUEFUNC(_wrap_MiscFeeType_VALUE_ADDED_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_SALES_TAX", VALUEFUNC(_wrap_MiscFeeType_SALES_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_EXECUTION_FEE", VALUEFUNC(_wrap_MiscFeeType_EXECUTION_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_ORDER_ENTRY_FEE", VALUEFUNC(_wrap_MiscFeeType_ORDER_ENTRY_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_ORDER_MODIFICATION_FEE", VALUEFUNC(_wrap_MiscFeeType_ORDER_MODIFICATION_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_ORDERS_CANCELLATION_FEE", VALUEFUNC(_wrap_MiscFeeType_ORDERS_CANCELLATION_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_MARKET_DATA_ACCESS_FEE", VALUEFUNC(_wrap_MiscFeeType_MARKET_DATA_ACCESS_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_MARKET_DATA_TERMINAL_FEE", VALUEFUNC(_wrap_MiscFeeType_MARKET_DATA_TERMINAL_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_MARKET_DATA_VOLUME_FEE", VALUEFUNC(_wrap_MiscFeeType_MARKET_DATA_VOLUME_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_CLEARING_FEE", VALUEFUNC(_wrap_MiscFeeType_CLEARING_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_SETTLEMENT_FEE", VALUEFUNC(_wrap_MiscFeeType_SETTLEMENT_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_REBATES", VALUEFUNC(_wrap_MiscFeeType_REBATES_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_DISCOUNTS", VALUEFUNC(_wrap_MiscFeeType_DISCOUNTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_PAYMENTS", VALUEFUNC(_wrap_MiscFeeType_PAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_NON_MONETARY_PAYMENTS", VALUEFUNC(_wrap_MiscFeeType_NON_MONETARY_PAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_NEW", VALUEFUNC(_wrap_ExecType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PARTIAL_FILL", VALUEFUNC(_wrap_ExecType_PARTIAL_FILL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_FILL", VALUEFUNC(_wrap_ExecType_FILL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_DONE_FOR_DAY", VALUEFUNC(_wrap_ExecType_DONE_FOR_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_CANCELED", VALUEFUNC(_wrap_ExecType_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_REPLACED", VALUEFUNC(_wrap_ExecType_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_CANCEL", VALUEFUNC(_wrap_ExecType_PENDING_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_STOPPED", VALUEFUNC(_wrap_ExecType_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_REJECTED", VALUEFUNC(_wrap_ExecType_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_SUSPENDED", VALUEFUNC(_wrap_ExecType_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_NEW", VALUEFUNC(_wrap_ExecType_PENDING_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_CALCULATED", VALUEFUNC(_wrap_ExecType_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_EXPIRED", VALUEFUNC(_wrap_ExecType_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_RESTATED", VALUEFUNC(_wrap_ExecType_RESTATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_REPLACE", VALUEFUNC(_wrap_ExecType_PENDING_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE", VALUEFUNC(_wrap_ExecType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_CORRECT", VALUEFUNC(_wrap_ExecType_TRADE_CORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_CANCEL", VALUEFUNC(_wrap_ExecType_TRADE_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_ORDER_STATUS", VALUEFUNC(_wrap_ExecType_ORDER_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_IN_A_CLEARING_HOLD", VALUEFUNC(_wrap_ExecType_TRADE_IN_A_CLEARING_HOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_HAS_BEEN_RELEASED_TO_CLEARING", VALUEFUNC(_wrap_ExecType_TRADE_HAS_BEEN_RELEASED_TO_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRIGGERED_OR_ACTIVATED_BY_SYSTEM", VALUEFUNC(_wrap_ExecType_TRIGGERED_OR_ACTIVATED_BY_SYSTEM_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_LOCKED", VALUEFUNC(_wrap_ExecType_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_RELEASED", VALUEFUNC(_wrap_ExecType_RELEASED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlCurrFxRateCalc_DIVIDE", VALUEFUNC(_wrap_SettlCurrFxRateCalc_DIVIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlCurrFxRateCalc_MULTIPLY", VALUEFUNC(_wrap_SettlCurrFxRateCalc_MULTIPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_DEFAULT", VALUEFUNC(_wrap_SettlInstMode_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED", VALUEFUNC(_wrap_SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_OVERRIDING", VALUEFUNC(_wrap_SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_OVERRIDING_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_STANDING", VALUEFUNC(_wrap_SettlInstMode_SPECIFIC_ALLOCATION_ACCOUNT_STANDING_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT", VALUEFUNC(_wrap_SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_REQUEST_REJECT", VALUEFUNC(_wrap_SettlInstMode_REQUEST_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_CANCEL", VALUEFUNC(_wrap_SettlInstTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_NEW", VALUEFUNC(_wrap_SettlInstTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_REPLACE", VALUEFUNC(_wrap_SettlInstTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_RESTATE", VALUEFUNC(_wrap_SettlInstTransType_RESTATE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_BROKER_CREDIT", VALUEFUNC(_wrap_SettlInstSource_BROKER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_INSTITUTION", VALUEFUNC(_wrap_SettlInstSource_INSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_INVESTOR", VALUEFUNC(_wrap_SettlInstSource_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_CEDEL", VALUEFUNC(_wrap_SettlLocation_CEDEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_DEPOSITORY_TRUST_COMPANY", VALUEFUNC(_wrap_SettlLocation_DEPOSITORY_TRUST_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_EURO_CLEAR", VALUEFUNC(_wrap_SettlLocation_EURO_CLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_FEDERAL_BOOK_ENTRY", VALUEFUNC(_wrap_SettlLocation_FEDERAL_BOOK_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_LOCAL_MARKET_SETTLE_LOCATION", VALUEFUNC(_wrap_SettlLocation_LOCAL_MARKET_SETTLE_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_PHYSICAL", VALUEFUNC(_wrap_SettlLocation_PHYSICAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_PARTICIPANT_TRUST_COMPANY", VALUEFUNC(_wrap_SettlLocation_PARTICIPANT_TRUST_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANKERS_ACCEPTANCE", VALUEFUNC(_wrap_SecurityType_BANKERS_ACCEPTANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION", VALUEFUNC(_wrap_SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORPORATE_PRIVATE_PLACEMENT", VALUEFUNC(_wrap_SecurityType_CORPORATE_PRIVATE_PLACEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMON_STOCK", VALUEFUNC(_wrap_SecurityType_COMMON_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_HOUSING_AUTHORITY", VALUEFUNC(_wrap_SecurityType_FEDERAL_HOUSING_AUTHORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_HOME_LOAN", VALUEFUNC(_wrap_SecurityType_FEDERAL_HOME_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_NATIONAL_MORTGAGE_ASSOCIATION", VALUEFUNC(_wrap_SecurityType_FEDERAL_NATIONAL_MORTGAGE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FOREIGN_EXCHANGE_CONTRACT", VALUEFUNC(_wrap_SecurityType_FOREIGN_EXCHANGE_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FUTURE", VALUEFUNC(_wrap_SecurityType_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_GOVERNMENT_NATIONAL_MORTGAGE_ASSOCIATION", VALUEFUNC(_wrap_SecurityType_GOVERNMENT_NATIONAL_MORTGAGE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TREASURIES_AGENCY_DEBENTURE", VALUEFUNC(_wrap_SecurityType_TREASURIES_AGENCY_DEBENTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MUTUAL_FUND", VALUEFUNC(_wrap_SecurityType_MUTUAL_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_INTEREST_ONLY", VALUEFUNC(_wrap_SecurityType_MORTGAGE_INTEREST_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_PRINCIPAL_ONLY", VALUEFUNC(_wrap_SecurityType_MORTGAGE_PRINCIPAL_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_PRIVATE_PLACEMENT", VALUEFUNC(_wrap_SecurityType_MORTGAGE_PRIVATE_PLACEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MISCELLANEOUS_PASS_THROUGH", VALUEFUNC(_wrap_SecurityType_MISCELLANEOUS_PASS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MUNICIPAL_BOND", VALUEFUNC(_wrap_SecurityType_MUNICIPAL_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NO_SECURITY_TYPE", VALUEFUNC(_wrap_SecurityType_NO_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OPTION", VALUEFUNC(_wrap_SecurityType_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PREFERRED_STOCK", VALUEFUNC(_wrap_SecurityType_PREFERRED_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REPURCHASE_AGREEMENT", VALUEFUNC(_wrap_SecurityType_REPURCHASE_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVERSE_REPURCHASE_AGREEMENT", VALUEFUNC(_wrap_SecurityType_REVERSE_REPURCHASE_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_STUDENT_LOAN_MARKETING_ASSOCIATION", VALUEFUNC(_wrap_SecurityType_STUDENT_LOAN_MARKETING_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TIME_DEPOSIT", VALUEFUNC(_wrap_SecurityType_TIME_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_BILL_OLD", VALUEFUNC(_wrap_SecurityType_US_TREASURY_BILL_OLD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WARRANT", VALUEFUNC(_wrap_SecurityType_WARRANT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CATS_TIGERS_AND_LIONS", VALUEFUNC(_wrap_SecurityType_CATS_TIGERS_AND_LIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WILDCARD", VALUEFUNC(_wrap_SecurityType_WILDCARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CONVERTIBLE_BOND", VALUEFUNC(_wrap_SecurityType_CONVERTIBLE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_IOETTE_MORTGAGE", VALUEFUNC(_wrap_SecurityType_IOETTE_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_VARIABLE_RATE_DEMAND_NOTE", VALUEFUNC(_wrap_SecurityType_VARIABLE_RATE_DEMAND_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PLAZOS_FIJOS", VALUEFUNC(_wrap_SecurityType_PLAZOS_FIJOS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PROMISSORY_NOTE", VALUEFUNC(_wrap_SecurityType_PROMISSORY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OVERNIGHT", VALUEFUNC(_wrap_SecurityType_OVERNIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MEDIUM_TERM_NOTES", VALUEFUNC(_wrap_SecurityType_MEDIUM_TERM_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_AMENDED", VALUEFUNC(_wrap_SecurityType_AMENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BRIDGE_LOAN", VALUEFUNC(_wrap_SecurityType_BRIDGE_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_LETTER_OF_CREDIT", VALUEFUNC(_wrap_SecurityType_LETTER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SWING_LINE_FACILITY", VALUEFUNC(_wrap_SecurityType_SWING_LINE_FACILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEBTOR_IN_POSSESSION", VALUEFUNC(_wrap_SecurityType_DEBTOR_IN_POSSESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEFAULTED", VALUEFUNC(_wrap_SecurityType_DEFAULTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WITHDRAWN", VALUEFUNC(_wrap_SecurityType_WITHDRAWN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_LIQUIDITY_NOTE", VALUEFUNC(_wrap_SecurityType_LIQUIDITY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MATURED", VALUEFUNC(_wrap_SecurityType_MATURED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEPOSIT_NOTES", VALUEFUNC(_wrap_SecurityType_DEPOSIT_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_RETIRED", VALUEFUNC(_wrap_SecurityType_RETIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANK_NOTES", VALUEFUNC(_wrap_SecurityType_BANK_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BILL_OF_EXCHANGES", VALUEFUNC(_wrap_SecurityType_BILL_OF_EXCHANGES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CALL_LOANS", VALUEFUNC(_wrap_SecurityType_CALL_LOANS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REPLACED", VALUEFUNC(_wrap_SecurityType_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MANDATORY_TENDER", VALUEFUNC(_wrap_SecurityType_MANDATORY_TENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVOLVER", VALUEFUNC(_wrap_SecurityType_REVOLVER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SHORT_TERM_LOAN_NOTE", VALUEFUNC(_wrap_SecurityType_SHORT_TERM_LOAN_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TO_BE_ANNOUNCED", VALUEFUNC(_wrap_SecurityType_TO_BE_ANNOUNCED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OTHER_ANTICIPATION_NOTES", VALUEFUNC(_wrap_SecurityType_OTHER_ANTICIPATION_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_PARTICIPATION", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_BACKED_SECURITIES", VALUEFUNC(_wrap_SecurityType_MORTGAGE_BACKED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVENUE_BONDS", VALUEFUNC(_wrap_SecurityType_REVENUE_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_ASSESSMENT", VALUEFUNC(_wrap_SecurityType_SPECIAL_ASSESSMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_OBLIGATION", VALUEFUNC(_wrap_SecurityType_SPECIAL_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_TAX", VALUEFUNC(_wrap_SecurityType_SPECIAL_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_TAX_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_ALLOCATION", VALUEFUNC(_wrap_SecurityType_TAX_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_OBLIGATION", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_GENERAL_OBLIGATION_BONDS", VALUEFUNC(_wrap_SecurityType_GENERAL_OBLIGATION_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MULTILEG_INSTRUMENT", VALUEFUNC(_wrap_SecurityType_MULTILEG_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_REVENUE_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_TAX_REVENUE_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXTENDED_COMM_NOTE", VALUEFUNC(_wrap_SecurityType_EXTENDED_COMM_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_AGENCY_POOLS", VALUEFUNC(_wrap_SecurityType_AGENCY_POOLS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_ASSET_BACKED_SECURITIES", VALUEFUNC(_wrap_SecurityType_ASSET_BACKED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORP", VALUEFUNC(_wrap_SecurityType_CORP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVENUE_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_REVENUE_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVOLVER_LOAN", VALUEFUNC(_wrap_SecurityType_REVOLVER_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_AGENCY_COUPON", VALUEFUNC(_wrap_SecurityType_FEDERAL_AGENCY_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE", VALUEFUNC(_wrap_SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRIVATE_EXPORT_FUNDING", VALUEFUNC(_wrap_SecurityType_PRIVATE_EXPORT_FUNDING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DUAL_CURRENCY", VALUEFUNC(_wrap_SecurityType_DUAL_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INDEXED_LINKED", VALUEFUNC(_wrap_SecurityType_INDEXED_LINKED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_YANKEE_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_YANKEE_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BRADY_BOND", VALUEFUNC(_wrap_SecurityType_BRADY_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_BOND", VALUEFUNC(_wrap_SecurityType_US_TREASURY_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES", VALUEFUNC(_wrap_SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_NOTE_OLD", VALUEFUNC(_wrap_SecurityType_US_TREASURY_NOTE_OLD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TERM_LOAN", VALUEFUNC(_wrap_SecurityType_TERM_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_STRUCTURED_NOTES", VALUEFUNC(_wrap_SecurityType_STRUCTURED_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_SUPRANATIONAL_COUPONS", VALUEFUNC(_wrap_SecurityType_EURO_SUPRANATIONAL_COUPONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_USD_SUPRANATIONAL_COUPONS", VALUEFUNC(_wrap_SecurityType_USD_SUPRANATIONAL_COUPONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_EURO_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_SOVEREIGNS", VALUEFUNC(_wrap_SecurityType_EURO_SOVEREIGNS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_NOTE", VALUEFUNC(_wrap_SecurityType_US_TREASURY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_BILL", VALUEFUNC(_wrap_SecurityType_US_TREASURY_BILL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REPURCHASE", VALUEFUNC(_wrap_SecurityType_REPURCHASE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FORWARD", VALUEFUNC(_wrap_SecurityType_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BUY_SELLBACK", VALUEFUNC(_wrap_SecurityType_BUY_SELLBACK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURITIES_LOAN", VALUEFUNC(_wrap_SecurityType_SECURITIES_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURITIES_PLEDGE", VALUEFUNC(_wrap_SecurityType_SECURITIES_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_EURO_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_EURO_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PFANDBRIEFE", VALUEFUNC(_wrap_SecurityType_PFANDBRIEFE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OPTIONS_ON_FUTURES", VALUEFUNC(_wrap_SecurityType_OPTIONS_ON_FUTURES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OPTIONS_ON_PHYSICAL", VALUEFUNC(_wrap_SecurityType_OPTIONS_ON_PHYSICAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WILDCARD_ENTRY", VALUEFUNC(_wrap_SecurityType_WILDCARD_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CASH", VALUEFUNC(_wrap_SecurityType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_CORPORATE_FLOATING_RATE_NOTES", VALUEFUNC(_wrap_SecurityType_EURO_CORPORATE_FLOATING_RATE_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_CORPORATE_FLOATING_RATE_NOTES", VALUEFUNC(_wrap_SecurityType_US_CORPORATE_FLOATING_RATE_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CREDIT_DEFAULT_SWAP", VALUEFUNC(_wrap_SecurityType_CREDIT_DEFAULT_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INTEREST_RATE_SWAP", VALUEFUNC(_wrap_SecurityType_INTEREST_RATE_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OPTIONS_ON_COMBO", VALUEFUNC(_wrap_SecurityType_OPTIONS_ON_COMBO_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CANADIAN_TREASURY_NOTES", VALUEFUNC(_wrap_SecurityType_CANADIAN_TREASURY_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CANADIAN_TREASURY_BILLS", VALUEFUNC(_wrap_SecurityType_CANADIAN_TREASURY_BILLS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CANADIAN_PROVINCIAL_BONDS", VALUEFUNC(_wrap_SecurityType_CANADIAN_PROVINCIAL_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TREASURY_BILL", VALUEFUNC(_wrap_SecurityType_TREASURY_BILL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANK_DEPOSITORY_NOTE", VALUEFUNC(_wrap_SecurityType_BANK_DEPOSITORY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CANADIAN_MONEY_MARKETS", VALUEFUNC(_wrap_SecurityType_CANADIAN_MONEY_MARKETS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURED_LIQUIDITY_NOTE", VALUEFUNC(_wrap_SecurityType_SECURED_LIQUIDITY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TERM_LIQUIDITY_NOTE", VALUEFUNC(_wrap_SecurityType_TERM_LIQUIDITY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CANADIAN_MORTGAGE_BONDS", VALUEFUNC(_wrap_SecurityType_CANADIAN_MORTGAGE_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAXABLE_MUNICIPAL_CP", VALUEFUNC(_wrap_SecurityType_TAXABLE_MUNICIPAL_CP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PREFERRED_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_PREFERRED_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NON_DELIVERABLE_FORWARD", VALUEFUNC(_wrap_SecurityType_NON_DELIVERABLE_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FX_SPOT", VALUEFUNC(_wrap_SecurityType_FX_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FX_FORWARD", VALUEFUNC(_wrap_SecurityType_FX_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FX_SWAP", VALUEFUNC(_wrap_SecurityType_FX_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NON_DELIVERABLE_SWAP", VALUEFUNC(_wrap_SecurityType_NON_DELIVERABLE_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FX_BANK_NOTE", VALUEFUNC(_wrap_SecurityType_FX_BANK_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FOREIGN_CURRENCY_DISCOUNT_NOTE", VALUEFUNC(_wrap_SecurityType_FOREIGN_CURRENCY_DISCOUNT_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CAP", VALUEFUNC(_wrap_SecurityType_CAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COLLAR", VALUEFUNC(_wrap_SecurityType_COLLAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMODITY_SWAP", VALUEFUNC(_wrap_SecurityType_COMMODITY_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXOTIC", VALUEFUNC(_wrap_SecurityType_EXOTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FLOOR", VALUEFUNC(_wrap_SecurityType_FLOOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FRA", VALUEFUNC(_wrap_SecurityType_FRA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DERIVATIVE_FORWARD", VALUEFUNC(_wrap_SecurityType_DERIVATIVE_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TOTAL_RETURN_SWAP", VALUEFUNC(_wrap_SecurityType_TOTAL_RETURN_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_LOAN_LEASE", VALUEFUNC(_wrap_SecurityType_LOAN_LEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPOT_FORWARD", VALUEFUNC(_wrap_SecurityType_SPOT_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SWAP_OPTION", VALUEFUNC(_wrap_SecurityType_SWAP_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TRANSMISSION", VALUEFUNC(_wrap_SecurityType_TRANSMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INDEX", VALUEFUNC(_wrap_SecurityType_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BOND_BASKET", VALUEFUNC(_wrap_SecurityType_BOND_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CONTRACT_FOR_DIFFERENCE", VALUEFUNC(_wrap_SecurityType_CONTRACT_FOR_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORRELATION_SWAP", VALUEFUNC(_wrap_SecurityType_CORRELATION_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DIVIEND_SWAP", VALUEFUNC(_wrap_SecurityType_DIVIEND_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EQUITY_BASKET", VALUEFUNC(_wrap_SecurityType_EQUITY_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EQUITY_FORWARD", VALUEFUNC(_wrap_SecurityType_EQUITY_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_RETURN_SWAP", VALUEFUNC(_wrap_SecurityType_RETURN_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_VARIANCE_SWAP", VALUEFUNC(_wrap_SecurityType_VARIANCE_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PORTFOLIO_SWAPS", VALUEFUNC(_wrap_SecurityType_PORTFOLIO_SWAPS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FUTURES_ON_A_SWAP", VALUEFUNC(_wrap_SecurityType_FUTURES_ON_A_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FORWARDS_ON_A_SWAP", VALUEFUNC(_wrap_SecurityType_FORWARDS_ON_A_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FORWARD_FREIGHT_AGREEMENT", VALUEFUNC(_wrap_SecurityType_FORWARD_FREIGHT_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPREAD_BETTING", VALUEFUNC(_wrap_SecurityType_SPREAD_BETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXCHANGE_TRADED_COMMODITY", VALUEFUNC(_wrap_SecurityType_EXCHANGE_TRADED_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEPOSITORY_RECEIPTS", VALUEFUNC(_wrap_SecurityType_DEPOSITORY_RECEIPTS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DELIVERY_VERSUS_PLEDGE", VALUEFUNC(_wrap_SecurityType_DELIVERY_VERSUS_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COLLATERAL_BASKET", VALUEFUNC(_wrap_SecurityType_COLLATERAL_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_STRUCTURED_FINANCE_PRODUCT", VALUEFUNC(_wrap_SecurityType_STRUCTURED_FINANCE_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MARGIN_LOAN", VALUEFUNC(_wrap_SecurityType_MARGIN_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_SOVEREIGN_BOND", VALUEFUNC(_wrap_SecurityType_OFFSHORE_ISSUED_CHINESE_YUAN_SOVEREIGN_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SOVEREIGN_BOND", VALUEFUNC(_wrap_SecurityType_SOVEREIGN_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_FLOATING_RATE_NOTE", VALUEFUNC(_wrap_SecurityType_US_TREASURY_FLOATING_RATE_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANK_ACCEPTED_BILL", VALUEFUNC(_wrap_SecurityType_BANK_ACCEPTED_BILL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SHORT_TERM_BANK_NOTE", VALUEFUNC(_wrap_SecurityType_SHORT_TERM_BANK_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CALLABLE_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_CALLABLE_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMERCIAL_NOTE", VALUEFUNC(_wrap_SecurityType_COMMERCIAL_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INTEREST_BEARING_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_INTEREST_BEARING_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_MEDIUM_TERM_NOTE", VALUEFUNC(_wrap_SecurityType_EURO_MEDIUM_TERM_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_NEGOTIABLE_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_EURO_NEGOTIABLE_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_STRUCTURED_LIQUIDITY_NOTE", VALUEFUNC(_wrap_SecurityType_EURO_STRUCTURED_LIQUIDITY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_TIME_DEPOSIT", VALUEFUNC(_wrap_SecurityType_EURO_TIME_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_JUMBO_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_JUMBO_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MONEY_MARKET_FUND", VALUEFUNC(_wrap_SecurityType_MONEY_MARKET_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MASTER_NOTE", VALUEFUNC(_wrap_SecurityType_MASTER_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NEGOTIABLE_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_NEGOTIABLE_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NEGOTIABLE_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_NEGOTIABLE_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_RETAIL_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_RETAIL_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TERM_DEPOSIT_RECEIPT", VALUEFUNC(_wrap_SecurityType_TERM_DEPOSIT_RECEIPT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PFANDBRIEF", VALUEFUNC(_wrap_SecurityType_PFANDBRIEF_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MUNICIPAL_INTEREST_BEARING_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_MUNICIPAL_INTEREST_BEARING_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAXABLE_MUNICIPAL_BOND", VALUEFUNC(_wrap_SecurityType_TAXABLE_MUNICIPAL_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_VARIABLE_RATE_DEMAND_OBLIGATION", VALUEFUNC(_wrap_SecurityType_VARIABLE_RATE_DEMAND_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OTHER", VALUEFUNC(_wrap_SecurityType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXCHANGE_TRADED_NOTE", VALUEFUNC(_wrap_SecurityType_EXCHANGE_TRADED_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURITIZED_DERIVATIVE", VALUEFUNC(_wrap_SecurityType_SECURITIZED_DERIVATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXCHANGE_TRADED_FUND", VALUEFUNC(_wrap_SecurityType_EXCHANGE_TRADED_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DIGITAL_ASSET", VALUEFUNC(_wrap_SecurityType_DIGITAL_ASSET_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_OTHER", VALUEFUNC(_wrap_StandInstDbType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_DTCSID", VALUEFUNC(_wrap_StandInstDbType_DTCSID_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_THOMSON_ALERT", VALUEFUNC(_wrap_StandInstDbType_THOMSON_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_A_GLOBAL_CUSTODIAN", VALUEFUNC(_wrap_StandInstDbType_A_GLOBAL_CUSTODIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_ACCOUNT_NET", VALUEFUNC(_wrap_StandInstDbType_ACCOUNT_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_FREE", VALUEFUNC(_wrap_SettlDeliveryType_FREE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_VERSUS", VALUEFUNC(_wrap_SettlDeliveryType_VERSUS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_TRI_PARTY", VALUEFUNC(_wrap_SettlDeliveryType_TRI_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_HOLD_IN_CUSTODY", VALUEFUNC(_wrap_SettlDeliveryType_HOLD_IN_CUSTODY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocLinkType_FX_NETTING", VALUEFUNC(_wrap_AllocLinkType_FX_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocLinkType_FX_SWAP", VALUEFUNC(_wrap_AllocLinkType_FX_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_PUT", VALUEFUNC(_wrap_PutOrCall_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_CALL", VALUEFUNC(_wrap_PutOrCall_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_OTHER", VALUEFUNC(_wrap_PutOrCall_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_CHOOSER", VALUEFUNC(_wrap_PutOrCall_CHOOSER_get), 0);
  rb_define_singleton_method(mQuickfix, "CoveredOrUncovered_COVERED", VALUEFUNC(_wrap_CoveredOrUncovered_COVERED_get), 0);
  rb_define_singleton_method(mQuickfix, "CoveredOrUncovered_UNCOVERED", VALUEFUNC(_wrap_CoveredOrUncovered_UNCOVERED_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerOrFirm_CUSTOMER", VALUEFUNC(_wrap_CustomerOrFirm_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerOrFirm_FIRM", VALUEFUNC(_wrap_CustomerOrFirm_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "NotifyBrokerOfCredit_NO", VALUEFUNC(_wrap_NotifyBrokerOfCredit_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "NotifyBrokerOfCredit_YES", VALUEFUNC(_wrap_NotifyBrokerOfCredit_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_MATCH", VALUEFUNC(_wrap_AllocHandlInst_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_FORWARD", VALUEFUNC(_wrap_AllocHandlInst_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_FORWARD_AND_MATCH", VALUEFUNC(_wrap_AllocHandlInst_FORWARD_AND_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_AUTO_CLAIM_GIVE_UP", VALUEFUNC(_wrap_AllocHandlInst_AUTO_CLAIM_GIVE_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_TARGET_FIRM", VALUEFUNC(_wrap_RoutingType_TARGET_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_TARGET_LIST", VALUEFUNC(_wrap_RoutingType_TARGET_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_BLOCK_FIRM", VALUEFUNC(_wrap_RoutingType_BLOCK_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_BLOCK_LIST", VALUEFUNC(_wrap_RoutingType_BLOCK_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_TARGET_PERSON", VALUEFUNC(_wrap_RoutingType_TARGET_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_BLOCK_PERSON", VALUEFUNC(_wrap_RoutingType_BLOCK_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_CURVE", VALUEFUNC(_wrap_Benchmark_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_FIVE_YR", VALUEFUNC(_wrap_Benchmark_FIVE_YR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD5", VALUEFUNC(_wrap_Benchmark_OLD5_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_TEN_YR", VALUEFUNC(_wrap_Benchmark_TEN_YR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD10", VALUEFUNC(_wrap_Benchmark_OLD10_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_THIRTY_YR", VALUEFUNC(_wrap_Benchmark_THIRTY_YR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD30", VALUEFUNC(_wrap_Benchmark_OLD30_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_THREE_MOLIBOR", VALUEFUNC(_wrap_Benchmark_THREE_MOLIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_SIX_MOLIBOR", VALUEFUNC(_wrap_Benchmark_SIX_MOLIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_SNAPSHOT", VALUEFUNC(_wrap_SubscriptionRequestType_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_SNAPSHOT_AND_UPDATES", VALUEFUNC(_wrap_SubscriptionRequestType_SNAPSHOT_AND_UPDATES_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT", VALUEFUNC(_wrap_SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateType_FULL_REFRESH", VALUEFUNC(_wrap_MDUpdateType_FULL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateType_INCREMENTAL_REFRESH", VALUEFUNC(_wrap_MDUpdateType_INCREMENTAL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "AggregatedBook_NO", VALUEFUNC(_wrap_AggregatedBook_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "AggregatedBook_YES", VALUEFUNC(_wrap_AggregatedBook_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_BID", VALUEFUNC(_wrap_MDEntryType_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OFFER", VALUEFUNC(_wrap_MDEntryType_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADE", VALUEFUNC(_wrap_MDEntryType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_INDEX_VALUE", VALUEFUNC(_wrap_MDEntryType_INDEX_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OPENING_PRICE", VALUEFUNC(_wrap_MDEntryType_OPENING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_CLOSING_PRICE", VALUEFUNC(_wrap_MDEntryType_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SETTLEMENT_PRICE", VALUEFUNC(_wrap_MDEntryType_SETTLEMENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_HIGH_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_HIGH_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_LOW_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_LOW_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_VWAP_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_VWAP_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_IMBALANCE", VALUEFUNC(_wrap_MDEntryType_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADE_VOLUME", VALUEFUNC(_wrap_MDEntryType_TRADE_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OPEN_INTEREST", VALUEFUNC(_wrap_MDEntryType_OPEN_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_COMPOSITE_UNDERLYING_PRICE", VALUEFUNC(_wrap_MDEntryType_COMPOSITE_UNDERLYING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SIMULATED_SELL_PRICE", VALUEFUNC(_wrap_MDEntryType_SIMULATED_SELL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SIMULATED_BUY_PRICE", VALUEFUNC(_wrap_MDEntryType_SIMULATED_BUY_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_MARGIN_RATE", VALUEFUNC(_wrap_MDEntryType_MARGIN_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_MID_PRICE", VALUEFUNC(_wrap_MDEntryType_MID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_EMPTY_BOOK", VALUEFUNC(_wrap_MDEntryType_EMPTY_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SETTLE_HIGH_PRICE", VALUEFUNC(_wrap_MDEntryType_SETTLE_HIGH_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SETTLE_LOW_PRICE", VALUEFUNC(_wrap_MDEntryType_SETTLE_LOW_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_PRIOR_SETTLE_PRICE", VALUEFUNC(_wrap_MDEntryType_PRIOR_SETTLE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SESSION_HIGH_BID", VALUEFUNC(_wrap_MDEntryType_SESSION_HIGH_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SESSION_LOW_OFFER", VALUEFUNC(_wrap_MDEntryType_SESSION_LOW_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_EARLY_PRICES", VALUEFUNC(_wrap_MDEntryType_EARLY_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_AUCTION_CLEARING_PRICE", VALUEFUNC(_wrap_MDEntryType_AUCTION_CLEARING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SWAP_VALUE_FACTOR", VALUEFUNC(_wrap_MDEntryType_SWAP_VALUE_FACTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS", VALUEFUNC(_wrap_MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS", VALUEFUNC(_wrap_MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_LONG_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS", VALUEFUNC(_wrap_MDEntryType_DAILY_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS", VALUEFUNC(_wrap_MDEntryType_CUMULATIVE_VALUE_ADJUSTMENT_FOR_SHORT_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_VWAP", VALUEFUNC(_wrap_MDEntryType_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_FIXING_PRICE", VALUEFUNC(_wrap_MDEntryType_FIXING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_CASH_RATE", VALUEFUNC(_wrap_MDEntryType_CASH_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_RECOVERY_RATE", VALUEFUNC(_wrap_MDEntryType_RECOVERY_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_RECOVERY_RATE_FOR_LONG", VALUEFUNC(_wrap_MDEntryType_RECOVERY_RATE_FOR_LONG_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_RECOVERY_RATE_FOR_SHORT", VALUEFUNC(_wrap_MDEntryType_RECOVERY_RATE_FOR_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_MARKET_BID", VALUEFUNC(_wrap_MDEntryType_MARKET_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_MARKET_OFFER", VALUEFUNC(_wrap_MDEntryType_MARKET_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SHORT_SALE_MIN_PRICE", VALUEFUNC(_wrap_MDEntryType_SHORT_SALE_MIN_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_PREVIOUS_CLOSING_PRICE", VALUEFUNC(_wrap_MDEntryType_PREVIOUS_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_THRESHOLD_LIMIT_PRICE_BANDING", VALUEFUNC(_wrap_MDEntryType_THRESHOLD_LIMIT_PRICE_BANDING_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_DAILY_FINANCING_VALUE", VALUEFUNC(_wrap_MDEntryType_DAILY_FINANCING_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_ACCRUED_FINANCING_VALUE", VALUEFUNC(_wrap_MDEntryType_ACCRUED_FINANCING_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TWAP", VALUEFUNC(_wrap_MDEntryType_TWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_PLUS_TICK", VALUEFUNC(_wrap_TickDirection_PLUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_ZERO_PLUS_TICK", VALUEFUNC(_wrap_TickDirection_ZERO_PLUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_MINUS_TICK", VALUEFUNC(_wrap_TickDirection_MINUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_ZERO_MINUS_TICK", VALUEFUNC(_wrap_TickDirection_ZERO_MINUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OPEN", VALUEFUNC(_wrap_QuoteCondition_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CLOSED", VALUEFUNC(_wrap_QuoteCondition_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_EXCHANGE_BEST", VALUEFUNC(_wrap_QuoteCondition_EXCHANGE_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CONSOLIDATED_BEST", VALUEFUNC(_wrap_QuoteCondition_CONSOLIDATED_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_LOCKED", VALUEFUNC(_wrap_QuoteCondition_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CROSSED", VALUEFUNC(_wrap_QuoteCondition_CROSSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DEPTH", VALUEFUNC(_wrap_QuoteCondition_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FAST_TRADING", VALUEFUNC(_wrap_QuoteCondition_FAST_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NON_FIRM", VALUEFUNC(_wrap_QuoteCondition_NON_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_MANUAL", VALUEFUNC(_wrap_QuoteCondition_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OUTRIGHT_PRICE", VALUEFUNC(_wrap_QuoteCondition_OUTRIGHT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_IMPLIED_PRICE", VALUEFUNC(_wrap_QuoteCondition_IMPLIED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DEPTH_ON_OFFER", VALUEFUNC(_wrap_QuoteCondition_DEPTH_ON_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DEPTH_ON_BID", VALUEFUNC(_wrap_QuoteCondition_DEPTH_ON_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CLOSING", VALUEFUNC(_wrap_QuoteCondition_CLOSING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NEWS_DISSEMINATION", VALUEFUNC(_wrap_QuoteCondition_NEWS_DISSEMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_TRADING_RANGE", VALUEFUNC(_wrap_QuoteCondition_TRADING_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ORDER_INFLUX", VALUEFUNC(_wrap_QuoteCondition_ORDER_INFLUX_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DUE_TO_RELATED", VALUEFUNC(_wrap_QuoteCondition_DUE_TO_RELATED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NEWS_PENDING", VALUEFUNC(_wrap_QuoteCondition_NEWS_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ADDITIONAL_INFO", VALUEFUNC(_wrap_QuoteCondition_ADDITIONAL_INFO_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ADDITIONAL_INFO_DUE_TO_RELATED", VALUEFUNC(_wrap_QuoteCondition_ADDITIONAL_INFO_DUE_TO_RELATED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_RESUME", VALUEFUNC(_wrap_QuoteCondition_RESUME_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_VIEW_OF_COMMON", VALUEFUNC(_wrap_QuoteCondition_VIEW_OF_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_VOLUME_ALERT", VALUEFUNC(_wrap_QuoteCondition_VOLUME_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ORDER_IMBALANCE", VALUEFUNC(_wrap_QuoteCondition_ORDER_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_EQUIPMENT_CHANGEOVER", VALUEFUNC(_wrap_QuoteCondition_EQUIPMENT_CHANGEOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NO_OPEN", VALUEFUNC(_wrap_QuoteCondition_NO_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_REGULAR_ETH", VALUEFUNC(_wrap_QuoteCondition_REGULAR_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_AUTOMATIC_EXECUTION", VALUEFUNC(_wrap_QuoteCondition_AUTOMATIC_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_AUTOMATIC_EXECUTION_ETH", VALUEFUNC(_wrap_QuoteCondition_AUTOMATIC_EXECUTION_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FAST_MARKET_ETH", VALUEFUNC(_wrap_QuoteCondition_FAST_MARKET_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_INACTIVE_ETH", VALUEFUNC(_wrap_QuoteCondition_INACTIVE_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ROTATION", VALUEFUNC(_wrap_QuoteCondition_ROTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_ROTATION_ETH", VALUEFUNC(_wrap_QuoteCondition_ROTATION_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_HALT", VALUEFUNC(_wrap_QuoteCondition_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_HALT_ETH", VALUEFUNC(_wrap_QuoteCondition_HALT_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DUE_TO_NEWS_DISSEMINATION", VALUEFUNC(_wrap_QuoteCondition_DUE_TO_NEWS_DISSEMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DUE_TO_NEWS_PENDING", VALUEFUNC(_wrap_QuoteCondition_DUE_TO_NEWS_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_TRADING_RESUME", VALUEFUNC(_wrap_QuoteCondition_TRADING_RESUME_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OUT_OF_SEQUENCE", VALUEFUNC(_wrap_QuoteCondition_OUT_OF_SEQUENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_BID_SPECIALIST", VALUEFUNC(_wrap_QuoteCondition_BID_SPECIALIST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OFFER_SPECIALIST", VALUEFUNC(_wrap_QuoteCondition_OFFER_SPECIALIST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_BID_OFFER_SPECIALIST", VALUEFUNC(_wrap_QuoteCondition_BID_OFFER_SPECIALIST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_END_OF_DAY_SAM", VALUEFUNC(_wrap_QuoteCondition_END_OF_DAY_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FORBIDDEN_SAM", VALUEFUNC(_wrap_QuoteCondition_FORBIDDEN_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FROZEN_SAM", VALUEFUNC(_wrap_QuoteCondition_FROZEN_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_PRE_OPENING_SAM", VALUEFUNC(_wrap_QuoteCondition_PRE_OPENING_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OPENING_SAM", VALUEFUNC(_wrap_QuoteCondition_OPENING_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OPEN_SAM", VALUEFUNC(_wrap_QuoteCondition_OPEN_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_SURVEILLANCE_SAM", VALUEFUNC(_wrap_QuoteCondition_SURVEILLANCE_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_SUSPENDED_SAM", VALUEFUNC(_wrap_QuoteCondition_SUSPENDED_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_RESERVED_SAM", VALUEFUNC(_wrap_QuoteCondition_RESERVED_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NO_ACTIVE_SAM", VALUEFUNC(_wrap_QuoteCondition_NO_ACTIVE_SAM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_RESTRICTED", VALUEFUNC(_wrap_QuoteCondition_RESTRICTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_REST_OF_BOOK_VWAP", VALUEFUNC(_wrap_QuoteCondition_REST_OF_BOOK_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_BETTER_PRICES_IN_CONDITIONAL_ORDERS", VALUEFUNC(_wrap_QuoteCondition_BETTER_PRICES_IN_CONDITIONAL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_MEDIAN_PRICE", VALUEFUNC(_wrap_QuoteCondition_MEDIAN_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FULL_CURVE", VALUEFUNC(_wrap_QuoteCondition_FULL_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FLAT_CURVE", VALUEFUNC(_wrap_QuoteCondition_FLAT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CASH", VALUEFUNC(_wrap_TradeCondition_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_AVERAGE_PRICE_TRADE", VALUEFUNC(_wrap_TradeCondition_AVERAGE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CASH_TRADE", VALUEFUNC(_wrap_TradeCondition_CASH_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_NEXT_DAY", VALUEFUNC(_wrap_TradeCondition_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENING", VALUEFUNC(_wrap_TradeCondition_OPENING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_INTRADAY_TRADE_DETAIL", VALUEFUNC(_wrap_TradeCondition_INTRADAY_TRADE_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_RULE127_TRADE", VALUEFUNC(_wrap_TradeCondition_RULE127_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_RULE155_TRADE", VALUEFUNC(_wrap_TradeCondition_RULE155_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD_LAST", VALUEFUNC(_wrap_TradeCondition_SOLD_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_NEXT_DAY_TRADE", VALUEFUNC(_wrap_TradeCondition_NEXT_DAY_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENED", VALUEFUNC(_wrap_TradeCondition_OPENED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SELLER", VALUEFUNC(_wrap_TradeCondition_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD", VALUEFUNC(_wrap_TradeCondition_SOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED_STOCK", VALUEFUNC(_wrap_TradeCondition_STOPPED_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_IMBALANCE_MORE_BUYERS", VALUEFUNC(_wrap_TradeCondition_IMBALANCE_MORE_BUYERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_IMBALANCE_MORE_SELLERS", VALUEFUNC(_wrap_TradeCondition_IMBALANCE_MORE_SELLERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENING_PRICE", VALUEFUNC(_wrap_TradeCondition_OPENING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BARGAIN_CONDITION", VALUEFUNC(_wrap_TradeCondition_BARGAIN_CONDITION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CONVERTED_PRICE_INDICATOR", VALUEFUNC(_wrap_TradeCondition_CONVERTED_PRICE_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_EXCHANGE_LAST", VALUEFUNC(_wrap_TradeCondition_EXCHANGE_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_FINAL_PRICE_OF_SESSION", VALUEFUNC(_wrap_TradeCondition_FINAL_PRICE_OF_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_EX_PIT", VALUEFUNC(_wrap_TradeCondition_EX_PIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CROSSED", VALUEFUNC(_wrap_TradeCondition_CROSSED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_TRADES_RESULTING_FROM_MANUAL", VALUEFUNC(_wrap_TradeCondition_TRADES_RESULTING_FROM_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_TRADES_RESULTING_FROM_INTERMARKET_SWEEP", VALUEFUNC(_wrap_TradeCondition_TRADES_RESULTING_FROM_INTERMARKET_SWEEP_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_VOLUME_ONLY", VALUEFUNC(_wrap_TradeCondition_VOLUME_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_DIRECT_PLUS", VALUEFUNC(_wrap_TradeCondition_DIRECT_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_ACQUISITION", VALUEFUNC(_wrap_TradeCondition_ACQUISITION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BUNCHED", VALUEFUNC(_wrap_TradeCondition_BUNCHED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_DISTRIBUTION", VALUEFUNC(_wrap_TradeCondition_DISTRIBUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BUNCHED_SALE", VALUEFUNC(_wrap_TradeCondition_BUNCHED_SALE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SPLIT_TRADE", VALUEFUNC(_wrap_TradeCondition_SPLIT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_STOPPED", VALUEFUNC(_wrap_TradeCondition_CANCEL_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_ETH", VALUEFUNC(_wrap_TradeCondition_CANCEL_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_STOPPED_ETH", VALUEFUNC(_wrap_TradeCondition_CANCEL_STOPPED_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OUT_OF_SEQUENCE_ETH", VALUEFUNC(_wrap_TradeCondition_OUT_OF_SEQUENCE_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_LAST_ETH", VALUEFUNC(_wrap_TradeCondition_CANCEL_LAST_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD_LAST_SALE_ETH", VALUEFUNC(_wrap_TradeCondition_SOLD_LAST_SALE_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_LAST", VALUEFUNC(_wrap_TradeCondition_CANCEL_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD_LAST_SALE", VALUEFUNC(_wrap_TradeCondition_SOLD_LAST_SALE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_OPEN", VALUEFUNC(_wrap_TradeCondition_CANCEL_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_OPEN_ETH", VALUEFUNC(_wrap_TradeCondition_CANCEL_OPEN_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENED_SALE_ETH", VALUEFUNC(_wrap_TradeCondition_OPENED_SALE_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_ONLY", VALUEFUNC(_wrap_TradeCondition_CANCEL_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL_ONLY_ETH", VALUEFUNC(_wrap_TradeCondition_CANCEL_ONLY_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_LATE_OPEN_ETH", VALUEFUNC(_wrap_TradeCondition_LATE_OPEN_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_AUTO_EXECUTION_ETH", VALUEFUNC(_wrap_TradeCondition_AUTO_EXECUTION_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_REOPEN", VALUEFUNC(_wrap_TradeCondition_REOPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_REOPEN_ETH", VALUEFUNC(_wrap_TradeCondition_REOPEN_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_ADJUSTED", VALUEFUNC(_wrap_TradeCondition_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_ADJUSTED_ETH", VALUEFUNC(_wrap_TradeCondition_ADJUSTED_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SPREAD", VALUEFUNC(_wrap_TradeCondition_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SPREAD_ETH", VALUEFUNC(_wrap_TradeCondition_SPREAD_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STRADDLE", VALUEFUNC(_wrap_TradeCondition_STRADDLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STRADDLE_ETH", VALUEFUNC(_wrap_TradeCondition_STRADDLE_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED", VALUEFUNC(_wrap_TradeCondition_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED_ETH", VALUEFUNC(_wrap_TradeCondition_STOPPED_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_REGULAR_ETH", VALUEFUNC(_wrap_TradeCondition_REGULAR_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_COMBO", VALUEFUNC(_wrap_TradeCondition_COMBO_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_COMBO_ETH", VALUEFUNC(_wrap_TradeCondition_COMBO_ETH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OFFICIAL_CLOSING_PRICE", VALUEFUNC(_wrap_TradeCondition_OFFICIAL_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_PRIOR_REFERENCE_PRICE", VALUEFUNC(_wrap_TradeCondition_PRIOR_REFERENCE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CANCEL", VALUEFUNC(_wrap_TradeCondition_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED_SOLD_LAST", VALUEFUNC(_wrap_TradeCondition_STOPPED_SOLD_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED_OUT_OF_SEQUENCE", VALUEFUNC(_wrap_TradeCondition_STOPPED_OUT_OF_SEQUENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OFFICAL_CLOSING_PRICE", VALUEFUNC(_wrap_TradeCondition_OFFICAL_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CROSSED_OLD", VALUEFUNC(_wrap_TradeCondition_CROSSED_OLD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_FAST_MARKET", VALUEFUNC(_wrap_TradeCondition_FAST_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_AUTOMATIC_EXECUTION", VALUEFUNC(_wrap_TradeCondition_AUTOMATIC_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_FORM_T", VALUEFUNC(_wrap_TradeCondition_FORM_T_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BASKET_INDEX", VALUEFUNC(_wrap_TradeCondition_BASKET_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BURST_BASKET", VALUEFUNC(_wrap_TradeCondition_BURST_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OUTSIDE_SPREAD", VALUEFUNC(_wrap_TradeCondition_OUTSIDE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_IMPLIED_TRADE", VALUEFUNC(_wrap_TradeCondition_IMPLIED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_MARKETPLACE_ENTERED_TRADE", VALUEFUNC(_wrap_TradeCondition_MARKETPLACE_ENTERED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_MULT_ASSET_CLASS_MULTILEG_TRADE", VALUEFUNC(_wrap_TradeCondition_MULT_ASSET_CLASS_MULTILEG_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_MULTILEG_TO_MULTILEG_TRADE", VALUEFUNC(_wrap_TradeCondition_MULTILEG_TO_MULTILEG_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OFFICIAL_CLOSING_PRICE_DUP", VALUEFUNC(_wrap_TradeCondition_OFFICIAL_CLOSING_PRICE_DUP_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_TRADE_THROUGH_EXEMPT", VALUEFUNC(_wrap_TradeCondition_TRADE_THROUGH_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_QUOTE_SPREAD", VALUEFUNC(_wrap_TradeCondition_QUOTE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_LAST_AUCTION_PRICE", VALUEFUNC(_wrap_TradeCondition_LAST_AUCTION_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_HIGH_PRICE", VALUEFUNC(_wrap_TradeCondition_HIGH_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_LOW_PRICE", VALUEFUNC(_wrap_TradeCondition_LOW_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SYSTEMATIC_INTERNALISER", VALUEFUNC(_wrap_TradeCondition_SYSTEMATIC_INTERNALISER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_AWAY_MARKET", VALUEFUNC(_wrap_TradeCondition_AWAY_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_MIDPOINT_PRICE", VALUEFUNC(_wrap_TradeCondition_MIDPOINT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_TRADED_BEFORE_ISSUE_DATE", VALUEFUNC(_wrap_TradeCondition_TRADED_BEFORE_ISSUE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_PREVIOUS_CLOSING_PRICE", VALUEFUNC(_wrap_TradeCondition_PREVIOUS_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_NATIONAL_BEST_BID_OFFER", VALUEFUNC(_wrap_TradeCondition_NATIONAL_BEST_BID_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_MULTI_ASSET_CLASS_MULTILEG_TRADE", VALUEFUNC(_wrap_TradeCondition_MULTI_ASSET_CLASS_MULTILEG_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SHORT_SALE_MIN_PRICE", VALUEFUNC(_wrap_TradeCondition_SHORT_SALE_MIN_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_BENCHMARK", VALUEFUNC(_wrap_TradeCondition_BENCHMARK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_NEW", VALUEFUNC(_wrap_MDUpdateAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_CHANGE", VALUEFUNC(_wrap_MDUpdateAction_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_DELETE", VALUEFUNC(_wrap_MDUpdateAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_DELETE_THRU", VALUEFUNC(_wrap_MDUpdateAction_DELETE_THRU_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_DELETE_FROM", VALUEFUNC(_wrap_MDUpdateAction_DELETE_FROM_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_OVERLAY", VALUEFUNC(_wrap_MDUpdateAction_OVERLAY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_MDReqRejReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_DUPLICATE_MD_REQ_ID", VALUEFUNC(_wrap_MDReqRejReason_DUPLICATE_MD_REQ_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_INSUFFICIENT_BANDWIDTH", VALUEFUNC(_wrap_MDReqRejReason_INSUFFICIENT_BANDWIDTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_INSUFFICIENT_PERMISSIONS", VALUEFUNC(_wrap_MDReqRejReason_INSUFFICIENT_PERMISSIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_SUBSCRIPTION_REQUEST_TYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_SUBSCRIPTION_REQUEST_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MARKET_DEPTH", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MARKET_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MD_UPDATE_TYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MD_UPDATE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_AGGREGATED_BOOK", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_AGGREGATED_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MD_ENTRY_TYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MD_ENTRY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MD_IMPLICIT_DELETE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MD_IMPLICIT_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_OPEN_CLOSE_SETTLE_FLAG", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_OPEN_CLOSE_SETTLE_FLAG_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_SCOPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_TRADING_SESSION_ID", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_TRADING_SESSION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_INSUFFICIENT_CREDIT", VALUEFUNC(_wrap_MDReqRejReason_INSUFFICIENT_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DeleteReason_CANCELLATION", VALUEFUNC(_wrap_DeleteReason_CANCELLATION_get), 0);
  rb_define_singleton_method(mQuickfix, "DeleteReason_ERROR", VALUEFUNC(_wrap_DeleteReason_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_DAILY_OPEN", VALUEFUNC(_wrap_OpenCloseSettleFlag_DAILY_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_SESSION_OPEN", VALUEFUNC(_wrap_OpenCloseSettleFlag_SESSION_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_DELIVERY_SETTLEMENT_ENTRY", VALUEFUNC(_wrap_OpenCloseSettleFlag_DELIVERY_SETTLEMENT_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_EXPECTED_ENTRY", VALUEFUNC(_wrap_OpenCloseSettleFlag_EXPECTED_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY", VALUEFUNC(_wrap_OpenCloseSettleFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "FinancialStatus_BANKRUPT", VALUEFUNC(_wrap_FinancialStatus_BANKRUPT_get), 0);
  rb_define_singleton_method(mQuickfix, "FinancialStatus_PENDING_DELISTING", VALUEFUNC(_wrap_FinancialStatus_PENDING_DELISTING_get), 0);
  rb_define_singleton_method(mQuickfix, "FinancialStatus_RESTRICTED", VALUEFUNC(_wrap_FinancialStatus_RESTRICTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_DIVIDEND", VALUEFUNC(_wrap_CorporateAction_EX_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_DISTRIBUTION", VALUEFUNC(_wrap_CorporateAction_EX_DISTRIBUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_RIGHTS", VALUEFUNC(_wrap_CorporateAction_EX_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_NEW", VALUEFUNC(_wrap_CorporateAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_INTEREST", VALUEFUNC(_wrap_CorporateAction_EX_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_CASH_DIVIDEND", VALUEFUNC(_wrap_CorporateAction_CASH_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_STOCK_DIVIDEND", VALUEFUNC(_wrap_CorporateAction_STOCK_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_NON_INTEGER_STOCK_SPLIT", VALUEFUNC(_wrap_CorporateAction_NON_INTEGER_STOCK_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_REVERSE_STOCK_SPLIT", VALUEFUNC(_wrap_CorporateAction_REVERSE_STOCK_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_STANDARD_INTEGER_STOCK_SPLIT", VALUEFUNC(_wrap_CorporateAction_STANDARD_INTEGER_STOCK_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_POSITION_CONSOLIDATION", VALUEFUNC(_wrap_CorporateAction_POSITION_CONSOLIDATION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_LIQUIDATION_REORGANIZATION", VALUEFUNC(_wrap_CorporateAction_LIQUIDATION_REORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_MERGER_REORGANIZATION", VALUEFUNC(_wrap_CorporateAction_MERGER_REORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_RIGHTS_OFFERING", VALUEFUNC(_wrap_CorporateAction_RIGHTS_OFFERING_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_SHAREHOLDER_MEETING", VALUEFUNC(_wrap_CorporateAction_SHAREHOLDER_MEETING_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_SPINOFF", VALUEFUNC(_wrap_CorporateAction_SPINOFF_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_TENDER_OFFER", VALUEFUNC(_wrap_CorporateAction_TENDER_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_WARRANT", VALUEFUNC(_wrap_CorporateAction_WARRANT_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_SPECIAL_ACTION", VALUEFUNC(_wrap_CorporateAction_SPECIAL_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_SYMBOL_CONVERSION", VALUEFUNC(_wrap_CorporateAction_SYMBOL_CONVERSION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_CUSIP", VALUEFUNC(_wrap_CorporateAction_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_LEAP_ROLLOVER", VALUEFUNC(_wrap_CorporateAction_LEAP_ROLLOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_SUCCESSION_EVENT", VALUEFUNC(_wrap_CorporateAction_SUCCESSION_EVENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_ACCEPTED", VALUEFUNC(_wrap_QuoteAckStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_CANCEL_FOR_SYMBOL", VALUEFUNC(_wrap_QuoteAckStatus_CANCEL_FOR_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_CANCELED_FOR_SECURITY_TYPE", VALUEFUNC(_wrap_QuoteAckStatus_CANCELED_FOR_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_CANCELED_FOR_UNDERLYING", VALUEFUNC(_wrap_QuoteAckStatus_CANCELED_FOR_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_CANCELED_ALL", VALUEFUNC(_wrap_QuoteAckStatus_CANCELED_ALL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_REJECTED", VALUEFUNC(_wrap_QuoteAckStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAckStatus_RECEIVED_NOT_YET_PROCESSED", VALUEFUNC(_wrap_QuoteAckStatus_RECEIVED_NOT_YET_PROCESSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_ONE_OR_MORE_SECURITIES", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_ONE_OR_MORE_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_SECURITY_TYPE", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_UNDERLYING_SECURITY", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_ALL_QUOTES", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_ALL_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_QUOTE_SPECIFIED_IN_QUOTE_ID", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_QUOTE_SPECIFIED_IN_QUOTE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_SPECIFIED_SINGLE_QUOTE", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_SPECIFIED_SINGLE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_BY_TYPE_OF_QUOTE", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_BY_TYPE_OF_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_SECURITY_ISSUER", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCHANGE", VALUEFUNC(_wrap_QuoteRejectReason_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_UNKNOWN_QUOTE", VALUEFUNC(_wrap_QuoteRejectReason_UNKNOWN_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_DUPLICATE_QUOTE", VALUEFUNC(_wrap_QuoteRejectReason_DUPLICATE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_BID", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY", VALUEFUNC(_wrap_QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_OTHER", VALUEFUNC(_wrap_QuoteRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND", VALUEFUNC(_wrap_QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_QUOTE_LOCKED", VALUEFUNC(_wrap_QuoteRejectReason_QUOTE_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD", VALUEFUNC(_wrap_QuoteRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_DEPR", VALUEFUNC(_wrap_QuoteRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_DEPR_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_REFERENCE_PRICE_NOT_AVAILABLE", VALUEFUNC(_wrap_QuoteRejectReason_REFERENCE_PRICE_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INSUFFICIENT_CREDIT_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_INSUFFICIENT_CREDIT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCEEDED_CLIP_SIZE_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_EXCEEDED_CLIP_SIZE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT", VALUEFUNC(_wrap_QuoteRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCEEDED_DV01_PV01_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_EXCEEDED_DV01_PV01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCEEDED_CS01_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_EXCEEDED_CS01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_NO_ACKNOWLEDGEMENT", VALUEFUNC(_wrap_QuoteResponseLevel_NO_ACKNOWLEDGEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES", VALUEFUNC(_wrap_QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGE", VALUEFUNC(_wrap_QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_SUMMARY_ACKNOWLEDGEMENT", VALUEFUNC(_wrap_QuoteResponseLevel_SUMMARY_ACKNOWLEDGEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestType_MANUAL", VALUEFUNC(_wrap_QuoteRequestType_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestType_AUTOMATIC", VALUEFUNC(_wrap_QuoteRequestType_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestType_CONFIRM_QUOTE", VALUEFUNC(_wrap_QuoteRequestType_CONFIRM_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_SPECIFICATIONS", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_SPECIFICATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_LIST_SECURITY_TYPES", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_LIST_SECURITY_TYPES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_LIST_SECURITIES", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_LIST_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_SYMBOL", VALUEFUNC(_wrap_SecurityRequestType_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_SECURITY_TYPE_AND_OR_CFI_CODE", VALUEFUNC(_wrap_SecurityRequestType_SECURITY_TYPE_AND_OR_CFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_PRODUCT", VALUEFUNC(_wrap_SecurityRequestType_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_TRADING_SESSION_ID", VALUEFUNC(_wrap_SecurityRequestType_TRADING_SESSION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_ALL_SECURITIES", VALUEFUNC(_wrap_SecurityRequestType_ALL_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_MARKET_ID_OR_MARKET_ID", VALUEFUNC(_wrap_SecurityRequestType_MARKET_ID_OR_MARKET_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_ACCEPT_AS_IS", VALUEFUNC(_wrap_SecurityResponseType_ACCEPT_AS_IS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_ACCEPT_WITH_REVISIONS", VALUEFUNC(_wrap_SecurityResponseType_ACCEPT_WITH_REVISIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST", VALUEFUNC(_wrap_SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST", VALUEFUNC(_wrap_SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_REJECT_SECURITY_PROPOSAL", VALUEFUNC(_wrap_SecurityResponseType_REJECT_SECURITY_PROPOSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_CANNOT_MATCH_SELECTION_CRITERIA", VALUEFUNC(_wrap_SecurityResponseType_CANNOT_MATCH_SELECTION_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "UnsolicitedIndicator_NO", VALUEFUNC(_wrap_UnsolicitedIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "UnsolicitedIndicator_YES", VALUEFUNC(_wrap_UnsolicitedIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_OPENING_DELAY", VALUEFUNC(_wrap_SecurityTradingStatus_OPENING_DELAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_MARKET_IMBALANCE", VALUEFUNC(_wrap_SecurityTradingStatus_NO_MARKET_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE", VALUEFUNC(_wrap_SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_ITS_PRE_OPENING", VALUEFUNC(_wrap_SecurityTradingStatus_ITS_PRE_OPENING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NEW_PRICE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_NEW_PRICE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADE_DISSEMINATION_TIME", VALUEFUNC(_wrap_SecurityTradingStatus_TRADE_DISSEMINATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_READY_TO_TRADE", VALUEFUNC(_wrap_SecurityTradingStatus_READY_TO_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING", VALUEFUNC(_wrap_SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET", VALUEFUNC(_wrap_SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADING_HALT", VALUEFUNC(_wrap_SecurityTradingStatus_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_UNKNOWN_OR_INVALID", VALUEFUNC(_wrap_SecurityTradingStatus_UNKNOWN_OR_INVALID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_RESUME", VALUEFUNC(_wrap_SecurityTradingStatus_RESUME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_OPEN", VALUEFUNC(_wrap_SecurityTradingStatus_NO_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_PRICE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_PRICE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADING_RANGE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_TRADING_RANGE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_IMBALANCE_BUY", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_IMBALANCE_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_IMBALANCE_SELL", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_IMBALANCE_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_OPENING_ROTATION", VALUEFUNC(_wrap_SecurityTradingStatus_OPENING_ROTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_PRE_OPEN", VALUEFUNC(_wrap_SecurityTradingStatus_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_FAST_MARKET", VALUEFUNC(_wrap_SecurityTradingStatus_FAST_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_PRE_CROSS", VALUEFUNC(_wrap_SecurityTradingStatus_PRE_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_CROSS", VALUEFUNC(_wrap_SecurityTradingStatus_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_POST_CLOSE", VALUEFUNC(_wrap_SecurityTradingStatus_POST_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_CANCEL", VALUEFUNC(_wrap_SecurityTradingStatus_NO_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_NEWS_DISSEMINATION", VALUEFUNC(_wrap_HaltReasonChar_NEWS_DISSEMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_ORDER_INFLUX", VALUEFUNC(_wrap_HaltReasonChar_ORDER_INFLUX_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_ORDER_IMBALANCE", VALUEFUNC(_wrap_HaltReasonChar_ORDER_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_ADDITIONAL_INFORMATION", VALUEFUNC(_wrap_HaltReasonChar_ADDITIONAL_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_NEWS_PENDING", VALUEFUNC(_wrap_HaltReasonChar_NEWS_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_EQUIPMENT_CHANGEOVER", VALUEFUNC(_wrap_HaltReasonChar_EQUIPMENT_CHANGEOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonChar_NEW_PENDING", VALUEFUNC(_wrap_HaltReasonChar_NEW_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "InViewOfCommon_NO", VALUEFUNC(_wrap_InViewOfCommon_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "InViewOfCommon_YES", VALUEFUNC(_wrap_InViewOfCommon_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "DueToRelated_NO", VALUEFUNC(_wrap_DueToRelated_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "DueToRelated_YES", VALUEFUNC(_wrap_DueToRelated_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_CANCEL", VALUEFUNC(_wrap_Adjustment_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_ERROR", VALUEFUNC(_wrap_Adjustment_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_CORRECTION", VALUEFUNC(_wrap_Adjustment_CORRECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_DAY", VALUEFUNC(_wrap_TradingSessionID_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_HALF_DAY", VALUEFUNC(_wrap_TradingSessionID_HALF_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_MORNING", VALUEFUNC(_wrap_TradingSessionID_MORNING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_AFTERNOON", VALUEFUNC(_wrap_TradingSessionID_AFTERNOON_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_EVENING", VALUEFUNC(_wrap_TradingSessionID_EVENING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_AFTER_HOURS", VALUEFUNC(_wrap_TradingSessionID_AFTER_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionID_HOLIDAY", VALUEFUNC(_wrap_TradingSessionID_HOLIDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_ELECTRONIC", VALUEFUNC(_wrap_TradSesMethod_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_OPEN_OUTCRY", VALUEFUNC(_wrap_TradSesMethod_OPEN_OUTCRY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_TWO_PARTY", VALUEFUNC(_wrap_TradSesMethod_TWO_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_VOICE", VALUEFUNC(_wrap_TradSesMethod_VOICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_TESTING", VALUEFUNC(_wrap_TradSesMode_TESTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_SIMULATED", VALUEFUNC(_wrap_TradSesMode_SIMULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_PRODUCTION", VALUEFUNC(_wrap_TradSesMode_PRODUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_HALTED", VALUEFUNC(_wrap_TradSesStatus_HALTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_OPEN", VALUEFUNC(_wrap_TradSesStatus_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_CLOSED", VALUEFUNC(_wrap_TradSesStatus_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_PRE_OPEN", VALUEFUNC(_wrap_TradSesStatus_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_PRE_CLOSE", VALUEFUNC(_wrap_TradSesStatus_PRE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_REQUEST_REJECTED", VALUEFUNC(_wrap_TradSesStatus_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_UNKNOWN", VALUEFUNC(_wrap_TradSesStatus_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteEntryRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_EXCHANGE", VALUEFUNC(_wrap_QuoteEntryRejectReason_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteEntryRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_UNKNOWN_QUOTE", VALUEFUNC(_wrap_QuoteEntryRejectReason_UNKNOWN_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_DUPLICATE_QUOTE", VALUEFUNC(_wrap_QuoteEntryRejectReason_DUPLICATE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD", VALUEFUNC(_wrap_QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteEntryRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY", VALUEFUNC(_wrap_QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "BidRequestTransType_CANCEL", VALUEFUNC(_wrap_BidRequestTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "BidRequestTransType_NEW", VALUEFUNC(_wrap_BidRequestTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "SolicitedFlag_NO", VALUEFUNC(_wrap_SolicitedFlag_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "SolicitedFlag_YES", VALUEFUNC(_wrap_SolicitedFlag_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_GT_CORPORATE_ACTION", VALUEFUNC(_wrap_ExecRestatementReason_GT_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_GT_RENEWAL", VALUEFUNC(_wrap_ExecRestatementReason_GT_RENEWAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_VERBAL_CHANGE", VALUEFUNC(_wrap_ExecRestatementReason_VERBAL_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_REPRICING_OF_ORDER", VALUEFUNC(_wrap_ExecRestatementReason_REPRICING_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_BROKER_OPTION", VALUEFUNC(_wrap_ExecRestatementReason_BROKER_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_PARTIAL_DECLINE_OF_ORDER_QTY", VALUEFUNC(_wrap_ExecRestatementReason_PARTIAL_DECLINE_OF_ORDER_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_MARKET", VALUEFUNC(_wrap_ExecRestatementReason_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCELED", VALUEFUNC(_wrap_ExecRestatementReason_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_WAREHOUSE_RECAP", VALUEFUNC(_wrap_ExecRestatementReason_WAREHOUSE_RECAP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_OTHER", VALUEFUNC(_wrap_ExecRestatementReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_PEG_REFRESH", VALUEFUNC(_wrap_ExecRestatementReason_PEG_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_CONNECTION_LOSS", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_CONNECTION_LOSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_LOGOUT", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_LOGOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_ASSIGN_TIME_PRIORITY", VALUEFUNC(_wrap_ExecRestatementReason_ASSIGN_TIME_PRIORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCELLED_FOR_TRADE_PRICE_VIOLATION", VALUEFUNC(_wrap_ExecRestatementReason_CANCELLED_FOR_TRADE_PRICE_VIOLATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCELLED_FOR_CROSS_IMBALANCE", VALUEFUNC(_wrap_ExecRestatementReason_CANCELLED_FOR_CROSS_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CXLD_SMP", VALUEFUNC(_wrap_ExecRestatementReason_CXLD_SMP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CXLD_SMP_AGGRESSIVE", VALUEFUNC(_wrap_ExecRestatementReason_CXLD_SMP_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CXLD_SMP_PASSIVE", VALUEFUNC(_wrap_ExecRestatementReason_CXLD_SMP_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CXLD_SMP_AGGRESSIVE_PASSIVE", VALUEFUNC(_wrap_ExecRestatementReason_CXLD_SMP_AGGRESSIVE_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_OTHER", VALUEFUNC(_wrap_BusinessRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_ID", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_SECURITY", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE", VALUEFUNC(_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_APPLICATION_NOT_AVAILABLE", VALUEFUNC(_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING", VALUEFUNC(_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME", VALUEFUNC(_wrap_BusinessRejectReason_DELIVER_TO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_NOT_AUTHORIZED", VALUEFUNC(_wrap_BusinessRejectReason_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_INVALID_PRICE_INCREMENT", VALUEFUNC(_wrap_BusinessRejectReason_INVALID_PRICE_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED", VALUEFUNC(_wrap_BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_SESSION_DISCONNECTED", VALUEFUNC(_wrap_BusinessRejectReason_THROTTLE_LIMIT_EXCEEDED_SESSION_DISCONNECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_THROTTLED_MESSAGES_REJECTED_ON_REQUEST", VALUEFUNC(_wrap_BusinessRejectReason_THROTTLED_MESSAGES_REJECTED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgDirection_RECEIVE", VALUEFUNC(_wrap_MsgDirection_RECEIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgDirection_SEND", VALUEFUNC(_wrap_MsgDirection_SEND_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_DISPLAYED_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_DISPLAYED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_MARKET_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_MARKET_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_PRIMARY_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_PRIMARY_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_MIDPOINT_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_MIDPOINT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_LAST_TRADE_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_LAST_TRADE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_VWAP", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_AVERAGE_PRICE_GUARANTEE", VALUEFUNC(_wrap_DiscretionInst_AVERAGE_PRICE_GUARANTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_NON_DISCLOSED", VALUEFUNC(_wrap_BidType_NON_DISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_DISCLOSED", VALUEFUNC(_wrap_BidType_DISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_NO_BIDDING_PROCESS", VALUEFUNC(_wrap_BidType_NO_BIDDING_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_INDEX", VALUEFUNC(_wrap_BidDescriptorType_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_COUNTRY", VALUEFUNC(_wrap_BidDescriptorType_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_SECTOR", VALUEFUNC(_wrap_BidDescriptorType_SECTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SideValueInd_SIDE_VALUE1", VALUEFUNC(_wrap_SideValueInd_SIDE_VALUE1_get), 0);
  rb_define_singleton_method(mQuickfix, "SideValueInd_SIDE_VALUE2", VALUEFUNC(_wrap_SideValueInd_SIDE_VALUE2_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_FIVE_DAY_MOVING_AVERAGE", VALUEFUNC(_wrap_LiquidityIndType_FIVE_DAY_MOVING_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_TWENTY_DAY_MOVING_AVERAGE", VALUEFUNC(_wrap_LiquidityIndType_TWENTY_DAY_MOVING_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_NORMAL_MARKET_SIZE", VALUEFUNC(_wrap_LiquidityIndType_NORMAL_MARKET_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_OTHER", VALUEFUNC(_wrap_LiquidityIndType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExchangeForPhysical_NO", VALUEFUNC(_wrap_ExchangeForPhysical_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ExchangeForPhysical_YES", VALUEFUNC(_wrap_ExchangeForPhysical_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_BUY_SIDE_REQUESTS", VALUEFUNC(_wrap_ProgRptReqs_BUY_SIDE_REQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_SELL_SIDE_SENDS", VALUEFUNC(_wrap_ProgRptReqs_SELL_SIDE_SENDS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_REAL_TIME_EXECUTION_REPORTS", VALUEFUNC(_wrap_ProgRptReqs_REAL_TIME_EXECUTION_REPORTS_get), 0);
  rb_define_singleton_method(mQuickfix, "IncTaxInd_NET", VALUEFUNC(_wrap_IncTaxInd_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "IncTaxInd_GROSS", VALUEFUNC(_wrap_IncTaxInd_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeType_AGENCY", VALUEFUNC(_wrap_TradeType_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeType_VWAP_GUARANTEE", VALUEFUNC(_wrap_TradeType_VWAP_GUARANTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeType_GUARANTEED_CLOSE", VALUEFUNC(_wrap_TradeType_GUARANTEED_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeType_RISK_TRADE", VALUEFUNC(_wrap_TradeType_RISK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION", VALUEFUNC(_wrap_BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CLOSING_PRICE", VALUEFUNC(_wrap_BasisPxType_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CURRENT_PRICE", VALUEFUNC(_wrap_BasisPxType_CURRENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_SQ", VALUEFUNC(_wrap_BasisPxType_SQ_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_DAY", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_MORNING_SESSION", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_STRIKE", VALUEFUNC(_wrap_BasisPxType_STRIKE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_OPEN", VALUEFUNC(_wrap_BasisPxType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_OTHERS", VALUEFUNC(_wrap_BasisPxType_OTHERS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PERCENTAGE", VALUEFUNC(_wrap_PriceType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PER_UNIT", VALUEFUNC(_wrap_PriceType_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_FIXED_AMOUNT", VALUEFUNC(_wrap_PriceType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_DISCOUNT", VALUEFUNC(_wrap_PriceType_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_SPREAD", VALUEFUNC(_wrap_PriceType_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_TED_PRICE", VALUEFUNC(_wrap_PriceType_TED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_TED_YIELD", VALUEFUNC(_wrap_PriceType_TED_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PREMIUM", VALUEFUNC(_wrap_PriceType_PREMIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_YIELD", VALUEFUNC(_wrap_PriceType_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_FIXED_CABINET_TRADE_PRICE", VALUEFUNC(_wrap_PriceType_FIXED_CABINET_TRADE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_VARIABLE_CABINET_TRADE_PRICE", VALUEFUNC(_wrap_PriceType_VARIABLE_CABINET_TRADE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_HALFS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_HALFS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_FOURTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_FOURTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_EIGHTS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_EIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_SIXTEENTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_SIXTEENTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_SIXTY_FORTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_SIXTY_FORTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRICE_SPREAD", VALUEFUNC(_wrap_PriceType_PRICE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_HALVES", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_HALVES_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_EIGHTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_EIGHTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS", VALUEFUNC(_wrap_PriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_NORMAL_RATE_REPRESENTATION", VALUEFUNC(_wrap_PriceType_NORMAL_RATE_REPRESENTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_INVERSE_RATE_REPRESENTATION", VALUEFUNC(_wrap_PriceType_INVERSE_RATE_REPRESENTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_BASIS_POINTS", VALUEFUNC(_wrap_PriceType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_UPFRONT_POINTS", VALUEFUNC(_wrap_PriceType_UPFRONT_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_INTEREST_RATE", VALUEFUNC(_wrap_PriceType_INTEREST_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PERCENTAGE_NOTIONAL", VALUEFUNC(_wrap_PriceType_PERCENTAGE_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION", VALUEFUNC(_wrap_GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED", VALUEFUNC(_wrap_GTBookingInst_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_ACCUMULATE_UNTIL_VERBALLLY_NOTIFIED_OTHERWISE", VALUEFUNC(_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLLY_NOTIFIED_OTHERWISE_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE", VALUEFUNC(_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ALERT", VALUEFUNC(_wrap_ListStatusType_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_EXEC_STARTED", VALUEFUNC(_wrap_ListStatusType_EXEC_STARTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_TIMED", VALUEFUNC(_wrap_ListStatusType_TIMED_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_RESPONSE", VALUEFUNC(_wrap_ListStatusType_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ACK", VALUEFUNC(_wrap_ListStatusType_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ALL_DONE", VALUEFUNC(_wrap_ListStatusType_ALL_DONE_get), 0);
  rb_define_singleton_method(mQuickfix, "NetGrossInd_NET", VALUEFUNC(_wrap_NetGrossInd_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "NetGrossInd_GROSS", VALUEFUNC(_wrap_NetGrossInd_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_CANCELLING", VALUEFUNC(_wrap_ListOrderStatus_CANCELLING_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_EXECUTING", VALUEFUNC(_wrap_ListOrderStatus_EXECUTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_REJECT", VALUEFUNC(_wrap_ListOrderStatus_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_ALL_DONE", VALUEFUNC(_wrap_ListOrderStatus_ALL_DONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_ALERT", VALUEFUNC(_wrap_ListOrderStatus_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_RECEIVED_FOR_EXECUTION", VALUEFUNC(_wrap_ListOrderStatus_RECEIVED_FOR_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_IN_BIDDING_PROCESS", VALUEFUNC(_wrap_ListOrderStatus_IN_BIDDING_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_IMMEDIATE", VALUEFUNC(_wrap_ListExecInstType_IMMEDIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_WAIT_FOR_INSTRUCTION", VALUEFUNC(_wrap_ListExecInstType_WAIT_FOR_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_BUY_DRIVEN_CASH_WITHDRAW", VALUEFUNC(_wrap_ListExecInstType_BUY_DRIVEN_CASH_WITHDRAW_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_BUY_DRIVEN_CASH_TOP_UP", VALUEFUNC(_wrap_ListExecInstType_BUY_DRIVEN_CASH_TOP_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_SELL_DRIVEN", VALUEFUNC(_wrap_ListExecInstType_SELL_DRIVEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejResponseTo_ORDER_CANCEL_REQUEST", VALUEFUNC(_wrap_CxlRejResponseTo_ORDER_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejResponseTo_ORDER_CANCEL", VALUEFUNC(_wrap_CxlRejResponseTo_ORDER_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST", VALUEFUNC(_wrap_CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_SINGLE_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_SINGLE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_SICOVAM", VALUEFUNC(_wrap_SecurityIDSource_SICOVAM_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_SEDOL", VALUEFUNC(_wrap_SecurityIDSource_SEDOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CUSIP", VALUEFUNC(_wrap_SecurityIDSource_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_QUIK", VALUEFUNC(_wrap_SecurityIDSource_QUIK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_BELGIAN", VALUEFUNC(_wrap_SecurityIDSource_BELGIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_VALOREN", VALUEFUNC(_wrap_SecurityIDSource_VALOREN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_DUTCH", VALUEFUNC(_wrap_SecurityIDSource_DUTCH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_WERTPAPIER", VALUEFUNC(_wrap_SecurityIDSource_WERTPAPIER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_BLOOMBERG_SYMBOL", VALUEFUNC(_wrap_SecurityIDSource_BLOOMBERG_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION", VALUEFUNC(_wrap_SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_EXCHANGE_SYMBOL", VALUEFUNC(_wrap_SecurityIDSource_EXCHANGE_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_SecurityIDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_SecurityIDSource_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_RIC_CODE", VALUEFUNC(_wrap_SecurityIDSource_RIC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISIN_NUMBER", VALUEFUNC(_wrap_SecurityIDSource_ISIN_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_COMMON", VALUEFUNC(_wrap_SecurityIDSource_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CLEARING_HOUSE", VALUEFUNC(_wrap_SecurityIDSource_CLEARING_HOUSE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISDA_FP_ML_SPECIFICATION", VALUEFUNC(_wrap_SecurityIDSource_ISDA_FP_ML_SPECIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_OPTION_PRICE_REPORTING_AUTHORITY", VALUEFUNC(_wrap_SecurityIDSource_OPTION_PRICE_REPORTING_AUTHORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISDA_FP_MLURL", VALUEFUNC(_wrap_SecurityIDSource_ISDA_FP_MLURL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_LETTER_OF_CREDIT", VALUEFUNC(_wrap_SecurityIDSource_LETTER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_MARKETPLACE_ASSIGNED_IDENTIFIER", VALUEFUNC(_wrap_SecurityIDSource_MARKETPLACE_ASSIGNED_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_MARKIT_RED_ENTITY_CLIP", VALUEFUNC(_wrap_SecurityIDSource_MARKIT_RED_ENTITY_CLIP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_MARKIT_RED_PAIR_CLIP", VALUEFUNC(_wrap_SecurityIDSource_MARKIT_RED_PAIR_CLIP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CFTC_COMMODITY_CODE", VALUEFUNC(_wrap_SecurityIDSource_CFTC_COMMODITY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISDA_COMMODITY_REFERENCE_PRICE", VALUEFUNC(_wrap_SecurityIDSource_ISDA_COMMODITY_REFERENCE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER", VALUEFUNC(_wrap_SecurityIDSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_LEGAL_ENTITY_IDENTIFIER", VALUEFUNC(_wrap_SecurityIDSource_LEGAL_ENTITY_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_SYNTHETIC", VALUEFUNC(_wrap_SecurityIDSource_SYNTHETIC_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_FIDESSA_INSTRUMENT_MNEMONIC", VALUEFUNC(_wrap_SecurityIDSource_FIDESSA_INSTRUMENT_MNEMONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_INDEX_NAME", VALUEFUNC(_wrap_SecurityIDSource_INDEX_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_UNIFORM_SYMBOL", VALUEFUNC(_wrap_SecurityIDSource_UNIFORM_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_DIGITAL_TOKEN_IDENTIFIER", VALUEFUNC(_wrap_SecurityIDSource_DIGITAL_TOKEN_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQty_LARGE", VALUEFUNC(_wrap_IOIQty_LARGE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQty_MEDIUM", VALUEFUNC(_wrap_IOIQty_MEDIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQty_SMALL", VALUEFUNC(_wrap_IOIQty_SMALL_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQty_UNDISCLOSED_QUANTITY", VALUEFUNC(_wrap_IOIQty_UNDISCLOSED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_FIFO", VALUEFUNC(_wrap_PositionEffect_FIFO_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_ROLLED", VALUEFUNC(_wrap_PositionEffect_ROLLED_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_CLOSE", VALUEFUNC(_wrap_PositionEffect_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_OPEN", VALUEFUNC(_wrap_PositionEffect_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_CLOSE_BUT_NOTIFY_ON_OPEN", VALUEFUNC(_wrap_PositionEffect_CLOSE_BUT_NOTIFY_ON_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_DEFAULT", VALUEFUNC(_wrap_PositionEffect_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SWAP", VALUEFUNC(_wrap_BenchmarkCurveName_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_LIBID", VALUEFUNC(_wrap_BenchmarkCurveName_LIBID_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_OTHER", VALUEFUNC(_wrap_BenchmarkCurveName_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TREASURY", VALUEFUNC(_wrap_BenchmarkCurveName_TREASURY_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EURIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_EURIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_PFANDBRIEFE", VALUEFUNC(_wrap_BenchmarkCurveName_PFANDBRIEFE_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_FUTURE_SWAP", VALUEFUNC(_wrap_BenchmarkCurveName_FUTURE_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_MUNI_AAA", VALUEFUNC(_wrap_BenchmarkCurveName_MUNI_AAA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_LIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_LIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EONIA", VALUEFUNC(_wrap_BenchmarkCurveName_EONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EUREPO", VALUEFUNC(_wrap_BenchmarkCurveName_EUREPO_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SONIA", VALUEFUNC(_wrap_BenchmarkCurveName_SONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_FED_FUND_RATE_EFFECTIVE", VALUEFUNC(_wrap_BenchmarkCurveName_FED_FUND_RATE_EFFECTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_FED_OPEN", VALUEFUNC(_wrap_BenchmarkCurveName_FED_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_AUBSW", VALUEFUNC(_wrap_BenchmarkCurveName_AUBSW_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_BUBOR", VALUEFUNC(_wrap_BenchmarkCurveName_BUBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_CDOR", VALUEFUNC(_wrap_BenchmarkCurveName_CDOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_CIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_CIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EONIASWAP", VALUEFUNC(_wrap_BenchmarkCurveName_EONIASWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_ESTR", VALUEFUNC(_wrap_BenchmarkCurveName_ESTR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EURODOLLAR", VALUEFUNC(_wrap_BenchmarkCurveName_EURODOLLAR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EUROSWISS", VALUEFUNC(_wrap_BenchmarkCurveName_EUROSWISS_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_GCFREPO", VALUEFUNC(_wrap_BenchmarkCurveName_GCFREPO_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_ISDAFIX", VALUEFUNC(_wrap_BenchmarkCurveName_ISDAFIX_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_JIBAR", VALUEFUNC(_wrap_BenchmarkCurveName_JIBAR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_MOSPRIM", VALUEFUNC(_wrap_BenchmarkCurveName_MOSPRIM_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_NIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_NIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_PRIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_PRIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SOFR", VALUEFUNC(_wrap_BenchmarkCurveName_SOFR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_STIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_STIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TELBOR", VALUEFUNC(_wrap_BenchmarkCurveName_TELBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_TIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_WIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_WIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_AONIA", VALUEFUNC(_wrap_BenchmarkCurveName_AONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_AONIAR", VALUEFUNC(_wrap_BenchmarkCurveName_AONIAR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_BKBM", VALUEFUNC(_wrap_BenchmarkCurveName_BKBM_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_CD19_D", VALUEFUNC(_wrap_BenchmarkCurveName_CD19_D_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_CORRA", VALUEFUNC(_wrap_BenchmarkCurveName_CORRA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_DIRRTN", VALUEFUNC(_wrap_BenchmarkCurveName_DIRRTN_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_EIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_FIXING_REPO_RATE", VALUEFUNC(_wrap_BenchmarkCurveName_FIXING_REPO_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_HIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_HIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_IBR", VALUEFUNC(_wrap_BenchmarkCurveName_IBR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_KLIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_KLIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_MIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_MIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_NZONIA", VALUEFUNC(_wrap_BenchmarkCurveName_NZONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_PHIREF", VALUEFUNC(_wrap_BenchmarkCurveName_PHIREF_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_REIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_REIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SAIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_SAIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SARON", VALUEFUNC(_wrap_BenchmarkCurveName_SARON_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SORA", VALUEFUNC(_wrap_BenchmarkCurveName_SORA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TLREF", VALUEFUNC(_wrap_BenchmarkCurveName_TLREF_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TIIE", VALUEFUNC(_wrap_BenchmarkCurveName_TIIE_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_THBFIX", VALUEFUNC(_wrap_BenchmarkCurveName_THBFIX_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TONAR", VALUEFUNC(_wrap_BenchmarkCurveName_TONAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ABSOLUTE_PREPAYMENT_SPEED", VALUEFUNC(_wrap_StipulationType_ABSOLUTE_PREPAYMENT_SPEED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_LOAN_AGE", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_LOAN_AGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_MATURITY", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_RATE", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SINGLE_MONTHLY_MORTALITY", VALUEFUNC(_wrap_StipulationType_SINGLE_MONTHLY_MORTALITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MONTHLY_PREPAYMENT_RATE", VALUEFUNC(_wrap_StipulationType_MONTHLY_PREPAYMENT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_PENALTY", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_PENALTY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_LOT_VARIANCE", VALUEFUNC(_wrap_StipulationType_LOT_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_YIELD", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_COUPON", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISSUE_DATE", VALUEFUNC(_wrap_StipulationType_ISSUE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MATURITY_YEAR_AND_MONTH", VALUEFUNC(_wrap_StipulationType_MATURITY_YEAR_AND_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_NUMBER_OF_PIECES", VALUEFUNC(_wrap_StipulationType_NUMBER_OF_PIECES_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_MAXIMUM", VALUEFUNC(_wrap_StipulationType_POOLS_MAXIMUM_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_MILLION", VALUEFUNC(_wrap_StipulationType_POOLS_PER_MILLION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_LOT", VALUEFUNC(_wrap_StipulationType_POOLS_PER_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_TRADE", VALUEFUNC(_wrap_StipulationType_POOLS_PER_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRODUCTION_YEAR", VALUEFUNC(_wrap_StipulationType_PRODUCTION_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TRADE_VARIANCE", VALUEFUNC(_wrap_StipulationType_TRADE_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_GEOGRAPHICS", VALUEFUNC(_wrap_StipulationType_GEOGRAPHICS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ALTERNATIVE_MINIMUM_TAX", VALUEFUNC(_wrap_StipulationType_ALTERNATIVE_MINIMUM_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AUTO_REINVESTMENT", VALUEFUNC(_wrap_StipulationType_AUTO_REINVESTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BANK_QUALIFIED", VALUEFUNC(_wrap_StipulationType_BANK_QUALIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BARGAIN_CONDITIONS", VALUEFUNC(_wrap_StipulationType_BARGAIN_CONDITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_COUPON_RANGE", VALUEFUNC(_wrap_StipulationType_COUPON_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_StipulationType_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CUSTOM_START", VALUEFUNC(_wrap_StipulationType_CUSTOM_START_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_VALUATION_DISCOUNT", VALUEFUNC(_wrap_StipulationType_VALUATION_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_INSURED", VALUEFUNC(_wrap_StipulationType_INSURED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISSUER", VALUEFUNC(_wrap_StipulationType_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISSUE_SIZE_RANGE", VALUEFUNC(_wrap_StipulationType_ISSUE_SIZE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_LOOKBACK_DAYS", VALUEFUNC(_wrap_StipulationType_LOOKBACK_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_EXPLICIT_LOT_IDENTIFIER", VALUEFUNC(_wrap_StipulationType_EXPLICIT_LOT_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MATURITY_RANGE", VALUEFUNC(_wrap_StipulationType_MATURITY_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MAXIMUM_SUBSTITUTIONS", VALUEFUNC(_wrap_StipulationType_MAXIMUM_SUBSTITUTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_QUANTITY", VALUEFUNC(_wrap_StipulationType_MINIMUM_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_INCREMENT", VALUEFUNC(_wrap_StipulationType_MINIMUM_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_DENOMINATION", VALUEFUNC(_wrap_StipulationType_MINIMUM_DENOMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PAYMENT_FREQUENCY", VALUEFUNC(_wrap_StipulationType_PAYMENT_FREQUENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRICE_RANGE", VALUEFUNC(_wrap_StipulationType_PRICE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRICING_FREQUENCY", VALUEFUNC(_wrap_StipulationType_PRICING_FREQUENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CALL_PROTECTION", VALUEFUNC(_wrap_StipulationType_CALL_PROTECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PURPOSE", VALUEFUNC(_wrap_StipulationType_PURPOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BENCHMARK_PRICE_SOURCE", VALUEFUNC(_wrap_StipulationType_BENCHMARK_PRICE_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_RATING_SOURCE_AND_RANGE", VALUEFUNC(_wrap_StipulationType_RATING_SOURCE_AND_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TYPE_OF_REDEMPTION", VALUEFUNC(_wrap_StipulationType_TYPE_OF_REDEMPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_RESTRICTED", VALUEFUNC(_wrap_StipulationType_RESTRICTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MARKET_SECTOR", VALUEFUNC(_wrap_StipulationType_MARKET_SECTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SECURITY_TYPE_INCLUDED_OR_EXCLUDED", VALUEFUNC(_wrap_StipulationType_SECURITY_TYPE_INCLUDED_OR_EXCLUDED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_STRUCTURE", VALUEFUNC(_wrap_StipulationType_STRUCTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SUBSTITUTIONS_FREQUENCY", VALUEFUNC(_wrap_StipulationType_SUBSTITUTIONS_FREQUENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SUBSTITUTIONS_LEFT", VALUEFUNC(_wrap_StipulationType_SUBSTITUTIONS_LEFT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_FREEFORM_TEXT", VALUEFUNC(_wrap_StipulationType_FREEFORM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WHOLE_POOL", VALUEFUNC(_wrap_StipulationType_WHOLE_POOL_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_YIELD_RANGE", VALUEFUNC(_wrap_StipulationType_YIELD_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AVERAGE_FICO_SCORE", VALUEFUNC(_wrap_StipulationType_AVERAGE_FICO_SCORE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AVERAGE_LOAN_SIZE", VALUEFUNC(_wrap_StipulationType_AVERAGE_LOAN_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MAXIMUM_LOAN_BALANCE", VALUEFUNC(_wrap_StipulationType_MAXIMUM_LOAN_BALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOL_IDENTIFIER", VALUEFUNC(_wrap_StipulationType_POOL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TYPE_OF_ROLL_TRADE", VALUEFUNC(_wrap_StipulationType_TYPE_OF_ROLL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_REFERENCE_TO_ROLLING_OR_CLOSING_TRADE", VALUEFUNC(_wrap_StipulationType_REFERENCE_TO_ROLLING_OR_CLOSING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRINCIPAL_OF_ROLLING_OR_CLOSING_TRADE", VALUEFUNC(_wrap_StipulationType_PRINCIPAL_OF_ROLLING_OR_CLOSING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_INTEREST_OF_ROLLING_OR_CLOSING_TRADE", VALUEFUNC(_wrap_StipulationType_INTEREST_OF_ROLLING_OR_CLOSING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AVAILABLE_OFFER_QUANTITY_TO_BE_SHOWN_TO_THE_STREET", VALUEFUNC(_wrap_StipulationType_AVAILABLE_OFFER_QUANTITY_TO_BE_SHOWN_TO_THE_STREET_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BROKER_CREDIT", VALUEFUNC(_wrap_StipulationType_BROKER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_OFFER_PRICE_TO_BE_SHOWN_TO_INTERNAL_BROKERS", VALUEFUNC(_wrap_StipulationType_OFFER_PRICE_TO_BE_SHOWN_TO_INTERNAL_BROKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_OFFER_QUANTITY_TO_BE_SHOWN_TO_INTERNAL_BROKERS", VALUEFUNC(_wrap_StipulationType_OFFER_QUANTITY_TO_BE_SHOWN_TO_INTERNAL_BROKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_THE_MINIMUM_RESIDUAL_OFFER_QUANTITY", VALUEFUNC(_wrap_StipulationType_THE_MINIMUM_RESIDUAL_OFFER_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MAXIMUM_ORDER_SIZE", VALUEFUNC(_wrap_StipulationType_MAXIMUM_ORDER_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ORDER_QUANTITY_INCREMENT", VALUEFUNC(_wrap_StipulationType_ORDER_QUANTITY_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRIMARY_OR_SECONDARY_MARKET_INDICATOR", VALUEFUNC(_wrap_StipulationType_PRIMARY_OR_SECONDARY_MARKET_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BROKER_SALES_CREDIT_OVERRIDE", VALUEFUNC(_wrap_StipulationType_BROKER_SALES_CREDIT_OVERRIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TRADER_CREDIT", VALUEFUNC(_wrap_StipulationType_TRADER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_DISCOUNT_RATE", VALUEFUNC(_wrap_StipulationType_DISCOUNT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_YIELD_TO_MATURITY", VALUEFUNC(_wrap_StipulationType_YIELD_TO_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ORIGINAL_AMOUNT", VALUEFUNC(_wrap_StipulationType_ORIGINAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOL_EFFECTIVE_DATE", VALUEFUNC(_wrap_StipulationType_POOL_EFFECTIVE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOL_INITIAL_FACTOR", VALUEFUNC(_wrap_StipulationType_POOL_INITIAL_FACTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TRANCHE", VALUEFUNC(_wrap_StipulationType_TRANCHE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SUBSTITUTION", VALUEFUNC(_wrap_StipulationType_SUBSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MULTEXCHFLLBCK", VALUEFUNC(_wrap_StipulationType_MULTEXCHFLLBCK_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_COMPSECFLLBCK", VALUEFUNC(_wrap_StipulationType_COMPSECFLLBCK_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_LOCLJRSDCTN", VALUEFUNC(_wrap_StipulationType_LOCLJRSDCTN_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_RELVJRSDCTN", VALUEFUNC(_wrap_StipulationType_RELVJRSDCTN_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_INCURRED_RECOVERY", VALUEFUNC(_wrap_StipulationType_INCURRED_RECOVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ADDITIONAL_TERM", VALUEFUNC(_wrap_StipulationType_ADDITIONAL_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MODIFIED_EQUITY_DELIVERY", VALUEFUNC(_wrap_StipulationType_MODIFIED_EQUITY_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_NO_REFERENCE_OBLICATION", VALUEFUNC(_wrap_StipulationType_NO_REFERENCE_OBLICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_UNKNOWN_REFERENCE_OBLIGATION", VALUEFUNC(_wrap_StipulationType_UNKNOWN_REFERENCE_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ALL_GUARANTEES", VALUEFUNC(_wrap_StipulationType_ALL_GUARANTEES_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_REFERENCE_PRICE", VALUEFUNC(_wrap_StipulationType_REFERENCE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_REFERENCE_POLICY", VALUEFUNC(_wrap_StipulationType_REFERENCE_POLICY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SECURED_LIST", VALUEFUNC(_wrap_StipulationType_SECURED_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_INTEREST_PAYOFF_OF_ROLLING_OR_AMENDING_TRADE", VALUEFUNC(_wrap_StipulationType_INTEREST_PAYOFF_OF_ROLLING_OR_AMENDING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TRUE_YIELD", VALUEFUNC(_wrap_YieldType_TRUE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_PREVIOUS_CLOSE_YIELD", VALUEFUNC(_wrap_YieldType_PREVIOUS_CLOSE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_LONGEST_AVERAGE", VALUEFUNC(_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE", VALUEFUNC(_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_MATURITY", VALUEFUNC(_wrap_YieldType_YIELD_TO_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_MARK_TO_MARKET_YIELD", VALUEFUNC(_wrap_YieldType_MARK_TO_MARKET_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_OPEN_AVERAGE_YIELD", VALUEFUNC(_wrap_YieldType_OPEN_AVERAGE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_PUT", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_PROCEEDS_YIELD", VALUEFUNC(_wrap_YieldType_PROCEEDS_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_SEMI_ANNUAL_YIELD", VALUEFUNC(_wrap_YieldType_SEMI_ANNUAL_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE", VALUEFUNC(_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_SHORTEST_AVERAGE", VALUEFUNC(_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_SIMPLE_YIELD", VALUEFUNC(_wrap_YieldType_SIMPLE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_TENDER_DATE", VALUEFUNC(_wrap_YieldType_YIELD_TO_TENDER_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_VALUE_OF32NDS", VALUEFUNC(_wrap_YieldType_YIELD_VALUE_OF32NDS_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_WORST", VALUEFUNC(_wrap_YieldType_YIELD_TO_WORST_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TAX_EQUIVALENT_YIELD", VALUEFUNC(_wrap_YieldType_TAX_EQUIVALENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_ANNUAL_YIELD", VALUEFUNC(_wrap_YieldType_ANNUAL_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_YEAR", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_REFUND", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_REFUND_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_AFTER_TAX_YIELD", VALUEFUNC(_wrap_YieldType_AFTER_TAX_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_AT_ISSUE", VALUEFUNC(_wrap_YieldType_YIELD_AT_ISSUE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_AVERAGE_LIFE", VALUEFUNC(_wrap_YieldType_YIELD_TO_AVERAGE_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_AVERAGE_MATURITY", VALUEFUNC(_wrap_YieldType_YIELD_TO_AVERAGE_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_BOOK_YIELD", VALUEFUNC(_wrap_YieldType_BOOK_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_CALL", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_CHANGE_SINCE_CLOSE", VALUEFUNC(_wrap_YieldType_YIELD_CHANGE_SINCE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_COMPOUND_YIELD", VALUEFUNC(_wrap_YieldType_COMPOUND_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CURRENT_YIELD", VALUEFUNC(_wrap_YieldType_CURRENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TRUE_GROSS_YIELD", VALUEFUNC(_wrap_YieldType_TRUE_GROSS_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_GVNT_EQUIVALENT_YIELD", VALUEFUNC(_wrap_YieldType_GVNT_EQUIVALENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_WITH_INFLATION_ASSUMPTION", VALUEFUNC(_wrap_YieldType_YIELD_WITH_INFLATION_ASSUMPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_INVERSE_FLOATER_BOND_YIELD", VALUEFUNC(_wrap_YieldType_INVERSE_FLOATER_BOND_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_MOST_RECENT_CLOSING_YIELD", VALUEFUNC(_wrap_YieldType_MOST_RECENT_CLOSING_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_MONTH", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_VALUE_OF132", VALUEFUNC(_wrap_YieldType_YIELD_VALUE_OF132_get), 0);
  rb_define_singleton_method(mQuickfix, "TradedFlatSwitch_NO", VALUEFUNC(_wrap_TradedFlatSwitch_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "TradedFlatSwitch_YES", VALUEFUNC(_wrap_TradedFlatSwitch_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_REMOVED_FROM_MARKET", VALUEFUNC(_wrap_QuoteStatus_REMOVED_FROM_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCEL_FOR_SYMBOL", VALUEFUNC(_wrap_QuoteStatus_CANCEL_FOR_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_PENDING", VALUEFUNC(_wrap_QuoteStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_QUOTE_NOT_FOUND", VALUEFUNC(_wrap_QuoteStatus_QUOTE_NOT_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_QUERY", VALUEFUNC(_wrap_QuoteStatus_QUERY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_EXPIRED", VALUEFUNC(_wrap_QuoteStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_REJECTED", VALUEFUNC(_wrap_QuoteStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_ALL", VALUEFUNC(_wrap_QuoteStatus_CANCELED_ALL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_FOR_UNDERLYING", VALUEFUNC(_wrap_QuoteStatus_CANCELED_FOR_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_FOR_SECURITY_TYPE", VALUEFUNC(_wrap_QuoteStatus_CANCELED_FOR_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_ACCEPTED", VALUEFUNC(_wrap_QuoteStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_PASS", VALUEFUNC(_wrap_QuoteStatus_PASS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_LOCKED_MARKET_WARNING", VALUEFUNC(_wrap_QuoteStatus_LOCKED_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CROSS_MARKET_WARNING", VALUEFUNC(_wrap_QuoteStatus_CROSS_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET", VALUEFUNC(_wrap_QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET", VALUEFUNC(_wrap_QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_ACTIVE", VALUEFUNC(_wrap_QuoteStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED", VALUEFUNC(_wrap_QuoteStatus_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_UNSOLICITED_QUOTE_REPLENISHMENT", VALUEFUNC(_wrap_QuoteStatus_UNSOLICITED_QUOTE_REPLENISHMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_PENDING_END_TRADE", VALUEFUNC(_wrap_QuoteStatus_PENDING_END_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_TOO_LATE_TO_END", VALUEFUNC(_wrap_QuoteStatus_TOO_LATE_TO_END_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_TRADED", VALUEFUNC(_wrap_QuoteStatus_TRADED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_TRADED_AND_REMOVED", VALUEFUNC(_wrap_QuoteStatus_TRADED_AND_REMOVED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CONTRACT_TERMINATES", VALUEFUNC(_wrap_QuoteStatus_CONTRACT_TERMINATES_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_CHINESE_INVESTOR_ID", VALUEFUNC(_wrap_PartyIDSource_CHINESE_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_US_EMPLOYER_OR_TAX_ID_NUMBER", VALUEFUNC(_wrap_PartyIDSource_US_EMPLOYER_OR_TAX_ID_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_PartyIDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_BIC", VALUEFUNC(_wrap_PartyIDSource_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_US_SOCIAL_SECURITY_NUMBER", VALUEFUNC(_wrap_PartyIDSource_US_SOCIAL_SECURITY_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_PROPRIETARY", VALUEFUNC(_wrap_PartyIDSource_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_SETTLEMENT_ENTITY_LOCATION", VALUEFUNC(_wrap_PartyIDSource_SETTLEMENT_ENTITY_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_KOREAN_INVESTOR_ID", VALUEFUNC(_wrap_PartyIDSource_KOREAN_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_TAIWANESE_FOREIGN_INVESTOR_ID", VALUEFUNC(_wrap_PartyIDSource_TAIWANESE_FOREIGN_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_TAIWANESE_TRADING_ACCT", VALUEFUNC(_wrap_PartyIDSource_TAIWANESE_TRADING_ACCT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY", VALUEFUNC(_wrap_PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER", VALUEFUNC(_wrap_PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_GENERAL_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_GENERAL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_MIC", VALUEFUNC(_wrap_PartyIDSource_MIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_CSD_PARTICIPANT", VALUEFUNC(_wrap_PartyIDSource_CSD_PARTICIPANT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_ISITC_ACRONYM", VALUEFUNC(_wrap_PartyIDSource_ISITC_ACRONYM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_TAX_ID", VALUEFUNC(_wrap_PartyIDSource_TAX_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_COMPANY_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_COMPANY_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_REGISTERED_BODY_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_REGISTERED_BODY_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_CFTC_REPORTING_FIRM_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_CFTC_REPORTING_FIRM_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_LEGAL_ENTITY_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_LEGAL_ENTITY_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_INTERIM_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_INTERIM_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_SHORT_CODE_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_SHORT_CODE_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_NATIONAL_ID_NATURAL_PERSON", VALUEFUNC(_wrap_PartyIDSource_NATIONAL_ID_NATURAL_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_INDIA_PERMANENT_ACCOUNT_NUMBER", VALUEFUNC(_wrap_PartyIDSource_INDIA_PERMANENT_ACCOUNT_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_FDID", VALUEFUNC(_wrap_PartyIDSource_FDID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_SPSAID", VALUEFUNC(_wrap_PartyIDSource_SPSAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_MASTER_SPSAID", VALUEFUNC(_wrap_PartyIDSource_MASTER_SPSAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CORRESPONDANT_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_CORRESPONDANT_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLIENT_ID", VALUEFUNC(_wrap_PartyRole_CLIENT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_UNDERLYING_CONTRA_FIRM", VALUEFUNC(_wrap_PartyRole_UNDERLYING_CONTRA_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SPONSORING_FIRM", VALUEFUNC(_wrap_PartyRole_SPONSORING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_CONTRA_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_FIRM", VALUEFUNC(_wrap_PartyRole_CONTRA_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTING_SYSTEM", VALUEFUNC(_wrap_PartyRole_EXECUTING_SYSTEM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ENTERING_FIRM", VALUEFUNC(_wrap_PartyRole_ENTERING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTING_FIRM", VALUEFUNC(_wrap_PartyRole_EXECUTING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BROKER_OF_CREDIT", VALUEFUNC(_wrap_PartyRole_BROKER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INVESTOR_ID", VALUEFUNC(_wrap_PartyRole_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTRODUCING_FIRM", VALUEFUNC(_wrap_PartyRole_INTRODUCING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_GIVEUP_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_GIVEUP_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LOCATE", VALUEFUNC(_wrap_PartyRole_LOCATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_FUND_MANAGER_CLIENT_ID", VALUEFUNC(_wrap_PartyRole_FUND_MANAGER_CLIENT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SETTLEMENT_LOCATION", VALUEFUNC(_wrap_PartyRole_SETTLEMENT_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ORDER_ORIGINATION_TRADER", VALUEFUNC(_wrap_PartyRole_ORDER_ORIGINATION_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTING_TRADER", VALUEFUNC(_wrap_PartyRole_EXECUTING_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ORDER_ORIGINATION_FIRM", VALUEFUNC(_wrap_PartyRole_ORDER_ORIGINATION_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLEARING_ORGANIZATION", VALUEFUNC(_wrap_PartyRole_CLEARING_ORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXCHANGE", VALUEFUNC(_wrap_PartyRole_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CUSTOMER_ACCOUNT", VALUEFUNC(_wrap_PartyRole_CUSTOMER_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CORRESPONDENT_CLEARING_ORGANIZATION", VALUEFUNC(_wrap_PartyRole_CORRESPONDENT_CLEARING_ORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CORRESPONDENT_BROKER", VALUEFUNC(_wrap_PartyRole_CORRESPONDENT_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BUYER", VALUEFUNC(_wrap_PartyRole_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CUSTODIAN", VALUEFUNC(_wrap_PartyRole_CUSTODIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTERMEDIARY", VALUEFUNC(_wrap_PartyRole_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_AGENT", VALUEFUNC(_wrap_PartyRole_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SUB_CUSTODIAN", VALUEFUNC(_wrap_PartyRole_SUB_CUSTODIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BENEFICIARY", VALUEFUNC(_wrap_PartyRole_BENEFICIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTERESTED_PARTY", VALUEFUNC(_wrap_PartyRole_INTERESTED_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REGULATORY_BODY", VALUEFUNC(_wrap_PartyRole_REGULATORY_BODY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LIQUIDITY_PROVIDER", VALUEFUNC(_wrap_PartyRole_LIQUIDITY_PROVIDER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ENTERING_TRADER", VALUEFUNC(_wrap_PartyRole_ENTERING_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_TRADER", VALUEFUNC(_wrap_PartyRole_CONTRA_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_POSITION_ACCOUNT", VALUEFUNC(_wrap_PartyRole_POSITION_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_INVESTOR_ID", VALUEFUNC(_wrap_PartyRole_CONTRA_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_TRANSFER_TO_FIRM", VALUEFUNC(_wrap_PartyRole_TRANSFER_TO_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_POSITION_ACCOUNT", VALUEFUNC(_wrap_PartyRole_CONTRA_POSITION_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_EXCHANGE", VALUEFUNC(_wrap_PartyRole_CONTRA_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTERNAL_CARRY_ACCOUNT", VALUEFUNC(_wrap_PartyRole_INTERNAL_CARRY_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ORDER_ENTRY_OPERATOR_ID", VALUEFUNC(_wrap_PartyRole_ORDER_ENTRY_OPERATOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SECONDARY_ACCOUNT_NUMBER", VALUEFUNC(_wrap_PartyRole_SECONDARY_ACCOUNT_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_FOREIGN_FIRM", VALUEFUNC(_wrap_PartyRole_FOREIGN_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_THIRD_PARTY_ALLOCATION_FIRM", VALUEFUNC(_wrap_PartyRole_THIRD_PARTY_ALLOCATION_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLAIMING_ACCOUNT", VALUEFUNC(_wrap_PartyRole_CLAIMING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ASSET_MANAGER", VALUEFUNC(_wrap_PartyRole_ASSET_MANAGER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_PLEDGOR_ACCOUNT", VALUEFUNC(_wrap_PartyRole_PLEDGOR_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_PLEDGEE_ACCOUNT", VALUEFUNC(_wrap_PartyRole_PLEDGEE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LARGE_TRADER_REPORTABLE_ACCOUNT", VALUEFUNC(_wrap_PartyRole_LARGE_TRADER_REPORTABLE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_TRADER_MNEMONIC", VALUEFUNC(_wrap_PartyRole_TRADER_MNEMONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SENDER_LOCATION", VALUEFUNC(_wrap_PartyRole_SENDER_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SESSION_ID", VALUEFUNC(_wrap_PartyRole_SESSION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ACCEPTABLE_COUNTERPARTY", VALUEFUNC(_wrap_PartyRole_ACCEPTABLE_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_UNACCEPTABLE_COUNTERPARTY", VALUEFUNC(_wrap_PartyRole_UNACCEPTABLE_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ENTERING_UNIT", VALUEFUNC(_wrap_PartyRole_ENTERING_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTING_UNIT", VALUEFUNC(_wrap_PartyRole_EXECUTING_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTRODUCING_BROKER", VALUEFUNC(_wrap_PartyRole_INTRODUCING_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_QUOTE_ORIGINATOR", VALUEFUNC(_wrap_PartyRole_QUOTE_ORIGINATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REPORT_ORIGINATOR", VALUEFUNC(_wrap_PartyRole_REPORT_ORIGINATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SYSTEMATIC_INTERNALISER", VALUEFUNC(_wrap_PartyRole_SYSTEMATIC_INTERNALISER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_MULTILATERAL_TRADING_FACILITY", VALUEFUNC(_wrap_PartyRole_MULTILATERAL_TRADING_FACILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REGULATED_MARKET", VALUEFUNC(_wrap_PartyRole_REGULATED_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_MARKET_MAKER", VALUEFUNC(_wrap_PartyRole_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INVESTMENT_FIRM", VALUEFUNC(_wrap_PartyRole_INVESTMENT_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_HOST_COMPETENT_AUTHORITY", VALUEFUNC(_wrap_PartyRole_HOST_COMPETENT_AUTHORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_HOME_COMPETENT_AUTHORITY", VALUEFUNC(_wrap_PartyRole_HOME_COMPETENT_AUTHORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_COMPETENT_AUTHORITY_LIQUIDITY", VALUEFUNC(_wrap_PartyRole_COMPETENT_AUTHORITY_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_COMPETENT_AUTHORITY_TRANSACTION_VENUE", VALUEFUNC(_wrap_PartyRole_COMPETENT_AUTHORITY_TRANSACTION_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REPORTING_INTERMEDIARY", VALUEFUNC(_wrap_PartyRole_REPORTING_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTION_VENUE", VALUEFUNC(_wrap_PartyRole_EXECUTION_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_MARKET_DATA_ENTRY_ORIGINATOR", VALUEFUNC(_wrap_PartyRole_MARKET_DATA_ENTRY_ORIGINATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LOCATION_ID", VALUEFUNC(_wrap_PartyRole_LOCATION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_DESK_ID", VALUEFUNC(_wrap_PartyRole_DESK_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_MARKET_DATA_MARKET", VALUEFUNC(_wrap_PartyRole_MARKET_DATA_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ALLOCATION_ENTITY", VALUEFUNC(_wrap_PartyRole_ALLOCATION_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_PRIME_BROKER", VALUEFUNC(_wrap_PartyRole_PRIME_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_STEP_OUT_FIRM", VALUEFUNC(_wrap_PartyRole_STEP_OUT_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BROKER_CLEARING_ID", VALUEFUNC(_wrap_PartyRole_BROKER_CLEARING_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_GIVEUP_CLEARING_FIRM_DEPR", VALUEFUNC(_wrap_PartyRole_GIVEUP_CLEARING_FIRM_DEPR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CENTRAL_REGISTRATION_DEPOSITORY", VALUEFUNC(_wrap_PartyRole_CENTRAL_REGISTRATION_DEPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLEARING_ACCOUNT", VALUEFUNC(_wrap_PartyRole_CLEARING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ACCEPTABLE_SETTLING_COUNTERPARTY", VALUEFUNC(_wrap_PartyRole_ACCEPTABLE_SETTLING_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_UNACCEPTABLE_SETTLING_COUNTERPARTY", VALUEFUNC(_wrap_PartyRole_UNACCEPTABLE_SETTLING_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLS_MEMBER_BANK", VALUEFUNC(_wrap_PartyRole_CLS_MEMBER_BANK_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_IN_CONCERT_GROUP", VALUEFUNC(_wrap_PartyRole_IN_CONCERT_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_IN_CONCERT_CONTROLLING_ENTITY", VALUEFUNC(_wrap_PartyRole_IN_CONCERT_CONTROLLING_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LARGE_POSITIONS_REPORTING_ACCOUNT", VALUEFUNC(_wrap_PartyRole_LARGE_POSITIONS_REPORTING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SETTLEMENT_FIRM", VALUEFUNC(_wrap_PartyRole_SETTLEMENT_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SETTLEMENT_ACCOUNT", VALUEFUNC(_wrap_PartyRole_SETTLEMENT_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REPORTING_MARKET_CENTER", VALUEFUNC(_wrap_PartyRole_REPORTING_MARKET_CENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_RELATED_REPORTING_MARKET_CENTER", VALUEFUNC(_wrap_PartyRole_RELATED_REPORTING_MARKET_CENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_AWAY_MARKET", VALUEFUNC(_wrap_PartyRole_AWAY_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_GIVEUP_TRADING_FIRM", VALUEFUNC(_wrap_PartyRole_GIVEUP_TRADING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_TAKEUP_TRADING_FIRM", VALUEFUNC(_wrap_PartyRole_TAKEUP_TRADING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_TAKEUP_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_TAKEUP_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ORIGINATING_MARKET", VALUEFUNC(_wrap_PartyRole_ORIGINATING_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_MARGIN_ACCOUNT", VALUEFUNC(_wrap_PartyRole_MARGIN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_COLLATERAL_ASSET_ACCOUNT", VALUEFUNC(_wrap_PartyRole_COLLATERAL_ASSET_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_DATA_REPOSITORY", VALUEFUNC(_wrap_PartyRole_DATA_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CALCULATION_AGENT", VALUEFUNC(_wrap_PartyRole_CALCULATION_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXERCISE_NOTICE_SENDER", VALUEFUNC(_wrap_PartyRole_EXERCISE_NOTICE_SENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXERCISE_NOTICE_RECEIVER", VALUEFUNC(_wrap_PartyRole_EXERCISE_NOTICE_RECEIVER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_RATE_REFERENCE_BANK", VALUEFUNC(_wrap_PartyRole_RATE_REFERENCE_BANK_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CORRESPONDENT", VALUEFUNC(_wrap_PartyRole_CORRESPONDENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BENEFICIARY_BANK", VALUEFUNC(_wrap_PartyRole_BENEFICIARY_BANK_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BORROWER", VALUEFUNC(_wrap_PartyRole_BORROWER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_PRIMARY_OBLIGATOR", VALUEFUNC(_wrap_PartyRole_PRIMARY_OBLIGATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_GUARANTOR", VALUEFUNC(_wrap_PartyRole_GUARANTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXCLUDED_REFERENCE_ENTITY", VALUEFUNC(_wrap_PartyRole_EXCLUDED_REFERENCE_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_DETERMINING_PARTY", VALUEFUNC(_wrap_PartyRole_DETERMINING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_HEDGING_PARTY", VALUEFUNC(_wrap_PartyRole_HEDGING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_REPORTING_ENTITY", VALUEFUNC(_wrap_PartyRole_REPORTING_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_SALES_PERSON", VALUEFUNC(_wrap_PartyRole_SALES_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_OPERATOR", VALUEFUNC(_wrap_PartyRole_OPERATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CSD", VALUEFUNC(_wrap_PartyRole_CSD_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ICSD", VALUEFUNC(_wrap_PartyRole_ICSD_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_TRADING_SUB_ACCOUNT", VALUEFUNC(_wrap_PartyRole_TRADING_SUB_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INVESTMENT_DECISION_MAKER", VALUEFUNC(_wrap_PartyRole_INVESTMENT_DECISION_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_PUBLISHING_INTERMEDIARY", VALUEFUNC(_wrap_PartyRole_PUBLISHING_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CSD_PARTICIPANT", VALUEFUNC(_wrap_PartyRole_CSD_PARTICIPANT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ISSUER", VALUEFUNC(_wrap_PartyRole_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_CUSTOMER_ACCOUNT", VALUEFUNC(_wrap_PartyRole_CONTRA_CUSTOMER_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CONTRA_INVESTMENT_DECISION_MAKER", VALUEFUNC(_wrap_PartyRole_CONTRA_INVESTMENT_DECISION_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_LOAN", VALUEFUNC(_wrap_Product_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_OTHER", VALUEFUNC(_wrap_Product_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MUNICIPAL", VALUEFUNC(_wrap_Product_MUNICIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_AGENCY", VALUEFUNC(_wrap_Product_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_CORPORATE", VALUEFUNC(_wrap_Product_CORPORATE_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_CURRENCY", VALUEFUNC(_wrap_Product_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_COMMODITY", VALUEFUNC(_wrap_Product_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_GOVERNMENT", VALUEFUNC(_wrap_Product_GOVERNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MORTGAGE", VALUEFUNC(_wrap_Product_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_INDEX", VALUEFUNC(_wrap_Product_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MONEYMARKET", VALUEFUNC(_wrap_Product_MONEYMARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_EQUITY", VALUEFUNC(_wrap_Product_EQUITY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_FINANCING", VALUEFUNC(_wrap_Product_FINANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CONTRACTS", VALUEFUNC(_wrap_QuantityType_CONTRACTS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_OTHER", VALUEFUNC(_wrap_QuantityType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CURRENCY", VALUEFUNC(_wrap_QuantityType_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_ORIGINALFACE", VALUEFUNC(_wrap_QuantityType_ORIGINALFACE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CURRENTFACE", VALUEFUNC(_wrap_QuantityType_CURRENTFACE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_BONDS", VALUEFUNC(_wrap_QuantityType_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_SHARES", VALUEFUNC(_wrap_QuantityType_SHARES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_PAR", VALUEFUNC(_wrap_QuantityType_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_TO_NEAREST", VALUEFUNC(_wrap_RoundingDirection_ROUND_TO_NEAREST_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_DOWN", VALUEFUNC(_wrap_RoundingDirection_ROUND_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_UP", VALUEFUNC(_wrap_RoundingDirection_ROUND_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CREST", VALUEFUNC(_wrap_DistribPaymentMethod_CREST_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_NSCC", VALUEFUNC(_wrap_DistribPaymentMethod_NSCC_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_EUROCLEAR", VALUEFUNC(_wrap_DistribPaymentMethod_EUROCLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CLEARSTREAM", VALUEFUNC(_wrap_DistribPaymentMethod_CLEARSTREAM_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CHEQUE", VALUEFUNC(_wrap_DistribPaymentMethod_CHEQUE_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_TELEGRAPHIC_TRANSFER", VALUEFUNC(_wrap_DistribPaymentMethod_TELEGRAPHIC_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_FED_WIRE", VALUEFUNC(_wrap_DistribPaymentMethod_FED_WIRE_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_DIRECT_CREDIT", VALUEFUNC(_wrap_DistribPaymentMethod_DIRECT_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_ACH_CREDIT", VALUEFUNC(_wrap_DistribPaymentMethod_ACH_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_BPAY", VALUEFUNC(_wrap_DistribPaymentMethod_BPAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_HVACS", VALUEFUNC(_wrap_DistribPaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_HVACS_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_REINVEST_IN_FUND", VALUEFUNC(_wrap_DistribPaymentMethod_REINVEST_IN_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_OTHER", VALUEFUNC(_wrap_DistribPaymentMethod_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_WAIVER_AGREEMENT", VALUEFUNC(_wrap_CancellationRights_NO_WAIVER_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_EXECUTION_ONLY", VALUEFUNC(_wrap_CancellationRights_NO_EXECUTION_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_YES", VALUEFUNC(_wrap_CancellationRights_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_INSTITUTIONAL", VALUEFUNC(_wrap_CancellationRights_NO_INSTITUTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_AUTHORISED", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_AUTHORISED_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_MONEY_TYPE", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_MONEY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_BELOW_LIMIT", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_BELOW_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_PASSED", VALUEFUNC(_wrap_MoneyLaunderingStatus_PASSED_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_NOT_CHECKED", VALUEFUNC(_wrap_MoneyLaunderingStatus_NOT_CHECKED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_SINGLE_PRICE", VALUEFUNC(_wrap_ExecPriceType_SINGLE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_BID_PRICE", VALUEFUNC(_wrap_ExecPriceType_BID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_NEW", VALUEFUNC(_wrap_TradeReportTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_REPLACE", VALUEFUNC(_wrap_TradeReportTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_CANCEL", VALUEFUNC(_wrap_TradeReportTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_RELEASE", VALUEFUNC(_wrap_TradeReportTransType_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_REVERSE", VALUEFUNC(_wrap_TradeReportTransType_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_CANCEL_DUE_TO_BACK_OUT_OF_TRADE", VALUEFUNC(_wrap_TradeReportTransType_CANCEL_DUE_TO_BACK_OUT_OF_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_BPAY", VALUEFUNC(_wrap_PaymentMethod_BPAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_ACH_CREDIT", VALUEFUNC(_wrap_PaymentMethod_ACH_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_ACH_DEBIT", VALUEFUNC(_wrap_PaymentMethod_ACH_DEBIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CREDIT_CARD", VALUEFUNC(_wrap_PaymentMethod_CREDIT_CARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_DIRECT_CREDIT", VALUEFUNC(_wrap_PaymentMethod_DIRECT_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_DIRECT_DEBIT", VALUEFUNC(_wrap_PaymentMethod_DIRECT_DEBIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_DEBIT_CARD", VALUEFUNC(_wrap_PaymentMethod_DEBIT_CARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_FED_WIRE", VALUEFUNC(_wrap_PaymentMethod_FED_WIRE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_HIGH_VALUE_CLEARING_SYSTEM", VALUEFUNC(_wrap_PaymentMethod_HIGH_VALUE_CLEARING_SYSTEM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_EUROCLEAR", VALUEFUNC(_wrap_PaymentMethod_EUROCLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_TELEGRAPHIC_TRANSFER", VALUEFUNC(_wrap_PaymentMethod_TELEGRAPHIC_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CLEARSTREAM", VALUEFUNC(_wrap_PaymentMethod_CLEARSTREAM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CREST", VALUEFUNC(_wrap_PaymentMethod_CREST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_NSCC", VALUEFUNC(_wrap_PaymentMethod_NSCC_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CHEQUE", VALUEFUNC(_wrap_PaymentMethod_CHEQUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CHIPS", VALUEFUNC(_wrap_PaymentMethod_CHIPS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_SWIFT", VALUEFUNC(_wrap_PaymentMethod_SWIFT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CHAPS", VALUEFUNC(_wrap_PaymentMethod_CHAPS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_SIC", VALUEFUNC(_wrap_PaymentMethod_SIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_EURO_SIC", VALUEFUNC(_wrap_PaymentMethod_EURO_SIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_OTHER", VALUEFUNC(_wrap_PaymentMethod_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_PROFIT_SHARING_PLAN", VALUEFUNC(_wrap_TaxAdvantageType_PROFIT_SHARING_PLAN_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EMPLOYER_PRIOR_YEAR", VALUEFUNC(_wrap_TaxAdvantageType_EMPLOYER_PRIOR_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EMPLOYER_CURRENT_YEAR", VALUEFUNC(_wrap_TaxAdvantageType_EMPLOYER_CURRENT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_NON_FUND_PROTOTYPE_IRA", VALUEFUNC(_wrap_TaxAdvantageType_NON_FUND_PROTOTYPE_IRA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_NON_FUND_QUALIFIED_PLAN", VALUEFUNC(_wrap_TaxAdvantageType_NON_FUND_QUALIFIED_PLAN_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_DEFINED_CONTRIBUTION_PLAN", VALUEFUNC(_wrap_TaxAdvantageType_DEFINED_CONTRIBUTION_PLAN_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EMPLOYEE_CURRENT_YEAR", VALUEFUNC(_wrap_TaxAdvantageType_EMPLOYEE_CURRENT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_IRA_ROLLOVER", VALUEFUNC(_wrap_TaxAdvantageType_IRA_ROLLOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_INSURANCE_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_INSURANCE_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_IRA", VALUEFUNC(_wrap_TaxAdvantageType_IRA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EMPLOYEE_PRIOR_YEAR", VALUEFUNC(_wrap_TaxAdvantageType_EMPLOYEE_PRIOR_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ASSET_TRANSFER", VALUEFUNC(_wrap_TaxAdvantageType_ASSET_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_SELF_DIRECTED_IRA", VALUEFUNC(_wrap_TaxAdvantageType_SELF_DIRECTED_IRA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_CURRENT_YEAR_PAYMENT", VALUEFUNC(_wrap_TaxAdvantageType_CURRENT_YEAR_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_US401_K", VALUEFUNC(_wrap_TaxAdvantageType_US401_K_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_CASH_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_CASH_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_TESSA", VALUEFUNC(_wrap_TaxAdvantageType_TESSA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MAXI_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MAXI_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_NONE", VALUEFUNC(_wrap_TaxAdvantageType_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_PRIOR_YEAR_PAYMENT", VALUEFUNC(_wrap_TaxAdvantageType_PRIOR_YEAR_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_US457", VALUEFUNC(_wrap_TaxAdvantageType_US457_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ROTH_IRA_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_ROTH_IRA_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ROTH_IRA_NON_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_ROTH_IRA_NON_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ROTH_CONVERSION_IRA_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_ROTH_CONVERSION_IRA_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ROTH_CONVERSION_IRA_NON_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_ROTH_CONVERSION_IRA_NON_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EDUCATION_IRA_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_EDUCATION_IRA_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EDUCATION_IRA_NON_PROTOTYPE", VALUEFUNC(_wrap_TaxAdvantageType_EDUCATION_IRA_NON_PROTOTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_KEOGH", VALUEFUNC(_wrap_TaxAdvantageType_KEOGH_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_US403B", VALUEFUNC(_wrap_TaxAdvantageType_US403B_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_OTHER", VALUEFUNC(_wrap_TaxAdvantageType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "FundRenewWaiv_NO", VALUEFUNC(_wrap_FundRenewWaiv_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "FundRenewWaiv_YES", VALUEFUNC(_wrap_FundRenewWaiv_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_ACCEPTED", VALUEFUNC(_wrap_RegistStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_REMINDER", VALUEFUNC(_wrap_RegistStatus_REMINDER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_REJECTED", VALUEFUNC(_wrap_RegistStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_HELD", VALUEFUNC(_wrap_RegistStatus_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_DISTRIB_INSTNS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_DISTRIB_INSTNS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_AGENT_CODE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_AGENT_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_ACCOUNT_NAME", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_ACCOUNT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_NO_REG_DETAILS", VALUEFUNC(_wrap_RegistRejReasonCode_NO_REG_DETAILS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_PAYMENT_METHOD", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_PAYMENT_METHOD_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_PERCENTAGE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_OWNERSHIP_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_OWNERSHIP_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_TAX_EXEMPT_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_TAX_EXEMPT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_COUNTRY", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_DATE_OF_BIRTH", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_DATE_OF_BIRTH_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_INVESTOR_ID_SOURCE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_INVESTOR_ID_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_INVESTOR_ID", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_MAILING_INSTRUCTIONS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_MAILING_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_MAILING_DETAILS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_MAILING_DETAILS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_REG_SEQ_NO", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_REG_SEQ_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_ACCOUNT_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_ACCOUNT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_ACCOUNT_NUM", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_ACCOUNT_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_REG_DETAILS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_REG_DETAILS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_OTHER", VALUEFUNC(_wrap_RegistRejReasonCode_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_CANCEL", VALUEFUNC(_wrap_RegistTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_NEW", VALUEFUNC(_wrap_RegistTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_REPLACE", VALUEFUNC(_wrap_RegistTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_JOINT_INVESTORS", VALUEFUNC(_wrap_OwnershipType_JOINT_INVESTORS_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_TENANTS_IN_COMMON", VALUEFUNC(_wrap_OwnershipType_TENANTS_IN_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_JOINT_TRUSTEES", VALUEFUNC(_wrap_OwnershipType_JOINT_TRUSTEES_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_NET_SETTLEMENT_AMOUNT", VALUEFUNC(_wrap_ContAmtType_NET_SETTLEMENT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_COMMISSION_AMOUNT", VALUEFUNC(_wrap_ContAmtType_COMMISSION_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_COMMISSION_PERCENT", VALUEFUNC(_wrap_ContAmtType_COMMISSION_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_INITIAL_CHARGE_AMOUNT", VALUEFUNC(_wrap_ContAmtType_INITIAL_CHARGE_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_INITIAL_CHARGE_PERCENT", VALUEFUNC(_wrap_ContAmtType_INITIAL_CHARGE_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DISCOUNT_AMOUNT", VALUEFUNC(_wrap_ContAmtType_DISCOUNT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DISCOUNT_PERCENT", VALUEFUNC(_wrap_ContAmtType_DISCOUNT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DILUTION_LEVY_AMOUNT", VALUEFUNC(_wrap_ContAmtType_DILUTION_LEVY_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DILUTION_LEVY_PERCENT", VALUEFUNC(_wrap_ContAmtType_DILUTION_LEVY_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_EXIT_CHARGE_AMOUNT", VALUEFUNC(_wrap_ContAmtType_EXIT_CHARGE_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_EXIT_CHARGE_PERCENT", VALUEFUNC(_wrap_ContAmtType_EXIT_CHARGE_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_FUND_BASED_RENEWAL_COMMISSION_PERCENT", VALUEFUNC(_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_PROJECTED_FUND_VALUE", VALUEFUNC(_wrap_ContAmtType_PROJECTED_FUND_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_FUND", VALUEFUNC(_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_ORDER", VALUEFUNC(_wrap_ContAmtType_FUND_BASED_RENEWAL_COMMISSION_ON_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_COMPANY_TRUSTEE", VALUEFUNC(_wrap_OwnerType_COMPANY_TRUSTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_NOMINEE", VALUEFUNC(_wrap_OwnerType_NOMINEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_CORPORATE_BODY", VALUEFUNC(_wrap_OwnerType_CORPORATE_BODY_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_NON_PROFIT_ORGANIZATION", VALUEFUNC(_wrap_OwnerType_NON_PROFIT_ORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_NETWORKING_SUB_ACCOUNT", VALUEFUNC(_wrap_OwnerType_NETWORKING_SUB_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_FIDUCIARIES", VALUEFUNC(_wrap_OwnerType_FIDUCIARIES_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_TRUSTS", VALUEFUNC(_wrap_OwnerType_TRUSTS_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PENSION_PLAN", VALUEFUNC(_wrap_OwnerType_PENSION_PLAN_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_INDIVIDUAL_TRUSTEE", VALUEFUNC(_wrap_OwnerType_INDIVIDUAL_TRUSTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PUBLIC_COMPANY", VALUEFUNC(_wrap_OwnerType_PUBLIC_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PRIVATE_COMPANY", VALUEFUNC(_wrap_OwnerType_PRIVATE_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_INDIVIDUAL_INVESTOR", VALUEFUNC(_wrap_OwnerType_INDIVIDUAL_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT", VALUEFUNC(_wrap_OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_INSTITUTIONAL_CUSTOMER", VALUEFUNC(_wrap_OwnerType_INSTITUTIONAL_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_COMBINED", VALUEFUNC(_wrap_OwnerType_COMBINED_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_MEMBER_FIRM_EMPLOYEE", VALUEFUNC(_wrap_OwnerType_MEMBER_FIRM_EMPLOYEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_MARKET_MAKING_ACCOUNT", VALUEFUNC(_wrap_OwnerType_MARKET_MAKING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PROPRIETARY_ACCOUNT", VALUEFUNC(_wrap_OwnerType_PROPRIETARY_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_NONBROKER_DEALER", VALUEFUNC(_wrap_OwnerType_NONBROKER_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_UNKNOWN_BENEFICIAL_OWNER_TYPE", VALUEFUNC(_wrap_OwnerType_UNKNOWN_BENEFICIAL_OWNER_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_FIRMS_ERROR_ACCOUNT", VALUEFUNC(_wrap_OwnerType_FIRMS_ERROR_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_FIRM_AGENCY_AVERAGE_PRICE_ACCOUNT", VALUEFUNC(_wrap_OwnerType_FIRM_AGENCY_AVERAGE_PRICE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_OrderCapacity_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_INDIVIDUAL", VALUEFUNC(_wrap_OrderCapacity_INDIVIDUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_PRINCIPAL", VALUEFUNC(_wrap_OrderCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_AGENT_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_OrderCapacity_AGENT_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_AGENCY", VALUEFUNC(_wrap_OrderCapacity_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_PROPRIETARY", VALUEFUNC(_wrap_OrderCapacity_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_MIXED_CAPACITY", VALUEFUNC(_wrap_OrderCapacity_MIXED_CAPACITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_FOREIGN_ENTITY", VALUEFUNC(_wrap_OrderRestrictions_FOREIGN_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_RISKLESS_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_RISKLESS_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_PROGRAM_TRADE", VALUEFUNC(_wrap_OrderRestrictions_PROGRAM_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT", VALUEFUNC(_wrap_OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_UNDERLYING", VALUEFUNC(_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY", VALUEFUNC(_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_NON_INDEX_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_NON_INDEX_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_INDEX_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_INDEX_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_COMPETING_MARKET_MAKER", VALUEFUNC(_wrap_OrderRestrictions_COMPETING_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE", VALUEFUNC(_wrap_OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ISSUER_HOLDING", VALUEFUNC(_wrap_OrderRestrictions_ISSUER_HOLDING_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ISSUE_PRICE_STABILIZATION", VALUEFUNC(_wrap_OrderRestrictions_ISSUE_PRICE_STABILIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_NON_ALGORITHMIC", VALUEFUNC(_wrap_OrderRestrictions_NON_ALGORITHMIC_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ALGORITHMIC", VALUEFUNC(_wrap_OrderRestrictions_ALGORITHMIC_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_CROSS", VALUEFUNC(_wrap_OrderRestrictions_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_INSIDER_ACCOUNT", VALUEFUNC(_wrap_OrderRestrictions_INSIDER_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_SIGNIFICANT_SHAREHOLDER", VALUEFUNC(_wrap_OrderRestrictions_SIGNIFICANT_SHAREHOLDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_NORMAL_COURSE_ISSUER_BID", VALUEFUNC(_wrap_OrderRestrictions_NORMAL_COURSE_ISSUER_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ALL_ORDERS", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_TYPE", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_ACFI_CODE", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_ACFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_GROUP", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_SECURITY_ISSUER", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_REQUEST_REJECTED", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ALL_ORDERS", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_TYPE", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_ACFI_CODE", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_ACFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_GROUP", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITIES_ISSUER", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITIES_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKOWN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKOWN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED", VALUEFUNC(_wrap_MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_CFI_CODE", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_CFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_OTHER", VALUEFUNC(_wrap_MassCancelRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_MARKET", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKOWN_MARKET_SEGMENT", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKOWN_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_INDICATIVE", VALUEFUNC(_wrap_QuoteType_INDICATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_TRADEABLE", VALUEFUNC(_wrap_QuoteType_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_RESTRICTED_TRADEABLE", VALUEFUNC(_wrap_QuoteType_RESTRICTED_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_COUNTER", VALUEFUNC(_wrap_QuoteType_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_INITIALLY_TRADEABLE", VALUEFUNC(_wrap_QuoteType_INITIALLY_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_MARGIN_OPEN", VALUEFUNC(_wrap_CashMargin_MARGIN_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_MARGIN_CLOSE", VALUEFUNC(_wrap_CashMargin_MARGIN_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_CASH", VALUEFUNC(_wrap_CashMargin_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_LOCAL_MARKET", VALUEFUNC(_wrap_Scope_LOCAL_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_NATIONAL", VALUEFUNC(_wrap_Scope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_GLOBAL", VALUEFUNC(_wrap_Scope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDImplicitDelete_YES", VALUEFUNC(_wrap_MDImplicitDelete_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDImplicitDelete_NO", VALUEFUNC(_wrap_MDImplicitDelete_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_AON", VALUEFUNC(_wrap_CrossType_CROSS_AON_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_IOC", VALUEFUNC(_wrap_CrossType_CROSS_IOC_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_ONE_SIDE", VALUEFUNC(_wrap_CrossType_CROSS_ONE_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_SAME_PRICE", VALUEFUNC(_wrap_CrossType_CROSS_SAME_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_BASIS_CROSS", VALUEFUNC(_wrap_CrossType_BASIS_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CONTINGENT_CROSS", VALUEFUNC(_wrap_CrossType_CONTINGENT_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_VWAP_CROSS", VALUEFUNC(_wrap_CrossType_VWAP_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_STS_CROSS", VALUEFUNC(_wrap_CrossType_STS_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CUSTOMER_TO_CUSTOMER", VALUEFUNC(_wrap_CrossType_CUSTOMER_TO_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_SELL_SIDE_IS_PRIORITIZED", VALUEFUNC(_wrap_CrossPrioritization_SELL_SIDE_IS_PRIORITIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_NONE", VALUEFUNC(_wrap_CrossPrioritization_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_BUY_SIDE_IS_PRIORITIZED", VALUEFUNC(_wrap_CrossPrioritization_BUY_SIDE_IS_PRIORITIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "NoSides_ONE_SIDE", VALUEFUNC(_wrap_NoSides_ONE_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "NoSides_BOTH_SIDES", VALUEFUNC(_wrap_NoSides_BOTH_SIDES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_SECURITY_TYPE_AND", VALUEFUNC(_wrap_SecurityListRequestType_SECURITY_TYPE_AND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_PRODUCT", VALUEFUNC(_wrap_SecurityListRequestType_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_TRADING_SESSION_ID", VALUEFUNC(_wrap_SecurityListRequestType_TRADING_SESSION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_ALL_SECURITIES", VALUEFUNC(_wrap_SecurityListRequestType_ALL_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_SYMBOL", VALUEFUNC(_wrap_SecurityListRequestType_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_MARKET_ID_OR_MARKET_ID", VALUEFUNC(_wrap_SecurityListRequestType_MARKET_ID_OR_MARKET_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE", VALUEFUNC(_wrap_SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_VALID_REQUEST", VALUEFUNC(_wrap_SecurityRequestResult_VALID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST", VALUEFUNC(_wrap_SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED", VALUEFUNC(_wrap_SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA", VALUEFUNC(_wrap_SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_NO_INSTRUMENTS_FOUND", VALUEFUNC(_wrap_SecurityRequestResult_NO_INSTRUMENTS_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_INSTRUMENT_LEGS", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_INSTRUMENT_LEGS_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_ONLY", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADING_SESSION_ID", VALUEFUNC(_wrap_TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADING_SESSION_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatusRejReason_OTHER", VALUEFUNC(_wrap_TradSesStatusRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_ALL_TRADES", VALUEFUNC(_wrap_TradeRequestType_ALL_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "PreviouslyReported_NO", VALUEFUNC(_wrap_PreviouslyReported_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "PreviouslyReported_YES", VALUEFUNC(_wrap_PreviouslyReported_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_COMPARED", VALUEFUNC(_wrap_MatchStatus_COMPARED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_UNCOMPARED", VALUEFUNC(_wrap_MatchStatus_UNCOMPARED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_ADVISORY_OR_ALERT", VALUEFUNC(_wrap_MatchStatus_ADVISORY_OR_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_MISMATCHED", VALUEFUNC(_wrap_MatchStatus_MISMATCHED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_A5_EXACT_MATCH_SUMMARIZED_QUANTITY", VALUEFUNC(_wrap_MatchType_A5_EXACT_MATCH_SUMMARIZED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_MINUS_BADGES_TIMES", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_MINUS_BADGES_TIMES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ACTM6_MATCH", VALUEFUNC(_wrap_MatchType_ACTM6_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ACT_DEFAULT_AFTER_M2", VALUEFUNC(_wrap_MatchType_ACT_DEFAULT_AFTER_M2_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ACT_ACCEPTED_TRADE", VALUEFUNC(_wrap_MatchType_ACT_ACCEPTED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_A2_EXACT_MATCH_SUMMARIZED_QUANTITY", VALUEFUNC(_wrap_MatchType_A2_EXACT_MATCH_SUMMARIZED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_A3_EXACT_MATCH_SUMMARIZED_QUANTITY", VALUEFUNC(_wrap_MatchType_A3_EXACT_MATCH_SUMMARIZED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_A4_EXACT_MATCH_SUMMARIZED_QUANTITY", VALUEFUNC(_wrap_MatchType_A4_EXACT_MATCH_SUMMARIZED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_SUMMARIZED_MATCH_MINUS_BADGES_TIMES", VALUEFUNC(_wrap_MatchType_SUMMARIZED_MATCH_MINUS_BADGES_TIMES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_PLUS4_BADGES", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_PLUS4_BADGES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_PLUS2_BADGES_EXEC_TIME", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_PLUS2_BADGES_EXEC_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_PLUS2_BADGES", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_PLUS2_BADGES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS", VALUEFUNC(_wrap_MatchType_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_OCS_LOCKED_IN", VALUEFUNC(_wrap_MatchType_OCS_LOCKED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ACT_DEFAULT_TRADE", VALUEFUNC(_wrap_MatchType_ACT_DEFAULT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_PLUS4_BADGES_EXEC_TIME", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_PLUS4_BADGES_EXEC_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_A1_EXACT_MATCH_SUMMARIZED_QUANTITY", VALUEFUNC(_wrap_MatchType_A1_EXACT_MATCH_SUMMARIZED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_EXACT_MATCH_PLUS_EXEC_TIME", VALUEFUNC(_wrap_MatchType_EXACT_MATCH_PLUS_EXEC_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ONE_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT", VALUEFUNC(_wrap_MatchType_ONE_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_TWO_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT", VALUEFUNC(_wrap_MatchType_TWO_PARTY_PRIVATELY_NEGOTIATED_TRADE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_CONTINUOUS_AUTO_MATCH", VALUEFUNC(_wrap_MatchType_CONTINUOUS_AUTO_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_CROSS_AUCTION", VALUEFUNC(_wrap_MatchType_CROSS_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_COUNTER_ORDER_SELECTION", VALUEFUNC(_wrap_MatchType_COUNTER_ORDER_SELECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_CALL_AUCTION", VALUEFUNC(_wrap_MatchType_CALL_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ONE_PARTY_TRADE_REPORT", VALUEFUNC(_wrap_MatchType_ONE_PARTY_TRADE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_TWO_PARTY_TRADE_REPORT", VALUEFUNC(_wrap_MatchType_TWO_PARTY_TRADE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_CONFIRMED_TRADE_REPORT", VALUEFUNC(_wrap_MatchType_CONFIRMED_TRADE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_AUTO_MATCH", VALUEFUNC(_wrap_MatchType_AUTO_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_ISSUING", VALUEFUNC(_wrap_MatchType_ISSUING_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_SYSTEMATIC_INTERNALISER", VALUEFUNC(_wrap_MatchType_SYSTEMATIC_INTERNALISER_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_AUTO_MATCH_LAST_LOOK", VALUEFUNC(_wrap_MatchType_AUTO_MATCH_LAST_LOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchType_CROSS_AUCTION_LAST_LOOK", VALUEFUNC(_wrap_MatchType_CROSS_AUCTION_LAST_LOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "OddLot_YES", VALUEFUNC(_wrap_OddLot_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "OddLot_NO", VALUEFUNC(_wrap_OddLot_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_MANUAL_MODE", VALUEFUNC(_wrap_ClearingInstruction_MANUAL_MODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_MULTILATERAL_NETTING", VALUEFUNC(_wrap_ClearingInstruction_MULTILATERAL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_AUTOMATIC_POSTING_MODE", VALUEFUNC(_wrap_ClearingInstruction_AUTOMATIC_POSTING_MODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_BILATERAL_NETTING_ONLY", VALUEFUNC(_wrap_ClearingInstruction_BILATERAL_NETTING_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY", VALUEFUNC(_wrap_ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_AUTOMATIC_GIVE_UP_MODE", VALUEFUNC(_wrap_ClearingInstruction_AUTOMATIC_GIVE_UP_MODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_SPECIAL_TRADE", VALUEFUNC(_wrap_ClearingInstruction_SPECIAL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EX_CLEARING", VALUEFUNC(_wrap_ClearingInstruction_EX_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_PROCESS_NORMALLY", VALUEFUNC(_wrap_ClearingInstruction_PROCESS_NORMALLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY", VALUEFUNC(_wrap_ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EXCLUDE_FROM_ALL_NETTING", VALUEFUNC(_wrap_ClearingInstruction_EXCLUDE_FROM_ALL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_QUALIFIED_SERVICE_REPRESENTATIVE_QSR", VALUEFUNC(_wrap_ClearingInstruction_QUALIFIED_SERVICE_REPRESENTATIVE_QSR_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_CUSTOMER_TRADE", VALUEFUNC(_wrap_ClearingInstruction_CUSTOMER_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_SELF_CLEARING", VALUEFUNC(_wrap_ClearingInstruction_SELF_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_BUY_IN", VALUEFUNC(_wrap_ClearingInstruction_BUY_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_HOUSE_TRADER", VALUEFUNC(_wrap_AccountType_HOUSE_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_HOUSE_TRADER_CROSS_MARGINED", VALUEFUNC(_wrap_AccountType_HOUSE_TRADER_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED", VALUEFUNC(_wrap_AccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_FLOOR_TRADER", VALUEFUNC(_wrap_AccountType_FLOOR_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_CARRIED_NON_CUSTOMER_SIDE", VALUEFUNC(_wrap_AccountType_CARRIED_NON_CUSTOMER_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_CARRIED_CUSTOMER_SIDE", VALUEFUNC(_wrap_AccountType_CARRIED_CUSTOMER_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_JOINT_BACK_OFFICE_ACCOUNT", VALUEFUNC(_wrap_AccountType_JOINT_BACK_OFFICE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_EQUITIES_SPECIALIST", VALUEFUNC(_wrap_AccountType_EQUITIES_SPECIALIST_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_OPTIONS_MARKET_MAKER", VALUEFUNC(_wrap_AccountType_OPTIONS_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_OPTIONS_FIRM_ACCOUNT", VALUEFUNC(_wrap_AccountType_OPTIONS_FIRM_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_CUSTOMER_NON_CUSTOMER_ORDERS", VALUEFUNC(_wrap_AccountType_ACCOUNT_CUSTOMER_NON_CUSTOMER_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_ORDERS_MULTIPLE_CUSTOMERS", VALUEFUNC(_wrap_AccountType_ACCOUNT_ORDERS_MULTIPLE_CUSTOMERS_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT", VALUEFUNC(_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT", VALUEFUNC(_wrap_CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER", VALUEFUNC(_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_ALL_OTHER", VALUEFUNC(_wrap_CustOrderCapacity_ALL_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_RETAIL_CUSTOMER", VALUEFUNC(_wrap_CustOrderCapacity_RETAIL_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_ACFI_CODE", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_ACFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_TYPE", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTY_ID", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTY_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ALL_ORDERS", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_SECURITY_ISSUER", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_AUTO", VALUEFUNC(_wrap_DayBookingInst_AUTO_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING", VALUEFUNC(_wrap_DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_ACCUMULATE", VALUEFUNC(_wrap_DayBookingInst_ACCUMULATE_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER", VALUEFUNC(_wrap_BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL", VALUEFUNC(_wrap_BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT", VALUEFUNC(_wrap_BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PreallocMethod_PRO_RATA", VALUEFUNC(_wrap_PreallocMethod_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "PreallocMethod_DO_NOT_PRO_RATA", VALUEFUNC(_wrap_PreallocMethod_DO_NOT_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_PRE_TRADING", VALUEFUNC(_wrap_TradingSessionSubID_PRE_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_OPENING_OR_OPENING_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_OPENING_OR_OPENING_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_CONTINUOUS", VALUEFUNC(_wrap_TradingSessionSubID_CONTINUOUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_CLOSING_OR_CLOSING_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_CLOSING_OR_CLOSING_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_POST_TRADING", VALUEFUNC(_wrap_TradingSessionSubID_POST_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_INTRADAY_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_INTRADAY_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_QUIESCENT", VALUEFUNC(_wrap_TradingSessionSubID_QUIESCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_SCHEDULED_INTRADAY_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_SCHEDULED_INTRADAY_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_ANY_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_ANY_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_UNSCHEDULED_INTRADAY_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_UNSCHEDULED_INTRADAY_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_OUT_OF_MAIN_SESSION_TRADING", VALUEFUNC(_wrap_TradingSessionSubID_OUT_OF_MAIN_SESSION_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_PRIVATE_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_PRIVATE_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_PUBLIC_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_PUBLIC_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingSessionSubID_GROUP_AUCTION", VALUEFUNC(_wrap_TradingSessionSubID_GROUP_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_BUYSIDE_READY_TO_BOOK", VALUEFUNC(_wrap_AllocType_BUYSIDE_READY_TO_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_PRELIMINARY", VALUEFUNC(_wrap_AllocType_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_SELLSIDE_CALCULATED_USING_PRELIMINARY", VALUEFUNC(_wrap_AllocType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_READY_TO_BOOK", VALUEFUNC(_wrap_AllocType_READY_TO_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_CALCULATED", VALUEFUNC(_wrap_AllocType_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY", VALUEFUNC(_wrap_AllocType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_WAREHOUSE_INSTRUCTION", VALUEFUNC(_wrap_AllocType_WAREHOUSE_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REQUEST_TO_INTERMEDIARY", VALUEFUNC(_wrap_AllocType_REQUEST_TO_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_ACCEPT", VALUEFUNC(_wrap_AllocType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REJECT", VALUEFUNC(_wrap_AllocType_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_ACCEPT_PENDING", VALUEFUNC(_wrap_AllocType_ACCEPT_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_INCOMPLETE_GROUP", VALUEFUNC(_wrap_AllocType_INCOMPLETE_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_COMPLETE_GROUP", VALUEFUNC(_wrap_AllocType_COMPLETE_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REVERSAL_PENDING", VALUEFUNC(_wrap_AllocType_REVERSAL_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REOPEN_GROUP", VALUEFUNC(_wrap_AllocType_REOPEN_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_CANCEL_GROUP", VALUEFUNC(_wrap_AllocType_CANCEL_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_GIVEUP", VALUEFUNC(_wrap_AllocType_GIVEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_TAKEUP", VALUEFUNC(_wrap_AllocType_TAKEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REFUSE_TAKEUP", VALUEFUNC(_wrap_AllocType_REFUSE_TAKEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_INITIATE_REVERSAL", VALUEFUNC(_wrap_AllocType_INITIATE_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REVERSE", VALUEFUNC(_wrap_AllocType_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REFUSE_REVERSAL", VALUEFUNC(_wrap_AllocType_REFUSE_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_SUB_ALLOCATION_GIVEUP", VALUEFUNC(_wrap_AllocType_SUB_ALLOCATION_GIVEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_APPROVE_GIVEUP", VALUEFUNC(_wrap_AllocType_APPROVE_GIVEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_APPROVE_TAKEUP", VALUEFUNC(_wrap_AllocType_APPROVE_TAKEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_NOTIONAL_VALUE_AVERAGE_PX_GROUP_ALLOC", VALUEFUNC(_wrap_AllocType_NOTIONAL_VALUE_AVERAGE_PX_GROUP_ALLOC_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FIRMS106_H_AND106_J", VALUEFUNC(_wrap_ClearingFeeIndicator_FIRMS106_H_AND106_J_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FIFTH_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_FIFTH_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FOURTH_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_FOURTH_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_THIRD_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_THIRD_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_SECOND_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_SECOND_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FIRST_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_FIRST_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES", VALUEFUNC(_wrap_ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_GIM", VALUEFUNC(_wrap_ClearingFeeIndicator_GIM_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_SIXTH_YEAR_DELEGATE", VALUEFUNC(_wrap_ClearingFeeIndicator_SIXTH_YEAR_DELEGATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER", VALUEFUNC(_wrap_ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER", VALUEFUNC(_wrap_ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER", VALUEFUNC(_wrap_ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_CBOE_MEMBER", VALUEFUNC(_wrap_ClearingFeeIndicator_CBOE_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_LESSEE106_F_EMPLOYEES", VALUEFUNC(_wrap_ClearingFeeIndicator_LESSEE106_F_EMPLOYEES_get), 0);
  rb_define_singleton_method(mQuickfix, "WorkingIndicator_NO", VALUEFUNC(_wrap_WorkingIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "WorkingIndicator_YES", VALUEFUNC(_wrap_WorkingIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "PriorityIndicator_PRIORITY_UNCHANGED", VALUEFUNC(_wrap_PriorityIndicator_PRIORITY_UNCHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE", VALUEFUNC(_wrap_PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LegalConfirm_YES", VALUEFUNC(_wrap_LegalConfirm_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "LegalConfirm_NO", VALUEFUNC(_wrap_LegalConfirm_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteRequestRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCHANGE", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteRequestRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteRequestRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE", VALUEFUNC(_wrap_QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_INVENTORY", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_INVENTORY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_PASS", VALUEFUNC(_wrap_QuoteRequestRejectReason_PASS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_OTHER", VALUEFUNC(_wrap_QuoteRequestRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_INSUFFICIENT_CREDIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_INSUFFICIENT_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCEEDED_CLIP_SIZE_LIMIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCEEDED_CLIP_SIZE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCEEDED_MAX_NOTIONAL_ORDER_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCEEDED_DV01_PV01_LIMIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCEEDED_DV01_PV01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCEEDED_CS01_LIMIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCEEDED_CS01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_REGULAR", VALUEFUNC(_wrap_SettlType_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_CASH", VALUEFUNC(_wrap_SettlType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_NEXT_DAY", VALUEFUNC(_wrap_SettlType_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS2", VALUEFUNC(_wrap_SettlType_T_PLUS2_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS3", VALUEFUNC(_wrap_SettlType_T_PLUS3_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS4", VALUEFUNC(_wrap_SettlType_T_PLUS4_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_FUTURE", VALUEFUNC(_wrap_SettlType_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_WHEN_AND_IF_ISSUED", VALUEFUNC(_wrap_SettlType_WHEN_AND_IF_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_SELLERS_OPTION", VALUEFUNC(_wrap_SettlType_SELLERS_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS5", VALUEFUNC(_wrap_SettlType_T_PLUS5_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_BROKEN_DATE", VALUEFUNC(_wrap_SettlType_BROKEN_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_FX_SPOT_NEXT_SETTLEMENT", VALUEFUNC(_wrap_SettlType_FX_SPOT_NEXT_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_DAILY_OPEN", VALUEFUNC(_wrap_OpenCloseSettlFlag_DAILY_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_SESSION_OPEN", VALUEFUNC(_wrap_OpenCloseSettlFlag_SESSION_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_EXPECTED_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_EXPECTED_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY", VALUEFUNC(_wrap_OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE", VALUEFUNC(_wrap_OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_RISK_TRADE", VALUEFUNC(_wrap_BidTradeType_RISK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_VWAP_GUARANTEE", VALUEFUNC(_wrap_BidTradeType_VWAP_GUARANTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_AGENCY", VALUEFUNC(_wrap_BidTradeType_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_GUARANTEED_CLOSE", VALUEFUNC(_wrap_BidTradeType_GUARANTEED_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_BIC", VALUEFUNC(_wrap_AcctIDSource_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_SID_CODE", VALUEFUNC(_wrap_AcctIDSource_SID_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_TFM", VALUEFUNC(_wrap_AcctIDSource_TFM_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_OMGEO", VALUEFUNC(_wrap_AcctIDSource_OMGEO_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_DTCC_CODE", VALUEFUNC(_wrap_AcctIDSource_DTCC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_OTHER", VALUEFUNC(_wrap_AcctIDSource_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_SPSAID", VALUEFUNC(_wrap_AcctIDSource_SPSAID_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_RECEIVED", VALUEFUNC(_wrap_ConfirmStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_MISMATCHED_ACCOUNT", VALUEFUNC(_wrap_ConfirmStatus_MISMATCHED_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_CONFIRMED", VALUEFUNC(_wrap_ConfirmStatus_CONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_REQUEST_REJECTED", VALUEFUNC(_wrap_ConfirmStatus_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_NEW", VALUEFUNC(_wrap_ConfirmTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_REPLACE", VALUEFUNC(_wrap_ConfirmTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_CANCEL", VALUEFUNC(_wrap_ConfirmTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryForm_BOOK_ENTRY", VALUEFUNC(_wrap_DeliveryForm_BOOK_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryForm_BEARER", VALUEFUNC(_wrap_DeliveryForm_BEARER_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_PAR_FOR_PAR", VALUEFUNC(_wrap_LegSwapType_PAR_FOR_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_MODIFIED_DURATION", VALUEFUNC(_wrap_LegSwapType_MODIFIED_DURATION_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_RISK", VALUEFUNC(_wrap_LegSwapType_RISK_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_PROCEEDS", VALUEFUNC(_wrap_LegSwapType_PROCEEDS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PERCENT", VALUEFUNC(_wrap_QuotePriceType_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PER_SHARE", VALUEFUNC(_wrap_QuotePriceType_PER_SHARE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_FIXED_AMOUNT", VALUEFUNC(_wrap_QuotePriceType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_DISCOUNT", VALUEFUNC(_wrap_QuotePriceType_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PREMIUM", VALUEFUNC(_wrap_QuotePriceType_PREMIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_SPREAD", VALUEFUNC(_wrap_QuotePriceType_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_TED_PRICE", VALUEFUNC(_wrap_QuotePriceType_TED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_TED_YIELD", VALUEFUNC(_wrap_QuotePriceType_TED_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_YIELD_SPREAD", VALUEFUNC(_wrap_QuotePriceType_YIELD_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_YIELD", VALUEFUNC(_wrap_QuotePriceType_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRICE_SPREAD", VALUEFUNC(_wrap_QuotePriceType_PRICE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_HALVES", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_HALVES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_FOURTHS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_FOURTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_EIGHTHS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_EIGHTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_SIXTEENTHS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_SIXTEENTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_THIRTY_SECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_SIXTY_FOURTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS", VALUEFUNC(_wrap_QuotePriceType_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_NORMAL_RATE_REPRESENTATION", VALUEFUNC(_wrap_QuotePriceType_NORMAL_RATE_REPRESENTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_INVERSE_RATE_REPRESENTATION", VALUEFUNC(_wrap_QuotePriceType_INVERSE_RATE_REPRESENTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_BASIS_POINTS", VALUEFUNC(_wrap_QuotePriceType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_UP_FRONT_POINTS", VALUEFUNC(_wrap_QuotePriceType_UP_FRONT_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_INTEREST_RATE", VALUEFUNC(_wrap_QuotePriceType_INTEREST_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PERCENTAGE_OF_NOTIONAL", VALUEFUNC(_wrap_QuotePriceType_PERCENTAGE_OF_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_HIT", VALUEFUNC(_wrap_QuoteRespType_HIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_COUNTER", VALUEFUNC(_wrap_QuoteRespType_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_EXPIRED", VALUEFUNC(_wrap_QuoteRespType_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_COVER", VALUEFUNC(_wrap_QuoteRespType_COVER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_DONE_AWAY", VALUEFUNC(_wrap_QuoteRespType_DONE_AWAY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_PASS", VALUEFUNC(_wrap_QuoteRespType_PASS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_END_TRADE", VALUEFUNC(_wrap_QuoteRespType_END_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_TIMED_OUT", VALUEFUNC(_wrap_QuoteRespType_TIMED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_TIED", VALUEFUNC(_wrap_QuoteRespType_TIED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_TIED_COVER", VALUEFUNC(_wrap_QuoteRespType_TIED_COVER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_ACCEPT", VALUEFUNC(_wrap_QuoteRespType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_TERMINATE_CONTRACT", VALUEFUNC(_wrap_QuoteRespType_TERMINATE_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_QUANTITY", VALUEFUNC(_wrap_PosType_TRANSACTION_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTRA_SPREAD_QTY", VALUEFUNC(_wrap_PosType_INTRA_SPREAD_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTER_SPREAD_QTY", VALUEFUNC(_wrap_PosType_INTER_SPREAD_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_END_OF_DAY_QTY", VALUEFUNC(_wrap_PosType_END_OF_DAY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_START_OF_DAY_QTY", VALUEFUNC(_wrap_PosType_START_OF_DAY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_OPTION_EXERCISE_QTY", VALUEFUNC(_wrap_PosType_OPTION_EXERCISE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_OPTION_ASSIGNMENT", VALUEFUNC(_wrap_PosType_OPTION_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_FROM_EXERCISE", VALUEFUNC(_wrap_PosType_TRANSACTION_FROM_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_FROM_ASSIGNMENT", VALUEFUNC(_wrap_PosType_TRANSACTION_FROM_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_PIT_TRADE_QTY", VALUEFUNC(_wrap_PosType_PIT_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSFER_TRADE_QTY", VALUEFUNC(_wrap_PosType_TRANSFER_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ELECTRONIC_TRADE_QTY", VALUEFUNC(_wrap_PosType_ELECTRONIC_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ALLOCATION_TRADE_QTY", VALUEFUNC(_wrap_PosType_ALLOCATION_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ADJUSTMENT_QTY", VALUEFUNC(_wrap_PosType_ADJUSTMENT_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_AS_OF_TRADE_QTY", VALUEFUNC(_wrap_PosType_AS_OF_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_DELIVERY_QTY", VALUEFUNC(_wrap_PosType_DELIVERY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TOTAL_TRANSACTION_QTY", VALUEFUNC(_wrap_PosType_TOTAL_TRANSACTION_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_CROSS_MARGIN_QTY", VALUEFUNC(_wrap_PosType_CROSS_MARGIN_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTEGRAL_SPLIT", VALUEFUNC(_wrap_PosType_INTEGRAL_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_RECEIVE_QUANTITY", VALUEFUNC(_wrap_PosType_RECEIVE_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_CORPORATE_ACTION_ADJUSTMENT", VALUEFUNC(_wrap_PosType_CORPORATE_ACTION_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_DELIVERY_NOTICE_QTY", VALUEFUNC(_wrap_PosType_DELIVERY_NOTICE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_EXCHANGE_FOR_PHYSICAL_QTY", VALUEFUNC(_wrap_PosType_EXCHANGE_FOR_PHYSICAL_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_PRIVATELY_NEGOTIATED_TRADE_QTY", VALUEFUNC(_wrap_PosType_PRIVATELY_NEGOTIATED_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_NET_DELTA_QTY", VALUEFUNC(_wrap_PosType_NET_DELTA_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_CREDIT_EVENT_ADJUSTMENT", VALUEFUNC(_wrap_PosType_CREDIT_EVENT_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_SUCCESSION_EVENT_ADJUSTMENT", VALUEFUNC(_wrap_PosType_SUCCESSION_EVENT_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_NET_QTY", VALUEFUNC(_wrap_PosType_NET_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_GROSS_QTY", VALUEFUNC(_wrap_PosType_GROSS_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTRADAY_QTY", VALUEFUNC(_wrap_PosType_INTRADAY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_GROSS_LONG_NON_DELTA_ADJUSTED_SWAPTION_POSITION", VALUEFUNC(_wrap_PosType_GROSS_LONG_NON_DELTA_ADJUSTED_SWAPTION_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_LONG_DELTA_ADJUSTED_PAIRED_SWAPTION_POSITION", VALUEFUNC(_wrap_PosType_LONG_DELTA_ADJUSTED_PAIRED_SWAPTION_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_EXPIRING_QUANTITY", VALUEFUNC(_wrap_PosType_EXPIRING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_QUANTITY_NOT_EXERCISED", VALUEFUNC(_wrap_PosType_QUANTITY_NOT_EXERCISED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_REQUESTED_EXERCISE_QUANTITY", VALUEFUNC(_wrap_PosType_REQUESTED_EXERCISE_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_CASH_FUTURES_EQUIVALENT_QUANTITY", VALUEFUNC(_wrap_PosType_CASH_FUTURES_EQUIVALENT_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_LOAN_OR_BORROWED_QUANTITY", VALUEFUNC(_wrap_PosType_LOAN_OR_BORROWED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_SUBMITTED", VALUEFUNC(_wrap_PosQtyStatus_SUBMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_ACCEPTED", VALUEFUNC(_wrap_PosQtyStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_REJECTED", VALUEFUNC(_wrap_PosQtyStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_TRADE_VARIATION_AMOUNT", VALUEFUNC(_wrap_PosAmtType_TRADE_VARIATION_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_PREMIUM_AMOUNT", VALUEFUNC(_wrap_PosAmtType_PREMIUM_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_CASH_RESIDUAL_AMOUNT", VALUEFUNC(_wrap_PosAmtType_CASH_RESIDUAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_CASH_AMOUNT", VALUEFUNC(_wrap_PosAmtType_CASH_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_VALUE_ADJUSTED_AMOUNT", VALUEFUNC(_wrap_PosAmtType_VALUE_ADJUSTED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_SETTLEMENT_VALUE", VALUEFUNC(_wrap_PosAmtType_SETTLEMENT_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_INITIAL_TRADE_COUPON_AMOUNT", VALUEFUNC(_wrap_PosAmtType_INITIAL_TRADE_COUPON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_ACCRUED_COUPON_AMOUNT", VALUEFUNC(_wrap_PosAmtType_ACCRUED_COUPON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_COUPON_AMOUNT", VALUEFUNC(_wrap_PosAmtType_COUPON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_INCREMENTAL_ACCRUED_COUPON", VALUEFUNC(_wrap_PosAmtType_INCREMENTAL_ACCRUED_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_COLLATERALIZED_MARK_TO_MARKET", VALUEFUNC(_wrap_PosAmtType_COLLATERALIZED_MARK_TO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_INCREMENTAL_COLLATERALIZED_MARK_TO_MARKET", VALUEFUNC(_wrap_PosAmtType_INCREMENTAL_COLLATERALIZED_MARK_TO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_COMPENSATION_AMOUNT", VALUEFUNC(_wrap_PosAmtType_COMPENSATION_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_TOTAL_BANKED_AMOUNT", VALUEFUNC(_wrap_PosAmtType_TOTAL_BANKED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_TOTAL_COLLATERALIZED_AMOUNT", VALUEFUNC(_wrap_PosAmtType_TOTAL_COLLATERALIZED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_LONG_PAIRED_SWAP_NOTIONAL_VALUE", VALUEFUNC(_wrap_PosAmtType_LONG_PAIRED_SWAP_NOTIONAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_SHORT_PAIRED_SWAP_NOTIONAL_VALUE", VALUEFUNC(_wrap_PosAmtType_SHORT_PAIRED_SWAP_NOTIONAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_START_OF_DAY_ACCRUED_COUPON", VALUEFUNC(_wrap_PosAmtType_START_OF_DAY_ACCRUED_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_NET_PRESENT_VALUE", VALUEFUNC(_wrap_PosAmtType_NET_PRESENT_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_START_OF_DAY_NET_PRESENT_VALUE", VALUEFUNC(_wrap_PosAmtType_START_OF_DAY_NET_PRESENT_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_NET_CASH_FLOW", VALUEFUNC(_wrap_PosAmtType_NET_CASH_FLOW_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_PRESENT_VALUE_OF_FEES", VALUEFUNC(_wrap_PosAmtType_PRESENT_VALUE_OF_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_PRESENT_VALUE_ONE_BASIS_POINTS", VALUEFUNC(_wrap_PosAmtType_PRESENT_VALUE_ONE_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_FIVE_YEAR_EQUIVALENT_NOTIONAL", VALUEFUNC(_wrap_PosAmtType_FIVE_YEAR_EQUIVALENT_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_UNDISCOUNTED_MARK_TO_MARKET", VALUEFUNC(_wrap_PosAmtType_UNDISCOUNTED_MARK_TO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_MARK_TO_MODEL", VALUEFUNC(_wrap_PosAmtType_MARK_TO_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_MARK_TO_MARKET_VARIANCE", VALUEFUNC(_wrap_PosAmtType_MARK_TO_MARKET_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_MARK_TO_MODEL_VARIANCE", VALUEFUNC(_wrap_PosAmtType_MARK_TO_MODEL_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_UPFRONT_PAYMENT", VALUEFUNC(_wrap_PosAmtType_UPFRONT_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_END_VALE", VALUEFUNC(_wrap_PosAmtType_END_VALE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_OUTSTANDING_MARGIN_LOAN", VALUEFUNC(_wrap_PosAmtType_OUTSTANDING_MARGIN_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_LOAN_VALUE", VALUEFUNC(_wrap_PosAmtType_LOAN_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_EXERCISE", VALUEFUNC(_wrap_PosTransType_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_DO_NOT_EXERCISE", VALUEFUNC(_wrap_PosTransType_DO_NOT_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_POSITION_ADJUSTMENT", VALUEFUNC(_wrap_PosTransType_POSITION_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_POSITION_CHANGE_SUBMISSION", VALUEFUNC(_wrap_PosTransType_POSITION_CHANGE_SUBMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_PLEDGE", VALUEFUNC(_wrap_PosTransType_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_LARGE_TRADER_SUBMISSION", VALUEFUNC(_wrap_PosTransType_LARGE_TRADER_SUBMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_LARGE_POSITIONS_REPORTING_SUBMISSION", VALUEFUNC(_wrap_PosTransType_LARGE_POSITIONS_REPORTING_SUBMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_LONG_HOLDINGS", VALUEFUNC(_wrap_PosTransType_LONG_HOLDINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_INTERNAL_TRANSFER", VALUEFUNC(_wrap_PosTransType_INTERNAL_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_TRANSFER_OF_FIRM", VALUEFUNC(_wrap_PosTransType_TRANSFER_OF_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_EXTERNAL_TRANSFER", VALUEFUNC(_wrap_PosTransType_EXTERNAL_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_CORPORATE_ACTION", VALUEFUNC(_wrap_PosTransType_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_NOTIFICATION", VALUEFUNC(_wrap_PosTransType_NOTIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_POSITION_CREATION", VALUEFUNC(_wrap_PosTransType_POSITION_CREATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_CLOSEOUT", VALUEFUNC(_wrap_PosTransType_CLOSEOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_REOPEN", VALUEFUNC(_wrap_PosTransType_REOPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_NEW", VALUEFUNC(_wrap_PosMaintAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_REPLACE", VALUEFUNC(_wrap_PosMaintAction_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_CANCEL", VALUEFUNC(_wrap_PosMaintAction_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_REVERSE", VALUEFUNC(_wrap_PosMaintAction_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSessID_INTRADAY", VALUEFUNC(_wrap_SettlSessID_INTRADAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSessID_REGULAR_TRADING_HOURS", VALUEFUNC(_wrap_SettlSessID_REGULAR_TRADING_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSessID_ELECTRONIC_TRADING_HOURS", VALUEFUNC(_wrap_SettlSessID_ELECTRONIC_TRADING_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSessID_END_OF_DAY", VALUEFUNC(_wrap_SettlSessID_END_OF_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION", VALUEFUNC(_wrap_AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_DELTA_PLUS", VALUEFUNC(_wrap_AdjustmentType_DELTA_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_DELTA_MINUS", VALUEFUNC(_wrap_AdjustmentType_DELTA_MINUS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_FINAL", VALUEFUNC(_wrap_AdjustmentType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_CUSTOMER_SPECIFIC_POSITION", VALUEFUNC(_wrap_AdjustmentType_CUSTOMER_SPECIFIC_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_ACCEPTED", VALUEFUNC(_wrap_PosMaintStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_ACCEPTED_WITH_WARNINGS", VALUEFUNC(_wrap_PosMaintStatus_ACCEPTED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_REJECTED", VALUEFUNC(_wrap_PosMaintStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_COMPLETED", VALUEFUNC(_wrap_PosMaintStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_PosMaintStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintResult_SUCCESSFUL_COMPLETION", VALUEFUNC(_wrap_PosMaintResult_SUCCESSFUL_COMPLETION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintResult_REJECTED", VALUEFUNC(_wrap_PosMaintResult_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintResult_OTHER", VALUEFUNC(_wrap_PosMaintResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_POSITIONS", VALUEFUNC(_wrap_PosReqType_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_TRADES", VALUEFUNC(_wrap_PosReqType_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_EXERCISES", VALUEFUNC(_wrap_PosReqType_EXERCISES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_ASSIGNMENTS", VALUEFUNC(_wrap_PosReqType_ASSIGNMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_SETTLEMENT_ACTIVITY", VALUEFUNC(_wrap_PosReqType_SETTLEMENT_ACTIVITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_BACKOUT_MESSAGE", VALUEFUNC(_wrap_PosReqType_BACKOUT_MESSAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_DELTA_POSITIONS", VALUEFUNC(_wrap_PosReqType_DELTA_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_NET_POSITION", VALUEFUNC(_wrap_PosReqType_NET_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_LARGE_POSITIONS_REPORTING", VALUEFUNC(_wrap_PosReqType_LARGE_POSITIONS_REPORTING_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_EXERCISE_POSITION_REPORTING_SUBMISSION", VALUEFUNC(_wrap_PosReqType_EXERCISE_POSITION_REPORTING_SUBMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_POSITION_LIMIT_REPORTING_SUBMISSING", VALUEFUNC(_wrap_PosReqType_POSITION_LIMIT_REPORTING_SUBMISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "ResponseTransportType_INBAND", VALUEFUNC(_wrap_ResponseTransportType_INBAND_get), 0);
  rb_define_singleton_method(mQuickfix, "ResponseTransportType_OUT_OF_BAND", VALUEFUNC(_wrap_ResponseTransportType_OUT_OF_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_VALID_REQUEST", VALUEFUNC(_wrap_PosReqResult_VALID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST", VALUEFUNC(_wrap_PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS", VALUEFUNC(_wrap_PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED", VALUEFUNC(_wrap_PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_OTHER", VALUEFUNC(_wrap_PosReqResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_COMPLETED", VALUEFUNC(_wrap_PosReqStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_PosReqStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_REJECTED", VALUEFUNC(_wrap_PosReqStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlPriceType_FINAL", VALUEFUNC(_wrap_SettlPriceType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlPriceType_THEORETICAL", VALUEFUNC(_wrap_SettlPriceType_THEORETICAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AssignmentMethod_RANDOM", VALUEFUNC(_wrap_AssignmentMethod_RANDOM_get), 0);
  rb_define_singleton_method(mQuickfix, "AssignmentMethod_PRO_RATA", VALUEFUNC(_wrap_AssignmentMethod_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseMethod_AUTOMATIC", VALUEFUNC(_wrap_ExerciseMethod_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseMethod_MANUAL", VALUEFUNC(_wrap_ExerciseMethod_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_TradeRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_PARTIES", VALUEFUNC(_wrap_TradeRequestResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_DESTINATION_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_DESTINATION_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_TRADE_REQUEST_TYPE_NOT_SUPPORTED", VALUEFUNC(_wrap_TradeRequestResult_TRADE_REQUEST_TYPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_NOT_AUTHORIZED", VALUEFUNC(_wrap_TradeRequestResult_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_OTHER", VALUEFUNC(_wrap_TradeRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_ACCEPTED", VALUEFUNC(_wrap_TradeRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_COMPLETED", VALUEFUNC(_wrap_TradeRequestStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_REJECTED", VALUEFUNC(_wrap_TradeRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_SUCCESSFUL", VALUEFUNC(_wrap_TradeReportRejectReason_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_INVALID_PARTY_ONFORMATION", VALUEFUNC(_wrap_TradeReportRejectReason_INVALID_PARTY_ONFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TradeReportRejectReason_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES", VALUEFUNC(_wrap_TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_INVALID_TRADE_TYPE", VALUEFUNC(_wrap_TradeReportRejectReason_INVALID_TRADE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_OTHER", VALUEFUNC(_wrap_TradeReportRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_INVALID_PARTY_INFORMATION", VALUEFUNC(_wrap_TradeReportRejectReason_INVALID_PARTY_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND", VALUEFUNC(_wrap_TradeReportRejectReason_PRICE_EXCEEDS_CURRENT_PRICE_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_REFERENCE_PRICE_NOT_AVAILABLE", VALUEFUNC(_wrap_TradeReportRejectReason_REFERENCE_PRICE_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD", VALUEFUNC(_wrap_TradeReportRejectReason_NOTIONAL_VALUE_EXCEEDS_THRESHOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_SINGLE_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_SINGLE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTILEG_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTILEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_MULTILEG_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_MULTILEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_EXECUTION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_EXECUTION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TIME_IN", VALUEFUNC(_wrap_TrdRegTimestampType_TIME_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TIME_OUT", VALUEFUNC(_wrap_TrdRegTimestampType_TIME_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_BROKER_RECEIPT", VALUEFUNC(_wrap_TrdRegTimestampType_BROKER_RECEIPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_BROKER_EXECUTION", VALUEFUNC(_wrap_TrdRegTimestampType_BROKER_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_DESK_RECEIPT", VALUEFUNC(_wrap_TrdRegTimestampType_DESK_RECEIPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_SUBMISSION_TO_CLEARING", VALUEFUNC(_wrap_TrdRegTimestampType_SUBMISSION_TO_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TIME_PRIORITY", VALUEFUNC(_wrap_TrdRegTimestampType_TIME_PRIORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ORDERBOOK_ENTRY_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_ORDERBOOK_ENTRY_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ORDER_SUBMISSION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_ORDER_SUBMISSION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_PUBLICLY_REPORTED", VALUEFUNC(_wrap_TrdRegTimestampType_PUBLICLY_REPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_PUBLIC_REPORT_UPDATED", VALUEFUNC(_wrap_TrdRegTimestampType_PUBLIC_REPORT_UPDATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_NON_PUBLICLY_REPORTED", VALUEFUNC(_wrap_TrdRegTimestampType_NON_PUBLICLY_REPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_NON_PUBLIC_REPORT_UPDATED", VALUEFUNC(_wrap_TrdRegTimestampType_NON_PUBLIC_REPORT_UPDATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_SUBMITTED_FOR_CONFIRMATION", VALUEFUNC(_wrap_TrdRegTimestampType_SUBMITTED_FOR_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_UPDATED_FOR_CONFIRMATION", VALUEFUNC(_wrap_TrdRegTimestampType_UPDATED_FOR_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_CONFIRMED", VALUEFUNC(_wrap_TrdRegTimestampType_CONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_UPDATED_FOR_CLEARING", VALUEFUNC(_wrap_TrdRegTimestampType_UPDATED_FOR_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_CLEARED", VALUEFUNC(_wrap_TrdRegTimestampType_CLEARED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ALLOCATIONS_SUBMITTED", VALUEFUNC(_wrap_TrdRegTimestampType_ALLOCATIONS_SUBMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ALLOCATIONS_UPDATED", VALUEFUNC(_wrap_TrdRegTimestampType_ALLOCATIONS_UPDATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ALLOCATIONS_COMPLETED", VALUEFUNC(_wrap_TrdRegTimestampType_ALLOCATIONS_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_SUBMITTED_TO_REPOSITORY", VALUEFUNC(_wrap_TrdRegTimestampType_SUBMITTED_TO_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_POST_TRD_CONTNTN_EVNT", VALUEFUNC(_wrap_TrdRegTimestampType_POST_TRD_CONTNTN_EVNT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_POST_TRADE_VALUATION", VALUEFUNC(_wrap_TrdRegTimestampType_POST_TRADE_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_PREVIOUS_TIME_PRIORITY", VALUEFUNC(_wrap_TrdRegTimestampType_PREVIOUS_TIME_PRIORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_IDENTIFIER_ASSIGNED", VALUEFUNC(_wrap_TrdRegTimestampType_IDENTIFIER_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_PREVIOUS_IDENTIFIER_ASSIGNED", VALUEFUNC(_wrap_TrdRegTimestampType_PREVIOUS_IDENTIFIER_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ORDER_CANCELLATION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_ORDER_CANCELLATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ORDER_MODIFICATION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_ORDER_MODIFICATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_ORDER_ROUTING_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_ORDER_ROUTING_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TRADE_CANCELLATION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_TRADE_CANCELLATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TRADE_MODIFICATION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_TRADE_MODIFICATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_REFERENCE_TIME_FOR_NBBO", VALUEFUNC(_wrap_TrdRegTimestampType_REFERENCE_TIME_FOR_NBBO_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_STATUS", VALUEFUNC(_wrap_ConfirmType_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_CONFIRMATION", VALUEFUNC(_wrap_ConfirmType_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_CONFIRMATION_REQUEST_REJECTED", VALUEFUNC(_wrap_ConfirmType_CONFIRMATION_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_MISMATCHED_ACCOUNT", VALUEFUNC(_wrap_ConfirmRejReason_MISMATCHED_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_OTHER", VALUEFUNC(_wrap_ConfirmRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_UNKNOWN_OR_MISSING_INDIVIDUAL_ALLOC_ID", VALUEFUNC(_wrap_ConfirmRejReason_UNKNOWN_OR_MISSING_INDIVIDUAL_ALLOC_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_TRANSACTION_NOT_RECOGNIZED", VALUEFUNC(_wrap_ConfirmRejReason_TRANSACTION_NOT_RECOGNIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_DUPLICATE_TRANSACTION", VALUEFUNC(_wrap_ConfirmRejReason_DUPLICATE_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_INSTRUMENT", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_PRICE", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_COMMISSION", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_COMMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_DATE", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_FUND_ID_OR_FUND_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_QUANTITY", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_FEES", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_TAX", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_PARTY", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_SIDE", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_NET_MONEY", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_NET_MONEY_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_TRADE_DATE", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_SETTL_CCY_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_INCORRECT_OR_MISSING_CAPACITY", VALUEFUNC(_wrap_ConfirmRejReason_INCORRECT_OR_MISSING_CAPACITY_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_REGULAR_BOOKING", VALUEFUNC(_wrap_BookingType_REGULAR_BOOKING_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_CFD", VALUEFUNC(_wrap_BookingType_CFD_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_TOTAL_RETURN_SWAP", VALUEFUNC(_wrap_BookingType_TOTAL_RETURN_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS", VALUEFUNC(_wrap_AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_FULL_DETAILS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_FULL_DETAILS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_SSIDBI_DS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_SSIDBI_DS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_PHONE_FOR_INSTRUCTIONS", VALUEFUNC(_wrap_AllocSettlInstType_PHONE_FOR_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "DlvyInstType_SECURITIES", VALUEFUNC(_wrap_DlvyInstType_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "DlvyInstType_CASH", VALUEFUNC(_wrap_DlvyInstType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_OVERNIGHT", VALUEFUNC(_wrap_TerminationType_OVERNIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_TERM", VALUEFUNC(_wrap_TerminationType_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_FLEXIBLE", VALUEFUNC(_wrap_TerminationType_FLEXIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_OPEN", VALUEFUNC(_wrap_TerminationType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST", VALUEFUNC(_wrap_SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_SettlInstReqRejCode_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND", VALUEFUNC(_wrap_SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_OTHER", VALUEFUNC(_wrap_SettlInstReqRejCode_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY", VALUEFUNC(_wrap_AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY", VALUEFUNC(_wrap_AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_WAREHOUSE_RECAP", VALUEFUNC(_wrap_AllocReportType_WAREHOUSE_RECAP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_REQUEST_TO_INTERMEDIARY", VALUEFUNC(_wrap_AllocReportType_REQUEST_TO_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_PRELIMINARY_REQUEST_TO_INTERMEDIARY", VALUEFUNC(_wrap_AllocReportType_PRELIMINARY_REQUEST_TO_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_ACCEPT", VALUEFUNC(_wrap_AllocReportType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_REJECT", VALUEFUNC(_wrap_AllocReportType_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_ACCEPT_PENDING", VALUEFUNC(_wrap_AllocReportType_ACCEPT_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_COMPLETE", VALUEFUNC(_wrap_AllocReportType_COMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_REVERSE_PENDING", VALUEFUNC(_wrap_AllocReportType_REVERSE_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_GIVEUP", VALUEFUNC(_wrap_AllocReportType_GIVEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_TAKEUP", VALUEFUNC(_wrap_AllocReportType_TAKEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_REVERSAL", VALUEFUNC(_wrap_AllocReportType_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_ALLEGED", VALUEFUNC(_wrap_AllocReportType_ALLEGED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_SUB_ALLOCATION_GIVEUP", VALUEFUNC(_wrap_AllocReportType_SUB_ALLOCATION_GIVEUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE", VALUEFUNC(_wrap_AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS", VALUEFUNC(_wrap_AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_OTHER", VALUEFUNC(_wrap_AllocCancReplaceReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_CANCELLED_BY_GIVEUP_FIRM", VALUEFUNC(_wrap_AllocCancReplaceReason_CANCELLED_BY_GIVEUP_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_CARRIED_CUSTOMER_SIDE", VALUEFUNC(_wrap_AllocAccountType_CARRIED_CUSTOMER_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_CARRIED_NON_CUSTOMER_SIDE", VALUEFUNC(_wrap_AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_HOUSE_TRADER", VALUEFUNC(_wrap_AllocAccountType_HOUSE_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_FLOOR_TRADER", VALUEFUNC(_wrap_AllocAccountType_FLOOR_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED", VALUEFUNC(_wrap_AllocAccountType_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_HOUSE_TRADER_CROSS_MARGINED", VALUEFUNC(_wrap_AllocAccountType_HOUSE_TRADER_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_JOINT_BACK_OFFICE_ACCOUNT", VALUEFUNC(_wrap_AllocAccountType_JOINT_BACK_OFFICE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FIRM", VALUEFUNC(_wrap_PartySubIDType_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PERSON", VALUEFUNC(_wrap_PartySubIDType_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SYSTEM", VALUEFUNC(_wrap_PartySubIDType_SYSTEM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_APPLICATION", VALUEFUNC(_wrap_PartySubIDType_APPLICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FULL_LEGAL_NAME_OF_FIRM", VALUEFUNC(_wrap_PartySubIDType_FULL_LEGAL_NAME_OF_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_POSTAL_ADDRESS", VALUEFUNC(_wrap_PartySubIDType_POSTAL_ADDRESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PHONE_NUMBER", VALUEFUNC(_wrap_PartySubIDType_PHONE_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_EMAIL_ADDRESS", VALUEFUNC(_wrap_PartySubIDType_EMAIL_ADDRESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CONTACT_NAME", VALUEFUNC(_wrap_PartySubIDType_CONTACT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SECURITIES_ACCOUNT_NUMBER", VALUEFUNC(_wrap_PartySubIDType_SECURITIES_ACCOUNT_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REGISTRATION_NUMBER", VALUEFUNC(_wrap_PartySubIDType_REGISTRATION_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REGISTERED_ADDRESS_FOR_CONFIRMATION", VALUEFUNC(_wrap_PartySubIDType_REGISTERED_ADDRESS_FOR_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REGULATORY_STATUS", VALUEFUNC(_wrap_PartySubIDType_REGULATORY_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REGISTRATION_NAME", VALUEFUNC(_wrap_PartySubIDType_REGISTRATION_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CASH_ACCOUNT_NUMBER", VALUEFUNC(_wrap_PartySubIDType_CASH_ACCOUNT_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_BIC", VALUEFUNC(_wrap_PartySubIDType_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CSD_PARTICIPANT_MEMBER_CODE", VALUEFUNC(_wrap_PartySubIDType_CSD_PARTICIPANT_MEMBER_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REGISTERED_ADDRESS", VALUEFUNC(_wrap_PartySubIDType_REGISTERED_ADDRESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FUND_ACCOUNT_NAME", VALUEFUNC(_wrap_PartySubIDType_FUND_ACCOUNT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_TELEX_NUMBER", VALUEFUNC(_wrap_PartySubIDType_TELEX_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FAX_NUMBER", VALUEFUNC(_wrap_PartySubIDType_FAX_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SECURITIES_ACCOUNT_NAME", VALUEFUNC(_wrap_PartySubIDType_SECURITIES_ACCOUNT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CASH_ACCOUNT_NAME", VALUEFUNC(_wrap_PartySubIDType_CASH_ACCOUNT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DEPARTMENT", VALUEFUNC(_wrap_PartySubIDType_DEPARTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_LOCATION_DESK", VALUEFUNC(_wrap_PartySubIDType_LOCATION_DESK_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_POSITION_ACCOUNT_TYPE", VALUEFUNC(_wrap_PartySubIDType_POSITION_ACCOUNT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SECURITY_LOCATE_ID", VALUEFUNC(_wrap_PartySubIDType_SECURITY_LOCATE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_MARKET_MAKER", VALUEFUNC(_wrap_PartySubIDType_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ELIGIBLE_COUNTERPARTY", VALUEFUNC(_wrap_PartySubIDType_ELIGIBLE_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PROFESSIONAL_CLIENT", VALUEFUNC(_wrap_PartySubIDType_PROFESSIONAL_CLIENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_LOCATION", VALUEFUNC(_wrap_PartySubIDType_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_EXECUTION_VENUE", VALUEFUNC(_wrap_PartySubIDType_EXECUTION_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CURRENCY_DELIVERY_IDENTIFIER", VALUEFUNC(_wrap_PartySubIDType_CURRENCY_DELIVERY_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ADDRESS_CITY", VALUEFUNC(_wrap_PartySubIDType_ADDRESS_CITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ADDRESS_STATE_OR_PROVINCE", VALUEFUNC(_wrap_PartySubIDType_ADDRESS_STATE_OR_PROVINCE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ADDRESS_POSTAL_CODE", VALUEFUNC(_wrap_PartySubIDType_ADDRESS_POSTAL_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ADDRESS_STREET", VALUEFUNC(_wrap_PartySubIDType_ADDRESS_STREET_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ADDRESS_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_PartySubIDType_ADDRESS_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_PartySubIDType_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_MARKET_SEGMENT", VALUEFUNC(_wrap_PartySubIDType_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CUSTOMER_ACCOUNT_TYPE", VALUEFUNC(_wrap_PartySubIDType_CUSTOMER_ACCOUNT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_OMNIBUS_ACCOUNT", VALUEFUNC(_wrap_PartySubIDType_OMNIBUS_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FUNDS_SEGREGATION_TYPE", VALUEFUNC(_wrap_PartySubIDType_FUNDS_SEGREGATION_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_GUARANTEE_FUND", VALUEFUNC(_wrap_PartySubIDType_GUARANTEE_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SWAP_DEALER", VALUEFUNC(_wrap_PartySubIDType_SWAP_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_MAJOR_PARTICIPANT", VALUEFUNC(_wrap_PartySubIDType_MAJOR_PARTICIPANT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FINANCIAL_ENTITY", VALUEFUNC(_wrap_PartySubIDType_FINANCIAL_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_US_PERSON", VALUEFUNC(_wrap_PartySubIDType_US_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REPORTING_ENTITY_INDICATOR", VALUEFUNC(_wrap_PartySubIDType_REPORTING_ENTITY_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ELECTED_CLEARING_REQUIREMENT_EXCEPTION", VALUEFUNC(_wrap_PartySubIDType_ELECTED_CLEARING_REQUIREMENT_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_BUSINESS_CENTER", VALUEFUNC(_wrap_PartySubIDType_BUSINESS_CENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_REFERENCE_TEXT", VALUEFUNC(_wrap_PartySubIDType_REFERENCE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SHORT_MARKING_EXEMPT_ACCOUNT", VALUEFUNC(_wrap_PartySubIDType_SHORT_MARKING_EXEMPT_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PARENT_FIRM_IDENTIFIER", VALUEFUNC(_wrap_PartySubIDType_PARENT_FIRM_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PARENT_FIRM_NAME", VALUEFUNC(_wrap_PartySubIDType_PARENT_FIRM_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DEAL_IDENTIFIER", VALUEFUNC(_wrap_PartySubIDType_DEAL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SYSTEM_TRADE_ID", VALUEFUNC(_wrap_PartySubIDType_SYSTEM_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SYSTEM_TRADE_SUB_ID", VALUEFUNC(_wrap_PartySubIDType_SYSTEM_TRADE_SUB_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FCM_CODE", VALUEFUNC(_wrap_PartySubIDType_FCM_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DLVRY_TRML_CODE", VALUEFUNC(_wrap_PartySubIDType_DLVRY_TRML_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_VOLNTY_RPT_ENTITY", VALUEFUNC(_wrap_PartySubIDType_VOLNTY_RPT_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_RPT_OBLIG_JURSDCTN", VALUEFUNC(_wrap_PartySubIDType_RPT_OBLIG_JURSDCTN_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_VOLNTY_RPT_JURSDCTN", VALUEFUNC(_wrap_PartySubIDType_VOLNTY_RPT_JURSDCTN_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_COMPANY_ACTIVITIES", VALUEFUNC(_wrap_PartySubIDType_COMPANY_ACTIVITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_EE_AREA_DOMICILED", VALUEFUNC(_wrap_PartySubIDType_EE_AREA_DOMICILED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CONTRACT_LINKED", VALUEFUNC(_wrap_PartySubIDType_CONTRACT_LINKED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_CONTRACT_ABOVE", VALUEFUNC(_wrap_PartySubIDType_CONTRACT_ABOVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_VOLNTY_RPT_PTY", VALUEFUNC(_wrap_PartySubIDType_VOLNTY_RPT_PTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_END_USER", VALUEFUNC(_wrap_PartySubIDType_END_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_LOCATION_OR_JURISDICTION", VALUEFUNC(_wrap_PartySubIDType_LOCATION_OR_JURISDICTION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DERIVATIVES_DEALER", VALUEFUNC(_wrap_PartySubIDType_DERIVATIVES_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DOMICILE", VALUEFUNC(_wrap_PartySubIDType_DOMICILE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_EXEMPT_FROM_RECOGNITION", VALUEFUNC(_wrap_PartySubIDType_EXEMPT_FROM_RECOGNITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PAYER", VALUEFUNC(_wrap_PartySubIDType_PAYER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_RECEIVER", VALUEFUNC(_wrap_PartySubIDType_RECEIVER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SYSTEMATIC_INTERNALISER", VALUEFUNC(_wrap_PartySubIDType_SYSTEMATIC_INTERNALISER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PUBLISHING_ENTITY_INDICATOR", VALUEFUNC(_wrap_PartySubIDType_PUBLISHING_ENTITY_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_FIRST_NAME", VALUEFUNC(_wrap_PartySubIDType_FIRST_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SURNAME", VALUEFUNC(_wrap_PartySubIDType_SURNAME_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_DATE_OF_BIRTH", VALUEFUNC(_wrap_PartySubIDType_DATE_OF_BIRTH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ORDER_TRANSMITTING_FIRM", VALUEFUNC(_wrap_PartySubIDType_ORDER_TRANSMITTING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ORDER_TRANSMITTING_FIRM_BUYER", VALUEFUNC(_wrap_PartySubIDType_ORDER_TRANSMITTING_FIRM_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_ORDER_TRANSMITTER_SELLER", VALUEFUNC(_wrap_PartySubIDType_ORDER_TRANSMITTER_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_LEGAL_ENTITY_IDENTIFIER", VALUEFUNC(_wrap_PartySubIDType_LEGAL_ENTITY_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_SUB_SECTOR_CLASSIFICATION", VALUEFUNC(_wrap_PartySubIDType_SUB_SECTOR_CLASSIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_PARTY_SIDE", VALUEFUNC(_wrap_PartySubIDType_PARTY_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartySubIDType_LEGAL_REGISTRATION_COUNTRY", VALUEFUNC(_wrap_PartySubIDType_LEGAL_REGISTRATION_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_ACCEPT", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_RELEASE", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_REVERSAL", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_ACCEPT", VALUEFUNC(_wrap_AllocIntermedReqType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_BLOCK_LEVEL_REJECT", VALUEFUNC(_wrap_AllocIntermedReqType_BLOCK_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_ACCOUNT_LEVEL_REJECT", VALUEFUNC(_wrap_AllocIntermedReqType_ACCOUNT_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_NO_ACTION_TAKEN", VALUEFUNC(_wrap_ApplQueueResolution_NO_ACTION_TAKEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_QUEUE_FLUSHED", VALUEFUNC(_wrap_ApplQueueResolution_QUEUE_FLUSHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_OVERLAY_LAST", VALUEFUNC(_wrap_ApplQueueResolution_OVERLAY_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_END_SESSION", VALUEFUNC(_wrap_ApplQueueResolution_END_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_NO_ACTION_TAKEN", VALUEFUNC(_wrap_ApplQueueAction_NO_ACTION_TAKEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_QUEUE_FLUSHED", VALUEFUNC(_wrap_ApplQueueAction_QUEUE_FLUSHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_OVERLAY_LAST", VALUEFUNC(_wrap_ApplQueueAction_OVERLAY_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_END_SESSION", VALUEFUNC(_wrap_ApplQueueAction_END_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_NO_AVERAGE_PRICING", VALUEFUNC(_wrap_AvgPxIndicator_NO_AVERAGE_PRICING_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_TRADE", VALUEFUNC(_wrap_AvgPxIndicator_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_LAST_TRADE", VALUEFUNC(_wrap_AvgPxIndicator_LAST_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_NOTIONAL_VALUE_AVERAGE_PX_GROUP_TRADE", VALUEFUNC(_wrap_AvgPxIndicator_NOTIONAL_VALUE_AVERAGE_PX_GROUP_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_AVERAGE_PRICED_TRADE", VALUEFUNC(_wrap_AvgPxIndicator_AVERAGE_PRICED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_NOT_REQUIRED", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_NOT_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_REQUIRED", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE", VALUEFUNC(_wrap_TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_GIVE_UP_EXECUTOR", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_GIVE_UP_EXECUTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_FROM_EXECUTOR", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_FROM_EXECUTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_TO_CLAIM_ACCOUNT", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_TO_CLAIM_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_TRADE_SPLIT", VALUEFUNC(_wrap_TradeAllocIndicator_TRADE_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE", VALUEFUNC(_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN", VALUEFUNC(_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationCycle_SPECIFIED_EXPIRATION", VALUEFUNC(_wrap_ExpirationCycle_SPECIFIED_EXPIRATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_REGULAR_TRADE", VALUEFUNC(_wrap_TrdType_REGULAR_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BLOCK_TRADE", VALUEFUNC(_wrap_TrdType_BLOCK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EFP", VALUEFUNC(_wrap_TrdType_EFP_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_TRANSFER", VALUEFUNC(_wrap_TrdType_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_LATE_TRADE", VALUEFUNC(_wrap_TrdType_LATE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_T_TRADE", VALUEFUNC(_wrap_TrdType_T_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_WEIGHTED_AVERAGE_PRICE_TRADE", VALUEFUNC(_wrap_TrdType_WEIGHTED_AVERAGE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BUNCHED_TRADE", VALUEFUNC(_wrap_TrdType_BUNCHED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_LATE_BUNCHED_TRADE", VALUEFUNC(_wrap_TrdType_LATE_BUNCHED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PRIOR_REFERENCE_PRICE_TRADE", VALUEFUNC(_wrap_TrdType_PRIOR_REFERENCE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_AFTER_HOURS_TRADE", VALUEFUNC(_wrap_TrdType_AFTER_HOURS_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_FOR_RISK", VALUEFUNC(_wrap_TrdType_EXCHANGE_FOR_RISK_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_FOR_SWAP", VALUEFUNC(_wrap_TrdType_EXCHANGE_FOR_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_OF_FUTURES_FOR", VALUEFUNC(_wrap_TrdType_EXCHANGE_OF_FUTURES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_OF_OPTIONS_FOR_OPTIONS", VALUEFUNC(_wrap_TrdType_EXCHANGE_OF_OPTIONS_FOR_OPTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_TRADING_AT_SETTLEMENT", VALUEFUNC(_wrap_TrdType_TRADING_AT_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_ALL_OR_NONE", VALUEFUNC(_wrap_TrdType_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_FUTURES_LARGE_ORDER_EXECUTION", VALUEFUNC(_wrap_TrdType_FUTURES_LARGE_ORDER_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_OF_FUTURES_FOR_FUTURES", VALUEFUNC(_wrap_TrdType_EXCHANGE_OF_FUTURES_FOR_FUTURES_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_OPTION_INTERIM_TRADE", VALUEFUNC(_wrap_TrdType_OPTION_INTERIM_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_OPTION_CABINET_TRADE", VALUEFUNC(_wrap_TrdType_OPTION_CABINET_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PRIVATELY_NEGOTIATED_TRADES", VALUEFUNC(_wrap_TrdType_PRIVATELY_NEGOTIATED_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SUBSTITUTION_OF_FUTURES_FOR_FORWARDS", VALUEFUNC(_wrap_TrdType_SUBSTITUTION_OF_FUTURES_FOR_FORWARDS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_ERROR_TRADE", VALUEFUNC(_wrap_TrdType_ERROR_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_CUM_DIVIDEND", VALUEFUNC(_wrap_TrdType_SPECIAL_CUM_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_EX_DIVIDEND", VALUEFUNC(_wrap_TrdType_SPECIAL_EX_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_CUM_COUPON", VALUEFUNC(_wrap_TrdType_SPECIAL_CUM_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_EX_COUPON", VALUEFUNC(_wrap_TrdType_SPECIAL_EX_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_CASH_SETTLEMENT", VALUEFUNC(_wrap_TrdType_CASH_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_PRICE", VALUEFUNC(_wrap_TrdType_SPECIAL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_GUARANTEED_DELIVERY", VALUEFUNC(_wrap_TrdType_GUARANTEED_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_CUM_RIGHTS", VALUEFUNC(_wrap_TrdType_SPECIAL_CUM_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_EX_RIGHTS", VALUEFUNC(_wrap_TrdType_SPECIAL_EX_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_CUM_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_TrdType_SPECIAL_CUM_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_EX_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_TrdType_SPECIAL_EX_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_CUM_BONUS", VALUEFUNC(_wrap_TrdType_SPECIAL_CUM_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SPECIAL_EX_BONUS", VALUEFUNC(_wrap_TrdType_SPECIAL_EX_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_LARGE_TRADE", VALUEFUNC(_wrap_TrdType_LARGE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_WORKED_PRINCIPAL_TRADE", VALUEFUNC(_wrap_TrdType_WORKED_PRINCIPAL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BLOCK_TRADES", VALUEFUNC(_wrap_TrdType_BLOCK_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_NAME_CHANGE", VALUEFUNC(_wrap_TrdType_NAME_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PORTFOLIO_TRANSFER", VALUEFUNC(_wrap_TrdType_PORTFOLIO_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PROROGATION_BUY", VALUEFUNC(_wrap_TrdType_PROROGATION_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PROROGATION_SELL", VALUEFUNC(_wrap_TrdType_PROROGATION_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_OPTION_EXERCISE", VALUEFUNC(_wrap_TrdType_OPTION_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_DELTA_NEUTRAL_TRANSACTION", VALUEFUNC(_wrap_TrdType_DELTA_NEUTRAL_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_FINANCING_TRANSACTION", VALUEFUNC(_wrap_TrdType_FINANCING_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_NON_STANDARD_SETTLEMENT", VALUEFUNC(_wrap_TrdType_NON_STANDARD_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_DERIVATIVE_RELATED_TRANSACTION", VALUEFUNC(_wrap_TrdType_DERIVATIVE_RELATED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PORTFOLIO_TRADE", VALUEFUNC(_wrap_TrdType_PORTFOLIO_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_VOLUME_WEIGHTED_AVERAGE_TRADE", VALUEFUNC(_wrap_TrdType_VOLUME_WEIGHTED_AVERAGE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_GRANTED_TRADE", VALUEFUNC(_wrap_TrdType_EXCHANGE_GRANTED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_REPURCHASE_AGREEMENT", VALUEFUNC(_wrap_TrdType_REPURCHASE_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_OTC", VALUEFUNC(_wrap_TrdType_OTC_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EXCHANGE_BASIS_FACILITY", VALUEFUNC(_wrap_TrdType_EXCHANGE_BASIS_FACILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_OPENING_TRADE", VALUEFUNC(_wrap_TrdType_OPENING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_NETTED_TRADE", VALUEFUNC(_wrap_TrdType_NETTED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BLOCK_SWAP_TRADE", VALUEFUNC(_wrap_TrdType_BLOCK_SWAP_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_CREDIT_EVENT_TRADE", VALUEFUNC(_wrap_TrdType_CREDIT_EVENT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_SUCCESSION_EVENT_TRADE", VALUEFUNC(_wrap_TrdType_SUCCESSION_EVENT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_GIVE_UP_GIVE_IN_TRADE", VALUEFUNC(_wrap_TrdType_GIVE_UP_GIVE_IN_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_DARK_TRADE", VALUEFUNC(_wrap_TrdType_DARK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_TECHNICAL_TRADE", VALUEFUNC(_wrap_TrdType_TECHNICAL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BENCHMARK", VALUEFUNC(_wrap_TrdType_BENCHMARK_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PACKAGE_TRADE", VALUEFUNC(_wrap_TrdType_PACKAGE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_ROLL_TRADE", VALUEFUNC(_wrap_TrdType_ROLL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_CMTA", VALUEFUNC(_wrap_TrdSubType_CMTA_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_INTERNAL_TRANSFER_OR_ADJUSTMENT", VALUEFUNC(_wrap_TrdSubType_INTERNAL_TRANSFER_OR_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_EXTERNAL_TRANSFER_OR_TRANSFER_OF_ACCOUNT", VALUEFUNC(_wrap_TrdSubType_EXTERNAL_TRANSFER_OR_TRANSFER_OF_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_REJECT_FOR_SUBMITTING_SIDE", VALUEFUNC(_wrap_TrdSubType_REJECT_FOR_SUBMITTING_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_ADVISORY_FOR_CONTRA_SIDE", VALUEFUNC(_wrap_TrdSubType_ADVISORY_FOR_CONTRA_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_OFFSET_DUE_TO_AN_ALLOCATION", VALUEFUNC(_wrap_TrdSubType_OFFSET_DUE_TO_AN_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_ONSET_DUE_TO_AN_ALLOCATION", VALUEFUNC(_wrap_TrdSubType_ONSET_DUE_TO_AN_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_DIFFERENTIAL_SPREAD", VALUEFUNC(_wrap_TrdSubType_DIFFERENTIAL_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_IMPLIED_SPREAD_LEG_EXECUTED_AGAINST_AN_OUTRIGHT", VALUEFUNC(_wrap_TrdSubType_IMPLIED_SPREAD_LEG_EXECUTED_AGAINST_AN_OUTRIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRANSACTION_FROM_EXERCISE", VALUEFUNC(_wrap_TrdSubType_TRANSACTION_FROM_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRANSACTION_FROM_ASSIGNMENT", VALUEFUNC(_wrap_TrdSubType_TRANSACTION_FROM_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_ACATS", VALUEFUNC(_wrap_TrdSubType_ACATS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_AI", VALUEFUNC(_wrap_TrdSubType_AI_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_B", VALUEFUNC(_wrap_TrdSubType_B_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_K", VALUEFUNC(_wrap_TrdSubType_K_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_LC", VALUEFUNC(_wrap_TrdSubType_LC_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_M", VALUEFUNC(_wrap_TrdSubType_M_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_N", VALUEFUNC(_wrap_TrdSubType_N_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_NM", VALUEFUNC(_wrap_TrdSubType_NM_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_NR", VALUEFUNC(_wrap_TrdSubType_NR_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_P", VALUEFUNC(_wrap_TrdSubType_P_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_PA", VALUEFUNC(_wrap_TrdSubType_PA_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_PC", VALUEFUNC(_wrap_TrdSubType_PC_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_PN", VALUEFUNC(_wrap_TrdSubType_PN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_R", VALUEFUNC(_wrap_TrdSubType_R_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_RO", VALUEFUNC(_wrap_TrdSubType_RO_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_RT", VALUEFUNC(_wrap_TrdSubType_RT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_SW", VALUEFUNC(_wrap_TrdSubType_SW_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_T", VALUEFUNC(_wrap_TrdSubType_T_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_WN", VALUEFUNC(_wrap_TrdSubType_WN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_WT", VALUEFUNC(_wrap_TrdSubType_WT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_OFF_HOURS_TRADE", VALUEFUNC(_wrap_TrdSubType_OFF_HOURS_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_ON_HOURS_TRADE", VALUEFUNC(_wrap_TrdSubType_ON_HOURS_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_OTC_QUOTE", VALUEFUNC(_wrap_TrdSubType_OTC_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_CONVERTED_SWAP", VALUEFUNC(_wrap_TrdSubType_CONVERTED_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_CROSSED_TRADE", VALUEFUNC(_wrap_TrdSubType_CROSSED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_INTERIM_PROTECTED_TRADE", VALUEFUNC(_wrap_TrdSubType_INTERIM_PROTECTED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_LARGE_IN_SCALE", VALUEFUNC(_wrap_TrdSubType_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_WASH_TRADE", VALUEFUNC(_wrap_TrdSubType_WASH_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRADE_AT_SETTLEMENT", VALUEFUNC(_wrap_TrdSubType_TRADE_AT_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_AUCTION_TRADE", VALUEFUNC(_wrap_TrdSubType_AUCTION_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRADE_AT_MARKER", VALUEFUNC(_wrap_TrdSubType_TRADE_AT_MARKER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_CREDIT_DEFAULT", VALUEFUNC(_wrap_TrdSubType_CREDIT_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_CREDIT_RESTRUCTURING", VALUEFUNC(_wrap_TrdSubType_CREDIT_RESTRUCTURING_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_MERGER", VALUEFUNC(_wrap_TrdSubType_MERGER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_SPIN_OFF", VALUEFUNC(_wrap_TrdSubType_SPIN_OFF_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_MULTILATERAL_COMPRESSION", VALUEFUNC(_wrap_TrdSubType_MULTILATERAL_COMPRESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_BALANCING", VALUEFUNC(_wrap_TrdSubType_BALANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_BASIS_TRADE_INDEX_CLOSE", VALUEFUNC(_wrap_TrdSubType_BASIS_TRADE_INDEX_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRADE_AT_CASH_OPEN", VALUEFUNC(_wrap_TrdSubType_TRADE_AT_CASH_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_TRD_SUBMIT_VENUE_CLR_SETTL", VALUEFUNC(_wrap_TrdSubType_TRD_SUBMIT_VENUE_CLR_SETTL_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdSubType_BILATERAL_COMPRESSION", VALUEFUNC(_wrap_TrdSubType_BILATERAL_COMPRESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "PegMoveType_FLOATING", VALUEFUNC(_wrap_PegMoveType_FLOATING_get), 0);
  rb_define_singleton_method(mQuickfix, "PegMoveType_FIXED", VALUEFUNC(_wrap_PegMoveType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_PRICE", VALUEFUNC(_wrap_PegOffsetType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_BASIS_POINTS", VALUEFUNC(_wrap_PegOffsetType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_TICKS", VALUEFUNC(_wrap_PegOffsetType_TICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_PRICE_TIER", VALUEFUNC(_wrap_PegOffsetType_PRICE_TIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_PERCENTAGE", VALUEFUNC(_wrap_PegOffsetType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_OR_BETTER", VALUEFUNC(_wrap_PegLimitType_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_STRICT", VALUEFUNC(_wrap_PegLimitType_STRICT_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_OR_WORSE", VALUEFUNC(_wrap_PegLimitType_OR_WORSE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegRoundDirection_MORE_AGGRESSIVE", VALUEFUNC(_wrap_PegRoundDirection_MORE_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegRoundDirection_MORE_PASSIVE", VALUEFUNC(_wrap_PegRoundDirection_MORE_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_LOCAL", VALUEFUNC(_wrap_PegScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_NATIONAL", VALUEFUNC(_wrap_PegScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_GLOBAL", VALUEFUNC(_wrap_PegScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_NATIONAL_EXCLUDING_LOCAL", VALUEFUNC(_wrap_PegScope_NATIONAL_EXCLUDING_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionMoveType_FLOATING", VALUEFUNC(_wrap_DiscretionMoveType_FLOATING_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionMoveType_FIXED", VALUEFUNC(_wrap_DiscretionMoveType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_PRICE", VALUEFUNC(_wrap_DiscretionOffsetType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_BASIS_POINTS", VALUEFUNC(_wrap_DiscretionOffsetType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_TICKS", VALUEFUNC(_wrap_DiscretionOffsetType_TICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_PRICE_TIER", VALUEFUNC(_wrap_DiscretionOffsetType_PRICE_TIER_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_OR_BETTER", VALUEFUNC(_wrap_DiscretionLimitType_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_STRICT", VALUEFUNC(_wrap_DiscretionLimitType_STRICT_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_OR_WORSE", VALUEFUNC(_wrap_DiscretionLimitType_OR_WORSE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionRoundDirection_MORE_AGGRESSIVE", VALUEFUNC(_wrap_DiscretionRoundDirection_MORE_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionRoundDirection_MORE_PASSIVE", VALUEFUNC(_wrap_DiscretionRoundDirection_MORE_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_LOCAL", VALUEFUNC(_wrap_DiscretionScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_NATIONAL", VALUEFUNC(_wrap_DiscretionScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_GLOBAL", VALUEFUNC(_wrap_DiscretionScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_NATIONAL_EXCLUDING_LOCAL", VALUEFUNC(_wrap_DiscretionScope_NATIONAL_EXCLUDING_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TargetStrategy_VWAP", VALUEFUNC(_wrap_TargetStrategy_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "TargetStrategy_PARTICIPATE", VALUEFUNC(_wrap_TargetStrategy_PARTICIPATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TargetStrategy_MININIZE_MARKET_IMPACT", VALUEFUNC(_wrap_TargetStrategy_MININIZE_MARKET_IMPACT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_ADDED_LIQUIDITY", VALUEFUNC(_wrap_LastLiquidityInd_ADDED_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_REMOVED_LIQUIDITY", VALUEFUNC(_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_LIQUIDITY_ROUTED_OUT", VALUEFUNC(_wrap_LastLiquidityInd_LIQUIDITY_ROUTED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_AUCTION", VALUEFUNC(_wrap_LastLiquidityInd_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_NEITHER_ADDED_NOR_REMOVED_LIQUIDITY", VALUEFUNC(_wrap_LastLiquidityInd_NEITHER_ADDED_NOR_REMOVED_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_TRIGGERED_STOP_ORDER", VALUEFUNC(_wrap_LastLiquidityInd_TRIGGERED_STOP_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_TRIGGERED_CONTINGENCY_ORDER", VALUEFUNC(_wrap_LastLiquidityInd_TRIGGERED_CONTINGENCY_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_TRIGGERED_MARKET_ORDER", VALUEFUNC(_wrap_LastLiquidityInd_TRIGGERED_MARKET_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_REMOVED_LIQUIDITY_AFTER_FIRM_ORDER_COMMITMENT", VALUEFUNC(_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_AFTER_FIRM_ORDER_COMMITMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_AUCTION_EXECUTION_AFTER_FIRM_ORDER_COMMITMENT", VALUEFUNC(_wrap_LastLiquidityInd_AUCTION_EXECUTION_AFTER_FIRM_ORDER_COMMITMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_UNKNOWN", VALUEFUNC(_wrap_LastLiquidityInd_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_OTHER", VALUEFUNC(_wrap_LastLiquidityInd_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PublishTrdIndicator_YES", VALUEFUNC(_wrap_PublishTrdIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "PublishTrdIndicator_NO", VALUEFUNC(_wrap_PublishTrdIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_DEALER_SOLD_SHORT", VALUEFUNC(_wrap_ShortSaleReason_DEALER_SOLD_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT", VALUEFUNC(_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_QUALIFIED_SERVICE_REPRESENTATIVE", VALUEFUNC(_wrap_ShortSaleReason_QUALIFIED_SERVICE_REPRESENTATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "QtyType_UNITS", VALUEFUNC(_wrap_QtyType_UNITS_get), 0);
  rb_define_singleton_method(mQuickfix, "QtyType_CONTRACTS", VALUEFUNC(_wrap_QtyType_CONTRACTS_get), 0);
  rb_define_singleton_method(mQuickfix, "QtyType_UNITS_OF_MEASURE_PER_TIME_UNIT", VALUEFUNC(_wrap_QtyType_UNITS_OF_MEASURE_PER_TIME_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_SUBMIT", VALUEFUNC(_wrap_TradeReportType_SUBMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED", VALUEFUNC(_wrap_TradeReportType_ALLEGED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ACCEPT", VALUEFUNC(_wrap_TradeReportType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_DECLINE", VALUEFUNC(_wrap_TradeReportType_DECLINE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ADDENDUM", VALUEFUNC(_wrap_TradeReportType_ADDENDUM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_NO", VALUEFUNC(_wrap_TradeReportType_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_TRADE_REPORT_CANCEL", VALUEFUNC(_wrap_TradeReportType_TRADE_REPORT_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_LOCKED_IN", VALUEFUNC(_wrap_TradeReportType_LOCKED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_DEFAULTED", VALUEFUNC(_wrap_TradeReportType_DEFAULTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_INVALID_CMTA", VALUEFUNC(_wrap_TradeReportType_INVALID_CMTA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_PENDED", VALUEFUNC(_wrap_TradeReportType_PENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED_NEW", VALUEFUNC(_wrap_TradeReportType_ALLEGED_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED_ADDENDUM", VALUEFUNC(_wrap_TradeReportType_ALLEGED_ADDENDUM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED_NO", VALUEFUNC(_wrap_TradeReportType_ALLEGED_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED_TRADE_REPORT_CANCEL", VALUEFUNC(_wrap_TradeReportType_ALLEGED_TRADE_REPORT_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED_TRADE_BREAK", VALUEFUNC(_wrap_TradeReportType_ALLEGED_TRADE_BREAK_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_VERIFY", VALUEFUNC(_wrap_TradeReportType_VERIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_DISPUTE", VALUEFUNC(_wrap_TradeReportType_DISPUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_NON_MATERIAL_UPDATE", VALUEFUNC(_wrap_TradeReportType_NON_MATERIAL_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocNoOrdersType_NOT_SPECIFIED", VALUEFUNC(_wrap_AllocNoOrdersType_NOT_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocNoOrdersType_EXPLICIT_LIST_PROVIDED", VALUEFUNC(_wrap_AllocNoOrdersType_EXPLICIT_LIST_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_PUT", VALUEFUNC(_wrap_EventType_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_CALL", VALUEFUNC(_wrap_EventType_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_TENDER", VALUEFUNC(_wrap_EventType_TENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SINKING_FUND_CALL", VALUEFUNC(_wrap_EventType_SINKING_FUND_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_OTHER", VALUEFUNC(_wrap_EventType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_ACTIVATION", VALUEFUNC(_wrap_EventType_ACTIVATION_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_INACTIVIATION", VALUEFUNC(_wrap_EventType_INACTIVIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_LAST_ELIGIBLE_TRADE_DATE", VALUEFUNC(_wrap_EventType_LAST_ELIGIBLE_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SWAP_START_DATE", VALUEFUNC(_wrap_EventType_SWAP_START_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SWAP_END_DATE", VALUEFUNC(_wrap_EventType_SWAP_END_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SWAP_ROLL_DATE", VALUEFUNC(_wrap_EventType_SWAP_ROLL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SWAP_NEXT_START_DATE", VALUEFUNC(_wrap_EventType_SWAP_NEXT_START_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SWAP_NEXT_ROLL_DATE", VALUEFUNC(_wrap_EventType_SWAP_NEXT_ROLL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_FIRST_DELIVERY_DATE", VALUEFUNC(_wrap_EventType_FIRST_DELIVERY_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_LAST_DELIVERY_DATE", VALUEFUNC(_wrap_EventType_LAST_DELIVERY_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_INITIAL_INVENTORY_DUE_DATE", VALUEFUNC(_wrap_EventType_INITIAL_INVENTORY_DUE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_FINAL_INVENTORY_DUE_DATE", VALUEFUNC(_wrap_EventType_FINAL_INVENTORY_DUE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_FIRST_INTENT_DATE", VALUEFUNC(_wrap_EventType_FIRST_INTENT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_LAST_INTENT_DATE", VALUEFUNC(_wrap_EventType_LAST_INTENT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_POSITION_REMOVAL_DATE", VALUEFUNC(_wrap_EventType_POSITION_REMOVAL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_MINIMUM_NOTICE", VALUEFUNC(_wrap_EventType_MINIMUM_NOTICE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_DELIVERY_START_TIME", VALUEFUNC(_wrap_EventType_DELIVERY_START_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_DELIVERY_END_TIME", VALUEFUNC(_wrap_EventType_DELIVERY_END_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_FIRST_NOTICE_DATE", VALUEFUNC(_wrap_EventType_FIRST_NOTICE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_LAST_NOTICE_DATE", VALUEFUNC(_wrap_EventType_LAST_NOTICE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_FIRST_EXERCISE_DATE", VALUEFUNC(_wrap_EventType_FIRST_EXERCISE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_REDEMPTION_DATE", VALUEFUNC(_wrap_EventType_REDEMPTION_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_TRD_CNTNTN_EFCTV_DT", VALUEFUNC(_wrap_EventType_TRD_CNTNTN_EFCTV_DT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_FLAT", VALUEFUNC(_wrap_InstrAttribType_FLAT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ZERO_COUPON", VALUEFUNC(_wrap_InstrAttribType_ZERO_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INTEREST_BEARING", VALUEFUNC(_wrap_InstrAttribType_INTEREST_BEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_NO_PERIODIC_PAYMENTS", VALUEFUNC(_wrap_InstrAttribType_NO_PERIODIC_PAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_VARIABLE_RATE", VALUEFUNC(_wrap_InstrAttribType_VARIABLE_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_LESS_FEE_FOR_PUT", VALUEFUNC(_wrap_InstrAttribType_LESS_FEE_FOR_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_STEPPED_COUPON", VALUEFUNC(_wrap_InstrAttribType_STEPPED_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_COUPON_PERIOD", VALUEFUNC(_wrap_InstrAttribType_COUPON_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_WHEN", VALUEFUNC(_wrap_InstrAttribType_WHEN_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ORIGINAL_ISSUE_DISCOUNT", VALUEFUNC(_wrap_InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_CALLABLE", VALUEFUNC(_wrap_InstrAttribType_CALLABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ESCROWED_TO_MATURITY", VALUEFUNC(_wrap_InstrAttribType_ESCROWED_TO_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ESCROWED_TO_REDEMPTION_DATE", VALUEFUNC(_wrap_InstrAttribType_ESCROWED_TO_REDEMPTION_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_PRE_REFUNDED", VALUEFUNC(_wrap_InstrAttribType_PRE_REFUNDED_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_IN_DEFAULT", VALUEFUNC(_wrap_InstrAttribType_IN_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_UNRATED", VALUEFUNC(_wrap_InstrAttribType_UNRATED_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TAXABLE", VALUEFUNC(_wrap_InstrAttribType_TAXABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INDEXED", VALUEFUNC(_wrap_InstrAttribType_INDEXED_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX", VALUEFUNC(_wrap_InstrAttribType_SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_PRICE", VALUEFUNC(_wrap_InstrAttribType_ORIGINAL_ISSUE_DISCOUNT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_CALLABLE_BELOW_MATURITY_VALUE", VALUEFUNC(_wrap_InstrAttribType_CALLABLE_BELOW_MATURITY_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_CALLABLE_WITHOUT_NOTICE", VALUEFUNC(_wrap_InstrAttribType_CALLABLE_WITHOUT_NOTICE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TEXT", VALUEFUNC(_wrap_InstrAttribType_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_PRICE_TICK_RULES_FOR_SECURITY", VALUEFUNC(_wrap_InstrAttribType_PRICE_TICK_RULES_FOR_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TRADE_TYPE_ELIGIBILITY_DETAILS_FOR_SECURITY", VALUEFUNC(_wrap_InstrAttribType_TRADE_TYPE_ELIGIBILITY_DETAILS_FOR_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INSTRUMENT_DENOMINATOR", VALUEFUNC(_wrap_InstrAttribType_INSTRUMENT_DENOMINATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INSTRUMENT_NUMERATOR", VALUEFUNC(_wrap_InstrAttribType_INSTRUMENT_NUMERATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INSTRUMENT_PRICE_PRECISION", VALUEFUNC(_wrap_InstrAttribType_INSTRUMENT_PRICE_PRECISION_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INSTRUMENT_STRIKE_PRICE", VALUEFUNC(_wrap_InstrAttribType_INSTRUMENT_STRIKE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TRADEABLE_INDICATOR", VALUEFUNC(_wrap_InstrAttribType_TRADEABLE_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INSTRUMENT_ELIGIBLE_ANON_ORDERS", VALUEFUNC(_wrap_InstrAttribType_INSTRUMENT_ELIGIBLE_ANON_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_MIN_GUARANTEED_FILL_VOLUME", VALUEFUNC(_wrap_InstrAttribType_MIN_GUARANTEED_FILL_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_MIN_GUARANTEED_FILL_STATUS", VALUEFUNC(_wrap_InstrAttribType_MIN_GUARANTEED_FILL_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TRADE_AT_SETTLEMENT_ELIGIBILITY", VALUEFUNC(_wrap_InstrAttribType_TRADE_AT_SETTLEMENT_ELIGIBILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_TEST_INSTRUMENT", VALUEFUNC(_wrap_InstrAttribType_TEST_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_DUMMY_INSTRUMENT", VALUEFUNC(_wrap_InstrAttribType_DUMMY_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_NEGATIVE_SETTLEMENT_PRICE_ELIGIBILITY", VALUEFUNC(_wrap_InstrAttribType_NEGATIVE_SETTLEMENT_PRICE_ELIGIBILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_NEGATIVE_STRIKE_PRICE_ELIGIBILITY", VALUEFUNC(_wrap_InstrAttribType_NEGATIVE_STRIKE_PRICE_ELIGIBILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_US_STD_CONTRACT_IND", VALUEFUNC(_wrap_InstrAttribType_US_STD_CONTRACT_IND_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ADMITTED_TO_TRADING_ON_TRADING_VENUE", VALUEFUNC(_wrap_InstrAttribType_ADMITTED_TO_TRADING_ON_TRADING_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_AVERAGE_DAILY_NOTIONAL_AMOUNT", VALUEFUNC(_wrap_InstrAttribType_AVERAGE_DAILY_NOTIONAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_AVERAGE_DAILY_NUMBER_TRADES", VALUEFUNC(_wrap_InstrAttribType_AVERAGE_DAILY_NUMBER_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A3", VALUEFUNC(_wrap_CPProgram_PROGRAM3A3_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM42", VALUEFUNC(_wrap_CPProgram_PROGRAM42_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_OTHER", VALUEFUNC(_wrap_CPProgram_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A2", VALUEFUNC(_wrap_CPProgram_PROGRAM3A2_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A3_AND3C7", VALUEFUNC(_wrap_CPProgram_PROGRAM3A3_AND3C7_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A4", VALUEFUNC(_wrap_CPProgram_PROGRAM3A4_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A5", VALUEFUNC(_wrap_CPProgram_PROGRAM3A5_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3A7", VALUEFUNC(_wrap_CPProgram_PROGRAM3A7_get), 0);
  rb_define_singleton_method(mQuickfix, "CPProgram_PROGRAM3C7", VALUEFUNC(_wrap_CPProgram_PROGRAM3C7_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_ABSOLUTE", VALUEFUNC(_wrap_MiscFeeBasis_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_PER_UNIT", VALUEFUNC(_wrap_MiscFeeBasis_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_PERCENTAGE", VALUEFUNC(_wrap_MiscFeeBasis_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LastFragment_YES", VALUEFUNC(_wrap_LastFragment_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "LastFragment_NO", VALUEFUNC(_wrap_LastFragment_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_INITIAL", VALUEFUNC(_wrap_CollAsgnReason_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_SCHEDULED", VALUEFUNC(_wrap_CollAsgnReason_SCHEDULED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_TIME_WARNING", VALUEFUNC(_wrap_CollAsgnReason_TIME_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_MARGIN_DEFICIENCY", VALUEFUNC(_wrap_CollAsgnReason_MARGIN_DEFICIENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_MARGIN_EXCESS", VALUEFUNC(_wrap_CollAsgnReason_MARGIN_EXCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_FORWARD_COLLATERAL_DEMAND", VALUEFUNC(_wrap_CollAsgnReason_FORWARD_COLLATERAL_DEMAND_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_EVENT_OF_DEFAULT", VALUEFUNC(_wrap_CollAsgnReason_EVENT_OF_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_ADVERSE_TAX_EVENT", VALUEFUNC(_wrap_CollAsgnReason_ADVERSE_TAX_EVENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_TRANSFER_DEPOSIT", VALUEFUNC(_wrap_CollAsgnReason_TRANSFER_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_TRANSFER_WITHDRAWAL", VALUEFUNC(_wrap_CollAsgnReason_TRANSFER_WITHDRAWAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_PLEDGE", VALUEFUNC(_wrap_CollAsgnReason_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_TRADE_DATE", VALUEFUNC(_wrap_CollInquiryQualifier_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_GC_INSTRUMENT", VALUEFUNC(_wrap_CollInquiryQualifier_GC_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_COLLATERAL_INSTRUMENT", VALUEFUNC(_wrap_CollInquiryQualifier_COLLATERAL_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_SUBSTITUTION_ELIGIBLE", VALUEFUNC(_wrap_CollInquiryQualifier_SUBSTITUTION_ELIGIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_NOT_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_NOT_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_PARTIALLY_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_PARTIALLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_FULLY_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_FULLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_OUTSTANDING_TRADES", VALUEFUNC(_wrap_CollInquiryQualifier_OUTSTANDING_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_NEW", VALUEFUNC(_wrap_CollAsgnTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_REPLACE", VALUEFUNC(_wrap_CollAsgnTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_CANCEL", VALUEFUNC(_wrap_CollAsgnTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_RELEASE", VALUEFUNC(_wrap_CollAsgnTransType_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_REVERSE", VALUEFUNC(_wrap_CollAsgnTransType_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_RECEIVED", VALUEFUNC(_wrap_CollAsgnRespType_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_ACCEPTED", VALUEFUNC(_wrap_CollAsgnRespType_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_DECLINED", VALUEFUNC(_wrap_CollAsgnRespType_DECLINED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_REJECTED", VALUEFUNC(_wrap_CollAsgnRespType_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_TRANSACTION_PENDING", VALUEFUNC(_wrap_CollAsgnRespType_TRANSACTION_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_TRANSACTION_COMPLETED_WITH_WARNING", VALUEFUNC(_wrap_CollAsgnRespType_TRANSACTION_COMPLETED_WITH_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNKNOWN_DEAL", VALUEFUNC(_wrap_CollAsgnRejectReason_UNKNOWN_DEAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT", VALUEFUNC(_wrap_CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION", VALUEFUNC(_wrap_CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_INSUFFICIENT_COLLATERAL", VALUEFUNC(_wrap_CollAsgnRejectReason_INSUFFICIENT_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL", VALUEFUNC(_wrap_CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION", VALUEFUNC(_wrap_CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_OTHER", VALUEFUNC(_wrap_CollAsgnRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_UNASSIGNED", VALUEFUNC(_wrap_CollStatus_UNASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_PARTIALLY_ASSIGNED", VALUEFUNC(_wrap_CollStatus_PARTIALLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_ASSIGNMENT_PROPOSED", VALUEFUNC(_wrap_CollStatus_ASSIGNMENT_PROPOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_ASSIGNED", VALUEFUNC(_wrap_CollStatus_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_CHALLENGED", VALUEFUNC(_wrap_CollStatus_CHALLENGED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_REUSED", VALUEFUNC(_wrap_CollStatus_REUSED_get), 0);
  rb_define_singleton_method(mQuickfix, "LastRptRequested_NO", VALUEFUNC(_wrap_LastRptRequested_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "LastRptRequested_YES", VALUEFUNC(_wrap_LastRptRequested_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_VERSUS_PAYMENT", VALUEFUNC(_wrap_DeliveryType_VERSUS_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_FREE", VALUEFUNC(_wrap_DeliveryType_FREE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_TRI_PARTY", VALUEFUNC(_wrap_DeliveryType_TRI_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_HOLD_IN_CUSTODY", VALUEFUNC(_wrap_DeliveryType_HOLD_IN_CUSTODY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_DELIVER_BY_VALUE", VALUEFUNC(_wrap_DeliveryType_DELIVER_BY_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_LOG_ON_USER", VALUEFUNC(_wrap_UserRequestType_LOG_ON_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_LOG_OFF_USER", VALUEFUNC(_wrap_UserRequestType_LOG_OFF_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_CHANGE_PASSWORD_FOR_USER", VALUEFUNC(_wrap_UserRequestType_CHANGE_PASSWORD_FOR_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS", VALUEFUNC(_wrap_UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_REQUEST_THROTTLE_LIMIT", VALUEFUNC(_wrap_UserRequestType_REQUEST_THROTTLE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_LOGGED_IN", VALUEFUNC(_wrap_UserStatus_LOGGED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_NOT_LOGGED_IN", VALUEFUNC(_wrap_UserStatus_NOT_LOGGED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_USER_NOT_RECOGNISED", VALUEFUNC(_wrap_UserStatus_USER_NOT_RECOGNISED_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_PASSWORD_INCORRECT", VALUEFUNC(_wrap_UserStatus_PASSWORD_INCORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_PASSWORD_CHANGED", VALUEFUNC(_wrap_UserStatus_PASSWORD_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_OTHER", VALUEFUNC(_wrap_UserStatus_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_FORCED_USER_LOGOUT_BY_EXCHANGE", VALUEFUNC(_wrap_UserStatus_FORCED_USER_LOGOUT_BY_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_SESSION_SHUTDOWN_WARNING", VALUEFUNC(_wrap_UserStatus_SESSION_SHUTDOWN_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_THROTTLE_PARAMETERS_CHANGED", VALUEFUNC(_wrap_UserStatus_THROTTLE_PARAMETERS_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_CONNECTED", VALUEFUNC(_wrap_StatusValue_CONNECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_NOT_CONNECTED_UNEXPECTED", VALUEFUNC(_wrap_StatusValue_NOT_CONNECTED_UNEXPECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_NOT_CONNECTED_EXPECTED", VALUEFUNC(_wrap_StatusValue_NOT_CONNECTED_EXPECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_IN_PROCESS", VALUEFUNC(_wrap_StatusValue_IN_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_SNAPSHOT", VALUEFUNC(_wrap_NetworkRequestType_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_SUBSCRIBE", VALUEFUNC(_wrap_NetworkRequestType_SUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_STOP_SUBSCRIBING", VALUEFUNC(_wrap_NetworkRequestType_STOP_SUBSCRIBING_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_LEVEL_OF_DETAIL", VALUEFUNC(_wrap_NetworkRequestType_LEVEL_OF_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkStatusResponseType_FULL", VALUEFUNC(_wrap_NetworkStatusResponseType_FULL_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkStatusResponseType_INCREMENTAL_UPDATE", VALUEFUNC(_wrap_NetworkStatusResponseType_INCREMENTAL_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_ACCEPTED", VALUEFUNC(_wrap_TrdRptStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_REJECTED", VALUEFUNC(_wrap_TrdRptStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_ACCEPTED_WITH_ERRORS", VALUEFUNC(_wrap_TrdRptStatus_ACCEPTED_WITH_ERRORS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_CANCELLED", VALUEFUNC(_wrap_TrdRptStatus_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_PENDING_NEW", VALUEFUNC(_wrap_TrdRptStatus_PENDING_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_PENDING_CANCEL", VALUEFUNC(_wrap_TrdRptStatus_PENDING_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_PENDING_REPLACE", VALUEFUNC(_wrap_TrdRptStatus_PENDING_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_TERMINATED", VALUEFUNC(_wrap_TrdRptStatus_TERMINATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_PENDING_VERIFICATION", VALUEFUNC(_wrap_TrdRptStatus_PENDING_VERIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_DEEMED_VERIFIED", VALUEFUNC(_wrap_TrdRptStatus_DEEMED_VERIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_VERIFIED", VALUEFUNC(_wrap_TrdRptStatus_VERIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_DISPUTED", VALUEFUNC(_wrap_TrdRptStatus_DISPUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_RECEIVED", VALUEFUNC(_wrap_AffirmStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_CONFIRM_REJECTED", VALUEFUNC(_wrap_AffirmStatus_CONFIRM_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_AFFIRMED", VALUEFUNC(_wrap_AffirmStatus_AFFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_RETAIN", VALUEFUNC(_wrap_CollAction_RETAIN_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_ADD", VALUEFUNC(_wrap_CollAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_REMOVE", VALUEFUNC(_wrap_CollAction_REMOVE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_ACCEPTED", VALUEFUNC(_wrap_CollInquiryStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_ACCEPTED_WITH_WARNINGS", VALUEFUNC(_wrap_CollInquiryStatus_ACCEPTED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_COMPLETED", VALUEFUNC(_wrap_CollInquiryStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_CollInquiryStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_REJECTED", VALUEFUNC(_wrap_CollInquiryStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_SUCCESSFUL", VALUEFUNC(_wrap_CollInquiryResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE", VALUEFUNC(_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_PARTIES", VALUEFUNC(_wrap_CollInquiryResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED", VALUEFUNC(_wrap_CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_DESTINATION_REQUESTED", VALUEFUNC(_wrap_CollInquiryResult_INVALID_DESTINATION_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED", VALUEFUNC(_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED", VALUEFUNC(_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED", VALUEFUNC(_wrap_CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY", VALUEFUNC(_wrap_CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_OTHER", VALUEFUNC(_wrap_CollInquiryResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_INT", VALUEFUNC(_wrap_StrategyParameterType_INT_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_LENGTH", VALUEFUNC(_wrap_StrategyParameterType_LENGTH_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_NUM_IN_GROUP", VALUEFUNC(_wrap_StrategyParameterType_NUM_IN_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_SEQ_NUM", VALUEFUNC(_wrap_StrategyParameterType_SEQ_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_TAG_NUM", VALUEFUNC(_wrap_StrategyParameterType_TAG_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_FLOAT", VALUEFUNC(_wrap_StrategyParameterType_FLOAT_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_QTY", VALUEFUNC(_wrap_StrategyParameterType_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_PRICE", VALUEFUNC(_wrap_StrategyParameterType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_PRICE_OFFSET", VALUEFUNC(_wrap_StrategyParameterType_PRICE_OFFSET_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_AMT", VALUEFUNC(_wrap_StrategyParameterType_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_PERCENTAGE", VALUEFUNC(_wrap_StrategyParameterType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_CHAR", VALUEFUNC(_wrap_StrategyParameterType_CHAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_BOOLEAN", VALUEFUNC(_wrap_StrategyParameterType_BOOLEAN_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_STRING", VALUEFUNC(_wrap_StrategyParameterType_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_MULTIPLE_CHAR_VALUE", VALUEFUNC(_wrap_StrategyParameterType_MULTIPLE_CHAR_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_CURRENCY", VALUEFUNC(_wrap_StrategyParameterType_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_EXCHANGE", VALUEFUNC(_wrap_StrategyParameterType_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_MONTH_YEAR", VALUEFUNC(_wrap_StrategyParameterType_MONTH_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_UTC_TIMESTAMP", VALUEFUNC(_wrap_StrategyParameterType_UTC_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_UTC_TIME_ONLY", VALUEFUNC(_wrap_StrategyParameterType_UTC_TIME_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_LOCAL_MKT_DATE", VALUEFUNC(_wrap_StrategyParameterType_LOCAL_MKT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_UTC_DATE_ONLY", VALUEFUNC(_wrap_StrategyParameterType_UTC_DATE_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_DATA", VALUEFUNC(_wrap_StrategyParameterType_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_MULTIPLE_STRING_VALUE", VALUEFUNC(_wrap_StrategyParameterType_MULTIPLE_STRING_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_COUNTRY", VALUEFUNC(_wrap_StrategyParameterType_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_LANGUAGE", VALUEFUNC(_wrap_StrategyParameterType_LANGUAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_TZ_TIME_ONLY", VALUEFUNC(_wrap_StrategyParameterType_TZ_TIME_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_TZ_TIMESTAMP", VALUEFUNC(_wrap_StrategyParameterType_TZ_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyParameterType_TENOR", VALUEFUNC(_wrap_StrategyParameterType_TENOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_ACTIVE", VALUEFUNC(_wrap_SecurityStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_INACTIVE", VALUEFUNC(_wrap_SecurityStatus_INACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_ACTIVE_CLOSING_ORDERS_ONLY", VALUEFUNC(_wrap_SecurityStatus_ACTIVE_CLOSING_ORDERS_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_EXPIRED", VALUEFUNC(_wrap_SecurityStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_DELISTED", VALUEFUNC(_wrap_SecurityStatus_DELISTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_KNOCKED_OUT", VALUEFUNC(_wrap_SecurityStatus_KNOCKED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_KNOCK_OUT_REVOKED", VALUEFUNC(_wrap_SecurityStatus_KNOCK_OUT_REVOKED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_PENDING_EXPIRY", VALUEFUNC(_wrap_SecurityStatus_PENDING_EXPIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_SUSPENDED", VALUEFUNC(_wrap_SecurityStatus_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_PUBLISHED", VALUEFUNC(_wrap_SecurityStatus_PUBLISHED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityStatus_PENDING_DELETION", VALUEFUNC(_wrap_SecurityStatus_PENDING_DELETION_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingCashType_FIXED", VALUEFUNC(_wrap_UnderlyingCashType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingCashType_DIFF", VALUEFUNC(_wrap_UnderlyingCashType_DIFF_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingSettlementType_T_PLUS1", VALUEFUNC(_wrap_UnderlyingSettlementType_T_PLUS1_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingSettlementType_T_PLUS3", VALUEFUNC(_wrap_UnderlyingSettlementType_T_PLUS3_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingSettlementType_T_PLUS4", VALUEFUNC(_wrap_UnderlyingSettlementType_T_PLUS4_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityUpdateAction_ADD", VALUEFUNC(_wrap_SecurityUpdateAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityUpdateAction_DELETE", VALUEFUNC(_wrap_SecurityUpdateAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityUpdateAction_MODIFY", VALUEFUNC(_wrap_SecurityUpdateAction_MODIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpType_AUTO_EXERCISE", VALUEFUNC(_wrap_ExpType_AUTO_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpType_NON_AUTO_EXERCISE", VALUEFUNC(_wrap_ExpType_NON_AUTO_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpType_FINAL_WILL_BE_EXERCISED", VALUEFUNC(_wrap_ExpType_FINAL_WILL_BE_EXERCISED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpType_CONTRARY_INTENTION", VALUEFUNC(_wrap_ExpType_CONTRARY_INTENTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpType_DIFFERENCE", VALUEFUNC(_wrap_ExpType_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "IndividualAllocType_SUB_ALLOCATE", VALUEFUNC(_wrap_IndividualAllocType_SUB_ALLOCATE_get), 0);
  rb_define_singleton_method(mQuickfix, "IndividualAllocType_THIRD_PARTY_ALLOCATION", VALUEFUNC(_wrap_IndividualAllocType_THIRD_PARTY_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_BARRELS", VALUEFUNC(_wrap_UnitofMeasure_BARRELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_BILLION_CUBIC_FEET", VALUEFUNC(_wrap_UnitofMeasure_BILLION_CUBIC_FEET_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_BUSHELS", VALUEFUNC(_wrap_UnitofMeasure_BUSHELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_POUNDS", VALUEFUNC(_wrap_UnitofMeasure_POUNDS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_GALLONS", VALUEFUNC(_wrap_UnitofMeasure_GALLONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_MILLION_BARRELS", VALUEFUNC(_wrap_UnitofMeasure_MILLION_BARRELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_ONE_MILLION_BTU", VALUEFUNC(_wrap_UnitofMeasure_ONE_MILLION_BTU_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_MEGAWATT_HOURS", VALUEFUNC(_wrap_UnitofMeasure_MEGAWATT_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_TROY_OUNCES", VALUEFUNC(_wrap_UnitofMeasure_TROY_OUNCES_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_METRIC_TONS", VALUEFUNC(_wrap_UnitofMeasure_METRIC_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_TONS", VALUEFUNC(_wrap_UnitofMeasure_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitofMeasure_US_DOLLARS", VALUEFUNC(_wrap_UnitofMeasure_US_DOLLARS_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_HOUR", VALUEFUNC(_wrap_TimeUnit_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_MINUTE", VALUEFUNC(_wrap_TimeUnit_MINUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_SECOND", VALUEFUNC(_wrap_TimeUnit_SECOND_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_DAY", VALUEFUNC(_wrap_TimeUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_WEEK", VALUEFUNC(_wrap_TimeUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_MONTH", VALUEFUNC(_wrap_TimeUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_YEAR", VALUEFUNC(_wrap_TimeUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeUnit_QUARTER", VALUEFUNC(_wrap_TimeUnit_QUARTER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocMethod_AUTOMATIC", VALUEFUNC(_wrap_AllocMethod_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocMethod_GUARANTOR", VALUEFUNC(_wrap_AllocMethod_GUARANTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocMethod_MANUAL", VALUEFUNC(_wrap_AllocMethod_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocMethod_BROKER_ASSIGNED", VALUEFUNC(_wrap_AllocMethod_BROKER_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "AsOfIndicator_FALSE", VALUEFUNC(_wrap_AsOfIndicator_FALSE_get), 0);
  rb_define_singleton_method(mQuickfix, "AsOfIndicator_TRUE", VALUEFUNC(_wrap_AsOfIndicator_TRUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDBookType_TOP_OF_BOOK", VALUEFUNC(_wrap_MDBookType_TOP_OF_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDBookType_PRICE_DEPTH", VALUEFUNC(_wrap_MDBookType_PRICE_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDBookType_ORDER_DEPTH", VALUEFUNC(_wrap_MDBookType_ORDER_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_BOOK", VALUEFUNC(_wrap_MDOriginType_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_OFF_BOOK", VALUEFUNC(_wrap_MDOriginType_OFF_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_CROSS", VALUEFUNC(_wrap_MDOriginType_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_QUOTE_DRIVEN_MARKET", VALUEFUNC(_wrap_MDOriginType_QUOTE_DRIVEN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_DARK_ORDER_BOOK", VALUEFUNC(_wrap_MDOriginType_DARK_ORDER_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_AUCTION_DRIVEN_MARKET", VALUEFUNC(_wrap_MDOriginType_AUCTION_DRIVEN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_QUOTE_NEGOTIATION", VALUEFUNC(_wrap_MDOriginType_QUOTE_NEGOTIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_VOICE_NEGOTIATION", VALUEFUNC(_wrap_MDOriginType_VOICE_NEGOTIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDOriginType_HYBRID_MARKET", VALUEFUNC(_wrap_MDOriginType_HYBRID_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_ADD_ON_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_ADD_ON_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_ALL_OR_NONE", VALUEFUNC(_wrap_CustOrderHandlingInst_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CASH_NOT_HELD", VALUEFUNC(_wrap_CustOrderHandlingInst_CASH_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DIRECTED_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_DIRECTED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION", VALUEFUNC(_wrap_CustOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_FILL_OR_KILL", VALUEFUNC(_wrap_CustOrderHandlingInst_FILL_OR_KILL_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_IMBALANCE_ONLY", VALUEFUNC(_wrap_CustOrderHandlingInst_IMBALANCE_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_IMMEDIATE_OR_CANCEL", VALUEFUNC(_wrap_CustOrderHandlingInst_IMMEDIATE_OR_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_LIMIT_ON_OPEN", VALUEFUNC(_wrap_CustOrderHandlingInst_LIMIT_ON_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_LIMIT_ON_CLOSE", VALUEFUNC(_wrap_CustOrderHandlingInst_LIMIT_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_AT_OPEN", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_AT_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_AT_CLOSE", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_AT_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_ON_OPEN", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_ON_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_ON_CLOSE", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MINIMUM_QUANTITY", VALUEFUNC(_wrap_CustOrderHandlingInst_MINIMUM_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_NOT_HELD", VALUEFUNC(_wrap_CustOrderHandlingInst_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_OVER_THE_DAY", VALUEFUNC(_wrap_CustOrderHandlingInst_OVER_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PEGGED", VALUEFUNC(_wrap_CustOrderHandlingInst_PEGGED_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_RESERVE_SIZE_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_RESERVE_SIZE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_STOP_STOCK_TRANSACTION", VALUEFUNC(_wrap_CustOrderHandlingInst_STOP_STOCK_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_SCALE", VALUEFUNC(_wrap_CustOrderHandlingInst_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_TIME_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_TIME_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_TRAILING_STOP", VALUEFUNC(_wrap_CustOrderHandlingInst_TRAILING_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_WORK", VALUEFUNC(_wrap_CustOrderHandlingInst_WORK_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PHONE_SIMPLE", VALUEFUNC(_wrap_CustOrderHandlingInst_PHONE_SIMPLE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PHONE_COMPLEX", VALUEFUNC(_wrap_CustOrderHandlingInst_PHONE_COMPLEX_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_FCM_PROVIDED_SCREEN", VALUEFUNC(_wrap_CustOrderHandlingInst_FCM_PROVIDED_SCREEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_OTHER_PROVIDED_SCREEN", VALUEFUNC(_wrap_CustOrderHandlingInst_OTHER_PROVIDED_SCREEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_CONTROLLED_BY_FCM", VALUEFUNC(_wrap_CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_CONTROLLED_BY_FCM_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_DIRECT_TO_EXCHANGE", VALUEFUNC(_wrap_CustOrderHandlingInst_CLIENT_PROVIDED_PLATFORM_DIRECT_TO_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_ALGO_ENGINE", VALUEFUNC(_wrap_CustOrderHandlingInst_ALGO_ENGINE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PRICE_AT_EXECUTION", VALUEFUNC(_wrap_CustOrderHandlingInst_PRICE_AT_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DESK_ELECTRONIC", VALUEFUNC(_wrap_CustOrderHandlingInst_DESK_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DESK_PIT", VALUEFUNC(_wrap_CustOrderHandlingInst_DESK_PIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CLIENT_ELECTRONIC", VALUEFUNC(_wrap_CustOrderHandlingInst_CLIENT_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CLIENT_PIT", VALUEFUNC(_wrap_CustOrderHandlingInst_CLIENT_PIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CONDITIONAL_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_CONDITIONAL_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_CASH", VALUEFUNC(_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DISCRETIONARY_LIMIT_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_DISCRETIONARY_LIMIT_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_INTRA_DAY_CROSS", VALUEFUNC(_wrap_CustOrderHandlingInst_INTRA_DAY_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_INTERMARKET_SWEEP_ORDER", VALUEFUNC(_wrap_CustOrderHandlingInst_INTERMARKET_SWEEP_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MERGER_RELATED_TRANSFER_POSITION", VALUEFUNC(_wrap_CustOrderHandlingInst_MERGER_RELATED_TRANSFER_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_TO_LIMIT", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_TO_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_NEXT_DAY", VALUEFUNC(_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_OPTIONS_RELATED_TRANSACTION", VALUEFUNC(_wrap_CustOrderHandlingInst_OPTIONS_RELATED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_SELLERS_OPTION", VALUEFUNC(_wrap_CustOrderHandlingInst_DELIVERY_INSTRUCTIONS_SELLERS_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_STAY_ON_OFFERSIDE", VALUEFUNC(_wrap_CustOrderHandlingInst_STAY_ON_OFFERSIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_GO_ALONG", VALUEFUNC(_wrap_CustOrderHandlingInst_GO_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PARTICIPATE_DO_NOT_INITIATE", VALUEFUNC(_wrap_CustOrderHandlingInst_PARTICIPATE_DO_NOT_INITIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_STRICT_SCALE", VALUEFUNC(_wrap_CustOrderHandlingInst_STRICT_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_TRY_TO_SCALE", VALUEFUNC(_wrap_CustOrderHandlingInst_TRY_TO_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_STAY_ON_BIDSIDE", VALUEFUNC(_wrap_CustOrderHandlingInst_STAY_ON_BIDSIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_NO_CROSS", VALUEFUNC(_wrap_CustOrderHandlingInst_NO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_OK_TO_CROSS", VALUEFUNC(_wrap_CustOrderHandlingInst_OK_TO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CALL_FIRST", VALUEFUNC(_wrap_CustOrderHandlingInst_CALL_FIRST_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PERCENT_OF_VOLUME", VALUEFUNC(_wrap_CustOrderHandlingInst_PERCENT_OF_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_REINSTATE_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_CustOrderHandlingInst_REINSTATE_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_INSTITUTION_ONLY", VALUEFUNC(_wrap_CustOrderHandlingInst_INSTITUTION_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_REINSTATE_ON_TRADING_HALT", VALUEFUNC(_wrap_CustOrderHandlingInst_REINSTATE_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CANCEL_ON_TRADING_HALF", VALUEFUNC(_wrap_CustOrderHandlingInst_CANCEL_ON_TRADING_HALF_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_LAST_PEG", VALUEFUNC(_wrap_CustOrderHandlingInst_LAST_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MID_PRICE_PEG", VALUEFUNC(_wrap_CustOrderHandlingInst_MID_PRICE_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_NON_NEGOTIABLE", VALUEFUNC(_wrap_CustOrderHandlingInst_NON_NEGOTIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_OPENING_PEG", VALUEFUNC(_wrap_CustOrderHandlingInst_OPENING_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_MARKET_PEG", VALUEFUNC(_wrap_CustOrderHandlingInst_MARKET_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CANCEL_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_CustOrderHandlingInst_CANCEL_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PRIMARY_PEG", VALUEFUNC(_wrap_CustOrderHandlingInst_PRIMARY_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_SUSPEND", VALUEFUNC(_wrap_CustOrderHandlingInst_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_FIXED_PEG_TO_LOCAL_BBO", VALUEFUNC(_wrap_CustOrderHandlingInst_FIXED_PEG_TO_LOCAL_BBO_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PEG_TO_VWAP", VALUEFUNC(_wrap_CustOrderHandlingInst_PEG_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_TRADE_ALONG", VALUEFUNC(_wrap_CustOrderHandlingInst_TRADE_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_TRY_TO_STOP", VALUEFUNC(_wrap_CustOrderHandlingInst_TRY_TO_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_CANCEL_IF_NOT_BEST", VALUEFUNC(_wrap_CustOrderHandlingInst_CANCEL_IF_NOT_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_STRICT_LIMIT", VALUEFUNC(_wrap_CustOrderHandlingInst_STRICT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_IGNORE_PRICE_VALIDITY_CHECKS", VALUEFUNC(_wrap_CustOrderHandlingInst_IGNORE_PRICE_VALIDITY_CHECKS_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_PEG_TO_LIMIT_PRICE", VALUEFUNC(_wrap_CustOrderHandlingInst_PEG_TO_LIMIT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_WORK_TO_TARGET_STRATEGY", VALUEFUNC(_wrap_CustOrderHandlingInst_WORK_TO_TARGET_STRATEGY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderHandlingInst_G_ORDER_AND_FCMAP_IOR_FIX", VALUEFUNC(_wrap_CustOrderHandlingInst_G_ORDER_AND_FCMAP_IOR_FIX_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderHandlingInstSource_NASDOATS", VALUEFUNC(_wrap_OrderHandlingInstSource_NASDOATS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderHandlingInstSource_FINRAOATS", VALUEFUNC(_wrap_OrderHandlingInstSource_FINRAOATS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderHandlingInstSource_FIA_EXECUTION_SOURCE_CODE", VALUEFUNC(_wrap_OrderHandlingInstSource_FIA_EXECUTION_SOURCE_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_AGENCY", VALUEFUNC(_wrap_DeskType_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_ARBITRAGE", VALUEFUNC(_wrap_DeskType_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_DERIVATIVES", VALUEFUNC(_wrap_DeskType_DERIVATIVES_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_INTERNATIONAL", VALUEFUNC(_wrap_DeskType_INTERNATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_INSTITUTIONAL", VALUEFUNC(_wrap_DeskType_INSTITUTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_OTHER", VALUEFUNC(_wrap_DeskType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_PREFERRED_TRADING", VALUEFUNC(_wrap_DeskType_PREFERRED_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_PROPRIETARY", VALUEFUNC(_wrap_DeskType_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_PROGRAM_TRADING", VALUEFUNC(_wrap_DeskType_PROGRAM_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_SALES", VALUEFUNC(_wrap_DeskType_SALES_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_TRADING", VALUEFUNC(_wrap_DeskType_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_BLOCK_TRADING", VALUEFUNC(_wrap_DeskType_BLOCK_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_CONVERTIBLE_DESK", VALUEFUNC(_wrap_DeskType_CONVERTIBLE_DESK_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_CENTRAL_RISK_BOOKS", VALUEFUNC(_wrap_DeskType_CENTRAL_RISK_BOOKS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_EQUITY_CAPITAL_MARKETS", VALUEFUNC(_wrap_DeskType_EQUITY_CAPITAL_MARKETS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_SWAPS", VALUEFUNC(_wrap_DeskType_SWAPS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_TRADING_DESK_SYSTEM", VALUEFUNC(_wrap_DeskType_TRADING_DESK_SYSTEM_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_TREASURY", VALUEFUNC(_wrap_DeskType_TREASURY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskType_FLOOR_BROKER", VALUEFUNC(_wrap_DeskType_FLOOR_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskTypeSource_NASDOATS", VALUEFUNC(_wrap_DeskTypeSource_NASDOATS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskTypeSource_FINRAOATS", VALUEFUNC(_wrap_DeskTypeSource_FINRAOATS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_ADD_ON_ORDER", VALUEFUNC(_wrap_DeskOrderHandlingInst_ADD_ON_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_ALL_OR_NONE", VALUEFUNC(_wrap_DeskOrderHandlingInst_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_CASH_NOT_HELD", VALUEFUNC(_wrap_DeskOrderHandlingInst_CASH_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_DIRECTED_ORDER", VALUEFUNC(_wrap_DeskOrderHandlingInst_DIRECTED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION", VALUEFUNC(_wrap_DeskOrderHandlingInst_EXCHANGE_FOR_PHYSICAL_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_FILL_OR_KILL", VALUEFUNC(_wrap_DeskOrderHandlingInst_FILL_OR_KILL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_IMBALANCE_ONLY", VALUEFUNC(_wrap_DeskOrderHandlingInst_IMBALANCE_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_IMMEDIATE_OR_CANCEL", VALUEFUNC(_wrap_DeskOrderHandlingInst_IMMEDIATE_OR_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_LIMIT_ON_OPEN", VALUEFUNC(_wrap_DeskOrderHandlingInst_LIMIT_ON_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_LIMIT_ON_CLOSE", VALUEFUNC(_wrap_DeskOrderHandlingInst_LIMIT_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_MARKET_AT_OPEN", VALUEFUNC(_wrap_DeskOrderHandlingInst_MARKET_AT_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_MARKET_AT_CLOSE", VALUEFUNC(_wrap_DeskOrderHandlingInst_MARKET_AT_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_MARKET_ON_OPEN", VALUEFUNC(_wrap_DeskOrderHandlingInst_MARKET_ON_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_MARKET_ON_CLOSE", VALUEFUNC(_wrap_DeskOrderHandlingInst_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_MINIMUM_QUANTITY", VALUEFUNC(_wrap_DeskOrderHandlingInst_MINIMUM_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_NOT_HELD", VALUEFUNC(_wrap_DeskOrderHandlingInst_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_OVER_THE_DAY", VALUEFUNC(_wrap_DeskOrderHandlingInst_OVER_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_PEGGED", VALUEFUNC(_wrap_DeskOrderHandlingInst_PEGGED_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_RESERVE_SIZE_ORDER", VALUEFUNC(_wrap_DeskOrderHandlingInst_RESERVE_SIZE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_STOP_STOCK_TRANSACTION", VALUEFUNC(_wrap_DeskOrderHandlingInst_STOP_STOCK_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_SCALE", VALUEFUNC(_wrap_DeskOrderHandlingInst_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_TIME_ORDER", VALUEFUNC(_wrap_DeskOrderHandlingInst_TIME_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_TRAILING_STOP", VALUEFUNC(_wrap_DeskOrderHandlingInst_TRAILING_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "DeskOrderHandlingInst_WORK", VALUEFUNC(_wrap_DeskOrderHandlingInst_WORK_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecAckStatus_RECEIVED", VALUEFUNC(_wrap_ExecAckStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecAckStatus_ACCEPTED", VALUEFUNC(_wrap_ExecAckStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecAckStatus_DON", VALUEFUNC(_wrap_ExecAckStatus_DON_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecAckStatus_DONT_KNOW", VALUEFUNC(_wrap_ExecAckStatus_DONT_KNOW_get), 0);
  rb_define_singleton_method(mQuickfix, "CollApplType_SPECIFIC_DEPOSIT", VALUEFUNC(_wrap_CollApplType_SPECIFIC_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollApplType_GENERAL", VALUEFUNC(_wrap_CollApplType_GENERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingFXRateCalc_DIVIDE", VALUEFUNC(_wrap_UnderlyingFXRateCalc_DIVIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingFXRateCalc_MULTIPLY", VALUEFUNC(_wrap_UnderlyingFXRateCalc_MULTIPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocPositionEffect_OPEN", VALUEFUNC(_wrap_AllocPositionEffect_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocPositionEffect_CLOSE", VALUEFUNC(_wrap_AllocPositionEffect_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocPositionEffect_ROLLED", VALUEFUNC(_wrap_AllocPositionEffect_ROLLED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocPositionEffect_FIFO", VALUEFUNC(_wrap_AllocPositionEffect_FIFO_get), 0);
  rb_define_singleton_method(mQuickfix, "DealingCapacity_AGENT", VALUEFUNC(_wrap_DealingCapacity_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "DealingCapacity_PRINCIPAL", VALUEFUNC(_wrap_DealingCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DealingCapacity_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_DealingCapacity_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrmtAssignmentMethod_RANDOM", VALUEFUNC(_wrap_InstrmtAssignmentMethod_RANDOM_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrmtAssignmentMethod_PRO_RATA", VALUEFUNC(_wrap_InstrmtAssignmentMethod_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "AggressorIndicator_YES", VALUEFUNC(_wrap_AggressorIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "AggressorIndicator_NO", VALUEFUNC(_wrap_AggressorIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "MDQuoteType_INDICATIVE", VALUEFUNC(_wrap_MDQuoteType_INDICATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDQuoteType_TRADEABLE", VALUEFUNC(_wrap_MDQuoteType_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDQuoteType_RESTRICTED_TRADEABLE", VALUEFUNC(_wrap_MDQuoteType_RESTRICTED_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDQuoteType_COUNTER", VALUEFUNC(_wrap_MDQuoteType_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDQuoteType_INDICATIVE_AND_TRADEABLE", VALUEFUNC(_wrap_MDQuoteType_INDICATIVE_AND_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_SECONDARY_ORDER_ID", VALUEFUNC(_wrap_RefOrderIDSource_SECONDARY_ORDER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_ORDER_ID", VALUEFUNC(_wrap_RefOrderIDSource_ORDER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_MD_ENTRY_ID", VALUEFUNC(_wrap_RefOrderIDSource_MD_ENTRY_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_QUOTE_ENTRY_ID", VALUEFUNC(_wrap_RefOrderIDSource_QUOTE_ENTRY_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_ORIGINAL_ORDER_ID", VALUEFUNC(_wrap_RefOrderIDSource_ORIGINAL_ORDER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_QUOTE_ID", VALUEFUNC(_wrap_RefOrderIDSource_QUOTE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_QUOTE_REQ_ID", VALUEFUNC(_wrap_RefOrderIDSource_QUOTE_REQ_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_PREVIOUS_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RefOrderIDSource_PREVIOUS_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_PREVIOUS_QUOTE_IDENTIFIER", VALUEFUNC(_wrap_RefOrderIDSource_PREVIOUS_QUOTE_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_PARENT_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RefOrderIDSource_PARENT_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrderIDSource_MANUAL_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RefOrderIDSource_MANUAL_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayWhen_IMMEDIATE", VALUEFUNC(_wrap_DisplayWhen_IMMEDIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayWhen_EXHAUST", VALUEFUNC(_wrap_DisplayWhen_EXHAUST_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayMethod_INITIAL", VALUEFUNC(_wrap_DisplayMethod_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayMethod_NEW", VALUEFUNC(_wrap_DisplayMethod_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayMethod_RANDOM", VALUEFUNC(_wrap_DisplayMethod_RANDOM_get), 0);
  rb_define_singleton_method(mQuickfix, "DisplayMethod_UNDISCLOSED", VALUEFUNC(_wrap_DisplayMethod_UNDISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceProtectionScope_NONE", VALUEFUNC(_wrap_PriceProtectionScope_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceProtectionScope_LOCAL", VALUEFUNC(_wrap_PriceProtectionScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceProtectionScope_NATIONAL", VALUEFUNC(_wrap_PriceProtectionScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceProtectionScope_GLOBAL", VALUEFUNC(_wrap_PriceProtectionScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "LotType_ODD_LOT", VALUEFUNC(_wrap_LotType_ODD_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "LotType_ROUND_LOT", VALUEFUNC(_wrap_LotType_ROUND_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "LotType_BLOCK_LOT", VALUEFUNC(_wrap_LotType_BLOCK_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "LotType_ROUND_LOT_BASED_UPON", VALUEFUNC(_wrap_LotType_ROUND_LOT_BASED_UPON_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_LAST_PEG", VALUEFUNC(_wrap_PegPriceType_LAST_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_MID_PRICE_PEG", VALUEFUNC(_wrap_PegPriceType_MID_PRICE_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_OPENING_PEG", VALUEFUNC(_wrap_PegPriceType_OPENING_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_MARKET_PEG", VALUEFUNC(_wrap_PegPriceType_MARKET_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_PRIMARY_PEG", VALUEFUNC(_wrap_PegPriceType_PRIMARY_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER", VALUEFUNC(_wrap_PegPriceType_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_PEG_TO_VWAP", VALUEFUNC(_wrap_PegPriceType_PEG_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_TRAILING_STOP_PEG", VALUEFUNC(_wrap_PegPriceType_TRAILING_STOP_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_PEG_TO_LIMIT_PRICE", VALUEFUNC(_wrap_PegPriceType_PEG_TO_LIMIT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegPriceType_SHORT_SALE_MIN_PRICE_PEG", VALUEFUNC(_wrap_PegPriceType_SHORT_SALE_MIN_PRICE_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerType_PARTIAL_EXECUTION", VALUEFUNC(_wrap_TriggerType_PARTIAL_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerType_SPECIFIED_TRADING_SESSION", VALUEFUNC(_wrap_TriggerType_SPECIFIED_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerType_NEXT_AUCTION", VALUEFUNC(_wrap_TriggerType_NEXT_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerType_PRICE_MOVEMENT", VALUEFUNC(_wrap_TriggerType_PRICE_MOVEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerType_ON_ORDER_ENTRY_OR_MODIFICATION", VALUEFUNC(_wrap_TriggerType_ON_ORDER_ENTRY_OR_MODIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerAction_ACTIVATE", VALUEFUNC(_wrap_TriggerAction_ACTIVATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerAction_MODIFY", VALUEFUNC(_wrap_TriggerAction_MODIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerAction_CANCEL", VALUEFUNC(_wrap_TriggerAction_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_BEST_OFFER", VALUEFUNC(_wrap_TriggerPriceType_BEST_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_LAST_TRADE", VALUEFUNC(_wrap_TriggerPriceType_LAST_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_BEST_BID", VALUEFUNC(_wrap_TriggerPriceType_BEST_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_BEST_BID_OR_LAST_TRADE", VALUEFUNC(_wrap_TriggerPriceType_BEST_BID_OR_LAST_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_BEST_OFFER_OR_LAST_TRADE", VALUEFUNC(_wrap_TriggerPriceType_BEST_OFFER_OR_LAST_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceType_BEST_MID", VALUEFUNC(_wrap_TriggerPriceType_BEST_MID_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceTypeScope_NONE", VALUEFUNC(_wrap_TriggerPriceTypeScope_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceTypeScope_LOCAL", VALUEFUNC(_wrap_TriggerPriceTypeScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceTypeScope_NATIONAL", VALUEFUNC(_wrap_TriggerPriceTypeScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceTypeScope_GLOBAL", VALUEFUNC(_wrap_TriggerPriceTypeScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceDirection_UP", VALUEFUNC(_wrap_TriggerPriceDirection_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerPriceDirection_DOWN", VALUEFUNC(_wrap_TriggerPriceDirection_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerOrderType_MARKET", VALUEFUNC(_wrap_TriggerOrderType_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerOrderType_LIMIT", VALUEFUNC(_wrap_TriggerOrderType_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_ORDER", VALUEFUNC(_wrap_OrderCategory_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_QUOTE", VALUEFUNC(_wrap_OrderCategory_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_PRIVATELY_NEGOTIATED_TRADE", VALUEFUNC(_wrap_OrderCategory_PRIVATELY_NEGOTIATED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_MULTILEG_ORDER", VALUEFUNC(_wrap_OrderCategory_MULTILEG_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_LINKED_ORDER", VALUEFUNC(_wrap_OrderCategory_LINKED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_QUOTE_REQUEST", VALUEFUNC(_wrap_OrderCategory_QUOTE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_IMPLIED_ORDER", VALUEFUNC(_wrap_OrderCategory_IMPLIED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_CROSS_ORDER", VALUEFUNC(_wrap_OrderCategory_CROSS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_STREAMING_PRICE", VALUEFUNC(_wrap_OrderCategory_STREAMING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCategory_INTERNAL_CROSS_ORDER", VALUEFUNC(_wrap_OrderCategory_INTERNAL_CROSS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_TRADE_CONFIRMATION", VALUEFUNC(_wrap_TradeHandlingInstr_TRADE_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_TWO_PARTY_REPORT", VALUEFUNC(_wrap_TradeHandlingInstr_TWO_PARTY_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_ONE_PARTY_REPORT_FOR_MATCHING", VALUEFUNC(_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_FOR_MATCHING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_ONE_PARTY_REPORT_FOR_PASS_THROUGH", VALUEFUNC(_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_FOR_PASS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_AUTOMATED_FLOOR_ORDER_ROUTING", VALUEFUNC(_wrap_TradeHandlingInstr_AUTOMATED_FLOOR_ORDER_ROUTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_TWO_PARTY_REPORT_FOR_CLAIM", VALUEFUNC(_wrap_TradeHandlingInstr_TWO_PARTY_REPORT_FOR_CLAIM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_ONE_PARTY_REPORT", VALUEFUNC(_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_THIRD_PTY_RPT_FOR_PASS_THROUGH", VALUEFUNC(_wrap_TradeHandlingInstr_THIRD_PTY_RPT_FOR_PASS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeHandlingInstr_ONE_PARTY_REPORT_AUTO_MATCH", VALUEFUNC(_wrap_TradeHandlingInstr_ONE_PARTY_REPORT_AUTO_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationIDSource_BIC", VALUEFUNC(_wrap_ExDestinationIDSource_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationIDSource_GENERAL_IDENTIFIER", VALUEFUNC(_wrap_ExDestinationIDSource_GENERAL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationIDSource_PROPRIETARY", VALUEFUNC(_wrap_ExDestinationIDSource_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationIDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_ExDestinationIDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationIDSource_MIC", VALUEFUNC(_wrap_ExDestinationIDSource_MIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationQtyType_AUTO_EXERCISE", VALUEFUNC(_wrap_ExpirationQtyType_AUTO_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationQtyType_NON_AUTO_EXERCISE", VALUEFUNC(_wrap_ExpirationQtyType_NON_AUTO_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationQtyType_FINAL_WILL_BE_EXERCISED", VALUEFUNC(_wrap_ExpirationQtyType_FINAL_WILL_BE_EXERCISED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationQtyType_CONTRARY_INTENTION", VALUEFUNC(_wrap_ExpirationQtyType_CONTRARY_INTENTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationQtyType_DIFFERENCE", VALUEFUNC(_wrap_ExpirationQtyType_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_BILLION_CUBIC_FEET", VALUEFUNC(_wrap_UnitOfMeasure_BILLION_CUBIC_FEET_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MILLION_BARRELS", VALUEFUNC(_wrap_UnitOfMeasure_MILLION_BARRELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ONE_MILLION_BTU", VALUEFUNC(_wrap_UnitOfMeasure_ONE_MILLION_BTU_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_HOURS", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_BARRELS", VALUEFUNC(_wrap_UnitOfMeasure_BARRELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_BUSHELS", VALUEFUNC(_wrap_UnitOfMeasure_BUSHELS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_POUNDS", VALUEFUNC(_wrap_UnitOfMeasure_POUNDS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GALLONS", VALUEFUNC(_wrap_UnitOfMeasure_GALLONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_TROY_OUNCES", VALUEFUNC(_wrap_UnitOfMeasure_TROY_OUNCES_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_METRIC_TONS", VALUEFUNC(_wrap_UnitOfMeasure_METRIC_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_TONS", VALUEFUNC(_wrap_UnitOfMeasure_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_US_DOLLARS", VALUEFUNC(_wrap_UnitOfMeasure_US_DOLLARS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CUBIC_METERS", VALUEFUNC(_wrap_UnitOfMeasure_CUBIC_METERS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GIGAJOULES", VALUEFUNC(_wrap_UnitOfMeasure_GIGAJOULES_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_HEAT_RATE", VALUEFUNC(_wrap_UnitOfMeasure_HEAT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_HOURS", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGA_HEAT_RATE", VALUEFUNC(_wrap_UnitOfMeasure_MEGA_HEAT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_THERMS", VALUEFUNC(_wrap_UnitOfMeasure_THERMS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_TONS_OF_CARBON_DIOXIDE", VALUEFUNC(_wrap_UnitOfMeasure_TONS_OF_CARBON_DIOXIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ALLOWANCES", VALUEFUNC(_wrap_UnitOfMeasure_ALLOWANCES_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_BOARD_FEET", VALUEFUNC(_wrap_UnitOfMeasure_BOARD_FEET_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CURRENCY", VALUEFUNC(_wrap_UnitOfMeasure_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_COOLING_DEGREE_DAY", VALUEFUNC(_wrap_UnitOfMeasure_COOLING_DEGREE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CERTIFIED_EMISSIONS_REDUCTION", VALUEFUNC(_wrap_UnitOfMeasure_CERTIFIED_EMISSIONS_REDUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CRITICAL_PRECIP_DAY", VALUEFUNC(_wrap_UnitOfMeasure_CRITICAL_PRECIP_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CLIMATE_RESERVE_TONNES", VALUEFUNC(_wrap_UnitOfMeasure_CLIMATE_RESERVE_TONNES_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_HUNDREDWEIGHT", VALUEFUNC(_wrap_UnitOfMeasure_HUNDREDWEIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_DAY", VALUEFUNC(_wrap_UnitOfMeasure_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_DRY_METRIC_TONS", VALUEFUNC(_wrap_UnitOfMeasure_DRY_METRIC_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ENV_ALLWNC_CERT", VALUEFUNC(_wrap_UnitOfMeasure_ENV_ALLWNC_CERT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ENVIRONMENTAL_CREDIT", VALUEFUNC(_wrap_UnitOfMeasure_ENVIRONMENTAL_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ENVIRONMENTAL_OFFSET", VALUEFUNC(_wrap_UnitOfMeasure_ENVIRONMENTAL_OFFSET_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GRAMS", VALUEFUNC(_wrap_UnitOfMeasure_GRAMS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GROSS_TONS", VALUEFUNC(_wrap_UnitOfMeasure_GROSS_TONS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_HEATING_DEGREE_DAY", VALUEFUNC(_wrap_UnitOfMeasure_HEATING_DEGREE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_INDEX_POINT", VALUEFUNC(_wrap_UnitOfMeasure_INDEX_POINT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOGRAMS", VALUEFUNC(_wrap_UnitOfMeasure_KILOGRAMS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOLITERS", VALUEFUNC(_wrap_UnitOfMeasure_KILOLITERS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_YEAR", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_DAY", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_HOUR", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_MONTH", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOWATT_MINUTE", VALUEFUNC(_wrap_UnitOfMeasure_KILOWATT_MINUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_LITERS", VALUEFUNC(_wrap_UnitOfMeasure_LITERS_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_YEAR", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_DAY", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_HOUR", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_MONTH", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MEGAWATT_MINUTE", VALUEFUNC(_wrap_UnitOfMeasure_MEGAWATT_MINUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_PRINCIPAL_WITH_RELATION_TO_DEBT_INSTRUMENT", VALUEFUNC(_wrap_UnitOfMeasure_PRINCIPAL_WITH_RELATION_TO_DEBT_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ARE", VALUEFUNC(_wrap_UnitOfMeasure_ARE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_ACRE", VALUEFUNC(_wrap_UnitOfMeasure_ACRE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CENTILITER", VALUEFUNC(_wrap_UnitOfMeasure_CENTILITER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_CENTIMETER", VALUEFUNC(_wrap_UnitOfMeasure_CENTIMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_DIESEL_GALLON_EQUIVALENT", VALUEFUNC(_wrap_UnitOfMeasure_DIESEL_GALLON_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_FOOT", VALUEFUNC(_wrap_UnitOfMeasure_FOOT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GB_GALLON", VALUEFUNC(_wrap_UnitOfMeasure_GB_GALLON_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GASOLINE_GALLON_EQUIVALENT", VALUEFUNC(_wrap_UnitOfMeasure_GASOLINE_GALLON_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_HECTARE", VALUEFUNC(_wrap_UnitOfMeasure_HECTARE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_INCH", VALUEFUNC(_wrap_UnitOfMeasure_INCH_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_KILOMETER", VALUEFUNC(_wrap_UnitOfMeasure_KILOMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_METER", VALUEFUNC(_wrap_UnitOfMeasure_METER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MILE", VALUEFUNC(_wrap_UnitOfMeasure_MILE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MILLILITER", VALUEFUNC(_wrap_UnitOfMeasure_MILLILITER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_MILLIMETER", VALUEFUNC(_wrap_UnitOfMeasure_MILLIMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_US_OUNCE", VALUEFUNC(_wrap_UnitOfMeasure_US_OUNCE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_PIECE", VALUEFUNC(_wrap_UnitOfMeasure_PIECE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_US_PINT", VALUEFUNC(_wrap_UnitOfMeasure_US_PINT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GB_PINT", VALUEFUNC(_wrap_UnitOfMeasure_GB_PINT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_US_QUART", VALUEFUNC(_wrap_UnitOfMeasure_US_QUART_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_GB_QUART", VALUEFUNC(_wrap_UnitOfMeasure_GB_QUART_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_CENTIMETER", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_CENTIMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_FOOT", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_FOOT_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_INCH", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_INCH_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_KILOMETER", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_KILOMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_METER", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_METER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_MILE", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_MILE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_MILLIMETER", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_MILLIMETER_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_SQUARE_YARD", VALUEFUNC(_wrap_UnitOfMeasure_SQUARE_YARD_get), 0);
  rb_define_singleton_method(mQuickfix, "UnitOfMeasure_YARD", VALUEFUNC(_wrap_UnitOfMeasure_YARD_get), 0);
  rb_define_singleton_method(mQuickfix, "ImpliedMarketIndicator_NOT_IMPLIED", VALUEFUNC(_wrap_ImpliedMarketIndicator_NOT_IMPLIED_get), 0);
  rb_define_singleton_method(mQuickfix, "ImpliedMarketIndicator_IMPLIED_IN", VALUEFUNC(_wrap_ImpliedMarketIndicator_IMPLIED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ImpliedMarketIndicator_IMPLIED_OUT", VALUEFUNC(_wrap_ImpliedMarketIndicator_IMPLIED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ImpliedMarketIndicator_BOTH_IMPLIED_IN_AND_IMPLIED_OUT", VALUEFUNC(_wrap_ImpliedMarketIndicator_BOTH_IMPLIED_IN_AND_IMPLIED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligMode_PRELIMINARY", VALUEFUNC(_wrap_SettlObligMode_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligMode_FINAL", VALUEFUNC(_wrap_SettlObligMode_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligTransType_CANCEL", VALUEFUNC(_wrap_SettlObligTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligTransType_NEW", VALUEFUNC(_wrap_SettlObligTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligTransType_REPLACE", VALUEFUNC(_wrap_SettlObligTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligTransType_RESTATE", VALUEFUNC(_wrap_SettlObligTransType_RESTATE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligSource_INSTRUCTIONS_OF_BROKER", VALUEFUNC(_wrap_SettlObligSource_INSTRUCTIONS_OF_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligSource_INSTRUCTIONS_FOR_INSTITUTION", VALUEFUNC(_wrap_SettlObligSource_INSTRUCTIONS_FOR_INSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligSource_INVESTOR", VALUEFUNC(_wrap_SettlObligSource_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligSource_BUYERS_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_SettlObligSource_BUYERS_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlObligSource_SELLERS_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_SettlObligSource_SELLERS_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_ACCEPTED", VALUEFUNC(_wrap_QuoteEntryStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_REJECTED", VALUEFUNC(_wrap_QuoteEntryStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_REMOVED_FROM_MARKET", VALUEFUNC(_wrap_QuoteEntryStatus_REMOVED_FROM_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_EXPIRED", VALUEFUNC(_wrap_QuoteEntryStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_LOCKED_MARKET_WARNING", VALUEFUNC(_wrap_QuoteEntryStatus_LOCKED_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_CROSS_MARKET_WARNING", VALUEFUNC(_wrap_QuoteEntryStatus_CROSS_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_CANCELED_DUE_TO_LOCK_MARKET", VALUEFUNC(_wrap_QuoteEntryStatus_CANCELED_DUE_TO_LOCK_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_CANCELED_DUE_TO_CROSS_MARKET", VALUEFUNC(_wrap_QuoteEntryStatus_CANCELED_DUE_TO_CROSS_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryStatus_ACTIVE", VALUEFUNC(_wrap_QuoteEntryStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PrivateQuote_YES", VALUEFUNC(_wrap_PrivateQuote_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "PrivateQuote_NO", VALUEFUNC(_wrap_PrivateQuote_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "RespondentType_ALL_MARKET_PARTICIPANTS", VALUEFUNC(_wrap_RespondentType_ALL_MARKET_PARTICIPANTS_get), 0);
  rb_define_singleton_method(mQuickfix, "RespondentType_SPECIFIED_MARKET_PARTICIPANTS", VALUEFUNC(_wrap_RespondentType_SPECIFIED_MARKET_PARTICIPANTS_get), 0);
  rb_define_singleton_method(mQuickfix, "RespondentType_ALL_MARKET_MAKERS", VALUEFUNC(_wrap_RespondentType_ALL_MARKET_MAKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "RespondentType_PRIMARY_MARKET_MAKER", VALUEFUNC(_wrap_RespondentType_PRIMARY_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_ORDER_IMBALANCE", VALUEFUNC(_wrap_SecurityTradingEvent_ORDER_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_TRADING_RESUMES", VALUEFUNC(_wrap_SecurityTradingEvent_TRADING_RESUMES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_PRICE_VOLATILITY_INTERRUPTION", VALUEFUNC(_wrap_SecurityTradingEvent_PRICE_VOLATILITY_INTERRUPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CHANGE_OF_TRADING_SESSION", VALUEFUNC(_wrap_SecurityTradingEvent_CHANGE_OF_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CHANGE_OF_TRADING_SUBSESSION", VALUEFUNC(_wrap_SecurityTradingEvent_CHANGE_OF_TRADING_SUBSESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CHANGE_OF_SECURITY_TRADING_STATUS", VALUEFUNC(_wrap_SecurityTradingEvent_CHANGE_OF_SECURITY_TRADING_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CHANGE_OF_BOOK_TYPE", VALUEFUNC(_wrap_SecurityTradingEvent_CHANGE_OF_BOOK_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CHANGE_OF_MARKET_DEPTH", VALUEFUNC(_wrap_SecurityTradingEvent_CHANGE_OF_MARKET_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingEvent_CORPORATE_ACTION", VALUEFUNC(_wrap_SecurityTradingEvent_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StatsType_EXCHANGE_LAST", VALUEFUNC(_wrap_StatsType_EXCHANGE_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "StatsType_HIGH", VALUEFUNC(_wrap_StatsType_HIGH_get), 0);
  rb_define_singleton_method(mQuickfix, "StatsType_AVERAGE_PRICE", VALUEFUNC(_wrap_StatsType_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "StatsType_TURNOVER", VALUEFUNC(_wrap_StatsType_TURNOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDSecSizeType_CUSTOMER", VALUEFUNC(_wrap_MDSecSizeType_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDSecSizeType_CUSTOMER_PROFESSIONAL", VALUEFUNC(_wrap_MDSecSizeType_CUSTOMER_PROFESSIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDSecSizeType_DO_NOT_TRADE_THROUGH", VALUEFUNC(_wrap_MDSecSizeType_DO_NOT_TRADE_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlMethod_CASH_SETTLEMENT_REQUIRED", VALUEFUNC(_wrap_SettlMethod_CASH_SETTLEMENT_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlMethod_PHYSICAL_SETTLEMENT_REQUIRED", VALUEFUNC(_wrap_SettlMethod_PHYSICAL_SETTLEMENT_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlMethod_ELECTION", VALUEFUNC(_wrap_SettlMethod_ELECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseStyle_EUROPEAN", VALUEFUNC(_wrap_ExerciseStyle_EUROPEAN_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseStyle_AMERICAN", VALUEFUNC(_wrap_ExerciseStyle_AMERICAN_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseStyle_BERMUDA", VALUEFUNC(_wrap_ExerciseStyle_BERMUDA_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseStyle_OTHER", VALUEFUNC(_wrap_ExerciseStyle_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQuoteMethod_STANDARD", VALUEFUNC(_wrap_PriceQuoteMethod_STANDARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQuoteMethod_INDEX", VALUEFUNC(_wrap_PriceQuoteMethod_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQuoteMethod_INTEREST_RATE_INDEX", VALUEFUNC(_wrap_PriceQuoteMethod_INTEREST_RATE_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQuoteMethod_PERCENT_OF_PAR", VALUEFUNC(_wrap_PriceQuoteMethod_PERCENT_OF_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "FuturesValuationMethod_PREMIUM_STYLE", VALUEFUNC(_wrap_FuturesValuationMethod_PREMIUM_STYLE_get), 0);
  rb_define_singleton_method(mQuickfix, "FuturesValuationMethod_FUTURES_STYLE_MARK_TO_MARKET", VALUEFUNC(_wrap_FuturesValuationMethod_FUTURES_STYLE_MARK_TO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "FuturesValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT", VALUEFUNC(_wrap_FuturesValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListMethod_PRE_LISTED_ONLY", VALUEFUNC(_wrap_ListMethod_PRE_LISTED_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ListMethod_USER_REQUESTED", VALUEFUNC(_wrap_ListMethod_USER_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_REGULAR", VALUEFUNC(_wrap_TickRuleType_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_VARIABLE", VALUEFUNC(_wrap_TickRuleType_VARIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_FIXED", VALUEFUNC(_wrap_TickRuleType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_TRADED_AS_A_SPREAD_LEG", VALUEFUNC(_wrap_TickRuleType_TRADED_AS_A_SPREAD_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_SETTLED_AS_A_SPREAD_LEG", VALUEFUNC(_wrap_TickRuleType_SETTLED_AS_A_SPREAD_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_REGULAR_TRADING", VALUEFUNC(_wrap_TickRuleType_REGULAR_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_VARIABLE_CABINET", VALUEFUNC(_wrap_TickRuleType_VARIABLE_CABINET_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_FIXED_CABINET", VALUEFUNC(_wrap_TickRuleType_FIXED_CABINET_get), 0);
  rb_define_singleton_method(mQuickfix, "TickRuleType_TRADED_AS_SPREAD", VALUEFUNC(_wrap_TickRuleType_TRADED_AS_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearIncrementUnits_MONTHS", VALUEFUNC(_wrap_MaturityMonthYearIncrementUnits_MONTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearIncrementUnits_DAYS", VALUEFUNC(_wrap_MaturityMonthYearIncrementUnits_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearIncrementUnits_WEEKS", VALUEFUNC(_wrap_MaturityMonthYearIncrementUnits_WEEKS_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearIncrementUnits_YEARS", VALUEFUNC(_wrap_MaturityMonthYearIncrementUnits_YEARS_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearFormat_YEAR_MONTH_ONLY", VALUEFUNC(_wrap_MaturityMonthYearFormat_YEAR_MONTH_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearFormat_YEAR_MONTH_DAY", VALUEFUNC(_wrap_MaturityMonthYearFormat_YEAR_MONTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "MaturityMonthYearFormat_YEAR_MONTH_WEEK", VALUEFUNC(_wrap_MaturityMonthYearFormat_YEAR_MONTH_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceLimitType_PRICE", VALUEFUNC(_wrap_PriceLimitType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceLimitType_TICKS", VALUEFUNC(_wrap_PriceLimitType_TICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceLimitType_PERCENTAGE", VALUEFUNC(_wrap_PriceLimitType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListUpdateAction_ADD", VALUEFUNC(_wrap_ListUpdateAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "ListUpdateAction_DELETE", VALUEFUNC(_wrap_ListUpdateAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListUpdateAction_MODIFY", VALUEFUNC(_wrap_ListUpdateAction_MODIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "ListUpdateAction_SNAPSHOT", VALUEFUNC(_wrap_ListUpdateAction_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketUpdateAction_ADD", VALUEFUNC(_wrap_MarketUpdateAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketUpdateAction_DELETE", VALUEFUNC(_wrap_MarketUpdateAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketUpdateAction_MODIFY", VALUEFUNC(_wrap_MarketUpdateAction_MODIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesEvent_TRADING_RESUMES", VALUEFUNC(_wrap_TradSesEvent_TRADING_RESUMES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesEvent_CHANGE_OF_TRADING_SESSION", VALUEFUNC(_wrap_TradSesEvent_CHANGE_OF_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesEvent_CHANGE_OF_TRADING_SUBSESSION", VALUEFUNC(_wrap_TradSesEvent_CHANGE_OF_TRADING_SUBSESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesEvent_CHANGE_OF_TRADING_STATUS", VALUEFUNC(_wrap_TradSesEvent_CHANGE_OF_TRADING_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionType_SUSPEND_ORDERS", VALUEFUNC(_wrap_MassActionType_SUSPEND_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionType_RELEASE_ORDERS_FROM_SUSPENSION", VALUEFUNC(_wrap_MassActionType_RELEASE_ORDERS_FROM_SUSPENSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionType_CANCEL_ORDERS", VALUEFUNC(_wrap_MassActionType_CANCEL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_ACFI_CODE", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_ACFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_SECURITY_TYPE", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_MARKET", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_MARKET_SEGMENT", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_ALL_ORDERS_FOR_A_SECURITY_GROUP", VALUEFUNC(_wrap_MassActionScope_ALL_ORDERS_FOR_A_SECURITY_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_CANCEL_FOR_SECURITY_ISSUER", VALUEFUNC(_wrap_MassActionScope_CANCEL_FOR_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionScope_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassActionScope_CANCEL_FOR_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionResponse_REJECTED", VALUEFUNC(_wrap_MassActionResponse_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionResponse_ACCEPTED", VALUEFUNC(_wrap_MassActionResponse_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionResponse_COMPLETED", VALUEFUNC(_wrap_MassActionResponse_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_MASS_ACTION_NOT_SUPPORTED", VALUEFUNC(_wrap_MassActionRejectReason_MASS_ACTION_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_PRODUCT", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_CFI_CODE", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_CFI_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_SEGMENT", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_OTHER", VALUEFUNC(_wrap_MassActionRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_SECURITY_ISSUER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassActionRejectReason_INVALID_OR_UNKNOWN_ISSUER_OF_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegModel_PREDEFINED_MULTILEG_SECURITY", VALUEFUNC(_wrap_MultilegModel_PREDEFINED_MULTILEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegModel_USER_DEFINED_MULTILEG_SECURITY", VALUEFUNC(_wrap_MultilegModel_USER_DEFINED_MULTILEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegModel_USER_DEFINED", VALUEFUNC(_wrap_MultilegModel_USER_DEFINED_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_NET_PRICE", VALUEFUNC(_wrap_MultilegPriceMethod_NET_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_REVERSED_NET_PRICE", VALUEFUNC(_wrap_MultilegPriceMethod_REVERSED_NET_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_YIELD_DIFFERENCE", VALUEFUNC(_wrap_MultilegPriceMethod_YIELD_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_INDIVIDUAL", VALUEFUNC(_wrap_MultilegPriceMethod_INDIVIDUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_CONTRACT_WEIGHTED_AVERAGE_PRICE", VALUEFUNC(_wrap_MultilegPriceMethod_CONTRACT_WEIGHTED_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MultilegPriceMethod_MULTIPLIED_PRICE", VALUEFUNC(_wrap_MultilegPriceMethod_MULTIPLIED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_ONE_CANCELS_THE_OTHER", VALUEFUNC(_wrap_ContingencyType_ONE_CANCELS_THE_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_ONE_TRIGGERS_THE_OTHER", VALUEFUNC(_wrap_ContingencyType_ONE_TRIGGERS_THE_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_ONE_UPDATES_THE_OTHER_ABSOLUTE", VALUEFUNC(_wrap_ContingencyType_ONE_UPDATES_THE_OTHER_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_ONE_UPDATES_THE_OTHER_PROPORTIONAL", VALUEFUNC(_wrap_ContingencyType_ONE_UPDATES_THE_OTHER_PROPORTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_BID_AND_OFFER", VALUEFUNC(_wrap_ContingencyType_BID_AND_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "ContingencyType_BID_AND_OFFER_OCO", VALUEFUNC(_wrap_ContingencyType_BID_AND_OFFER_OCO_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_BROKER_CREDIT", VALUEFUNC(_wrap_ListRejectReason_BROKER_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_ListRejectReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_ListRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_UNKNOWN_ORDER", VALUEFUNC(_wrap_ListRejectReason_UNKNOWN_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_DUPLICATE_ORDER", VALUEFUNC(_wrap_ListRejectReason_DUPLICATE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_UNSUPPORTED_ORDER_CHARACTERISTIC", VALUEFUNC(_wrap_ListRejectReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ListRejectReason_OTHER", VALUEFUNC(_wrap_ListRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePublishIndicator_DO_NOT_PUBLISH_TRADE", VALUEFUNC(_wrap_TradePublishIndicator_DO_NOT_PUBLISH_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePublishIndicator_PUBLISH_TRADE", VALUEFUNC(_wrap_TradePublishIndicator_PUBLISH_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePublishIndicator_DEFERRED_PUBLICATION", VALUEFUNC(_wrap_TradePublishIndicator_DEFERRED_PUBLICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePublishIndicator_PUBLISHED", VALUEFUNC(_wrap_TradePublishIndicator_PUBLISHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_RETRANSMISSION", VALUEFUNC(_wrap_ApplReqType_RETRANSMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_SUBSCRIPTION", VALUEFUNC(_wrap_ApplReqType_SUBSCRIPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_REQUEST_LAST_SEQ_NUM", VALUEFUNC(_wrap_ApplReqType_REQUEST_LAST_SEQ_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_REQUEST_APPLICATIONS", VALUEFUNC(_wrap_ApplReqType_REQUEST_APPLICATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_UNSUBSCRIBE", VALUEFUNC(_wrap_ApplReqType_UNSUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_CANCEL_RETRANSMISSION", VALUEFUNC(_wrap_ApplReqType_CANCEL_RETRANSMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReqType_CANCEL_RETRANSMISSION_UNSUBSCRIBE", VALUEFUNC(_wrap_ApplReqType_CANCEL_RETRANSMISSION_UNSUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseType_REQUEST_SUCCESSFULLY_PROCESSED", VALUEFUNC(_wrap_ApplResponseType_REQUEST_SUCCESSFULLY_PROCESSED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseType_APPLICATION_DOES_NOT_EXIST", VALUEFUNC(_wrap_ApplResponseType_APPLICATION_DOES_NOT_EXIST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseType_MESSAGES_NOT_AVAILABLE", VALUEFUNC(_wrap_ApplResponseType_MESSAGES_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseError_APPLICATION_DOES_NOT_EXIST", VALUEFUNC(_wrap_ApplResponseError_APPLICATION_DOES_NOT_EXIST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseError_MESSAGES_REQUESTED_ARE_NOT_AVAILABLE", VALUEFUNC(_wrap_ApplResponseError_MESSAGES_REQUESTED_ARE_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplResponseError_USER_NOT_AUTHORIZED_FOR_APPLICATION", VALUEFUNC(_wrap_ApplResponseError_USER_NOT_AUTHORIZED_FOR_APPLICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReportType_APPL_SEQ_NUM_RESET", VALUEFUNC(_wrap_ApplReportType_APPL_SEQ_NUM_RESET_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReportType_LAST_MESSAGE_SENT", VALUEFUNC(_wrap_ApplReportType_LAST_MESSAGE_SENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReportType_APPLICATION_ALIVE", VALUEFUNC(_wrap_ApplReportType_APPLICATION_ALIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplReportType_RESEND_COMPLETE", VALUEFUNC(_wrap_ApplReportType_RESEND_COMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_NEWS_DISSEMINATION", VALUEFUNC(_wrap_HaltReasonInt_NEWS_DISSEMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_ORDER_INFLUX", VALUEFUNC(_wrap_HaltReasonInt_ORDER_INFLUX_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_ORDER_IMBALANCE", VALUEFUNC(_wrap_HaltReasonInt_ORDER_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_ADDITIONAL_INFORMATION", VALUEFUNC(_wrap_HaltReasonInt_ADDITIONAL_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_NEWS_PENDING", VALUEFUNC(_wrap_HaltReasonInt_NEWS_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReasonInt_EQUIPMENT_CHANGEOVER", VALUEFUNC(_wrap_HaltReasonInt_EQUIPMENT_CHANGEOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "ValuationMethod_PREMIUM_STYLE", VALUEFUNC(_wrap_ValuationMethod_PREMIUM_STYLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ValuationMethod_FUTURES_STYLE_MARK_TO_MARKET", VALUEFUNC(_wrap_ValuationMethod_FUTURES_STYLE_MARK_TO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "ValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT", VALUEFUNC(_wrap_ValuationMethod_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ValuationMethod_CDS_STYLE_COLLATERALIZATION", VALUEFUNC(_wrap_ValuationMethod_CDS_STYLE_COLLATERALIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ValuationMethod_CDS_IN_DELIVERY_USE_RECOVERY_RATE_TO_CALCULATE", VALUEFUNC(_wrap_ValuationMethod_CDS_IN_DELIVERY_USE_RECOVERY_RATE_TO_CALCULATE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_SECONDS", VALUEFUNC(_wrap_OrderDelayUnit_SECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_TENTHS_OF_A_SECOND", VALUEFUNC(_wrap_OrderDelayUnit_TENTHS_OF_A_SECOND_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_HUNDREDTHS_OF_A_SECOND", VALUEFUNC(_wrap_OrderDelayUnit_HUNDREDTHS_OF_A_SECOND_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_MILLISECONDS", VALUEFUNC(_wrap_OrderDelayUnit_MILLISECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_MICROSECONDS", VALUEFUNC(_wrap_OrderDelayUnit_MICROSECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_NANOSECONDS", VALUEFUNC(_wrap_OrderDelayUnit_NANOSECONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_MINUTES", VALUEFUNC(_wrap_OrderDelayUnit_MINUTES_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_HOURS", VALUEFUNC(_wrap_OrderDelayUnit_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_DAYS", VALUEFUNC(_wrap_OrderDelayUnit_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_WEEKS", VALUEFUNC(_wrap_OrderDelayUnit_WEEKS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_MONTHS", VALUEFUNC(_wrap_OrderDelayUnit_MONTHS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderDelayUnit_YEARS", VALUEFUNC(_wrap_OrderDelayUnit_YEARS_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_ELECTRONIC", VALUEFUNC(_wrap_VenueType_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_PIT", VALUEFUNC(_wrap_VenueType_PIT_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_EX_PIT", VALUEFUNC(_wrap_VenueType_EX_PIT_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_CLEARING_HOUSE", VALUEFUNC(_wrap_VenueType_CLEARING_HOUSE_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_REGISTERED_MARKET", VALUEFUNC(_wrap_VenueType_REGISTERED_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_OFF_MARKET", VALUEFUNC(_wrap_VenueType_OFF_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_CENTRAL_LIMIT_ORDER_BOOK", VALUEFUNC(_wrap_VenueType_CENTRAL_LIMIT_ORDER_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_QUOTE_DRIVEN_MARKET", VALUEFUNC(_wrap_VenueType_QUOTE_DRIVEN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_DARK_ORDER_BOOK", VALUEFUNC(_wrap_VenueType_DARK_ORDER_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_AUCTION_DRIVEN_MARKET", VALUEFUNC(_wrap_VenueType_AUCTION_DRIVEN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_QUOTE_NEGOTIATION", VALUEFUNC(_wrap_VenueType_QUOTE_NEGOTIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_VOICE_NEGOTIATION", VALUEFUNC(_wrap_VenueType_VOICE_NEGOTIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_HYBRID_MARKET", VALUEFUNC(_wrap_VenueType_HYBRID_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "VenueType_OTHER_MARKET", VALUEFUNC(_wrap_VenueType_OTHER_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrdIDReason_GTC_FROM_PREVIOUS_DAY", VALUEFUNC(_wrap_RefOrdIDReason_GTC_FROM_PREVIOUS_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrdIDReason_PARTIAL_FILL_REMAINING", VALUEFUNC(_wrap_RefOrdIDReason_PARTIAL_FILL_REMAINING_get), 0);
  rb_define_singleton_method(mQuickfix, "RefOrdIDReason_ORDER_CHANGED", VALUEFUNC(_wrap_RefOrdIDReason_ORDER_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrigCustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT", VALUEFUNC(_wrap_OrigCustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrigCustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT", VALUEFUNC(_wrap_OrigCustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrigCustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER", VALUEFUNC(_wrap_OrigCustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrigCustOrderCapacity_ALL_OTHER", VALUEFUNC(_wrap_OrigCustOrderCapacity_ALL_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ModelType_UTILITY_PROVIDED_STANDARD_MODEL", VALUEFUNC(_wrap_ModelType_UTILITY_PROVIDED_STANDARD_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ModelType_PROPRIETARY_MODEL", VALUEFUNC(_wrap_ModelType_PROPRIETARY_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractMultiplierUnit_SHARES", VALUEFUNC(_wrap_ContractMultiplierUnit_SHARES_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractMultiplierUnit_HOURS", VALUEFUNC(_wrap_ContractMultiplierUnit_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractMultiplierUnit_DAYS", VALUEFUNC(_wrap_ContractMultiplierUnit_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_NERC_EASTERN_OFF_PEAK", VALUEFUNC(_wrap_FlowScheduleType_NERC_EASTERN_OFF_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_NERC_WESTERN_OFF_PEAK", VALUEFUNC(_wrap_FlowScheduleType_NERC_WESTERN_OFF_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_NERC_CALENDAR_ALL_DAYS_IN_MONTH", VALUEFUNC(_wrap_FlowScheduleType_NERC_CALENDAR_ALL_DAYS_IN_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_NERC_EASTERN_PEAK", VALUEFUNC(_wrap_FlowScheduleType_NERC_EASTERN_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_NERC_WESTERN_PEAK", VALUEFUNC(_wrap_FlowScheduleType_NERC_WESTERN_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_ALL_TIMES", VALUEFUNC(_wrap_FlowScheduleType_ALL_TIMES_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_ON_PEAK", VALUEFUNC(_wrap_FlowScheduleType_ON_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_OFF_PEAK", VALUEFUNC(_wrap_FlowScheduleType_OFF_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_BASE", VALUEFUNC(_wrap_FlowScheduleType_BASE_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_BLOCK", VALUEFUNC(_wrap_FlowScheduleType_BLOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "FlowScheduleType_OTHER", VALUEFUNC(_wrap_FlowScheduleType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSource_BLOOMBERG", VALUEFUNC(_wrap_RateSource_BLOOMBERG_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSource_REUTERS", VALUEFUNC(_wrap_RateSource_REUTERS_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSource_TELERATE", VALUEFUNC(_wrap_RateSource_TELERATE_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSource_ISDA_RATE_OPTION", VALUEFUNC(_wrap_RateSource_ISDA_RATE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSource_OTHER", VALUEFUNC(_wrap_RateSource_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSourceType_PRIMARY", VALUEFUNC(_wrap_RateSourceType_PRIMARY_get), 0);
  rb_define_singleton_method(mQuickfix, "RateSourceType_SECONDARY", VALUEFUNC(_wrap_RateSourceType_SECONDARY_get), 0);
  rb_define_singleton_method(mQuickfix, "RestructuringType_FULL_RESTRUCTURING", VALUEFUNC(_wrap_RestructuringType_FULL_RESTRUCTURING_get), 0);
  rb_define_singleton_method(mQuickfix, "RestructuringType_MODIFIED_RESTRUCTURING", VALUEFUNC(_wrap_RestructuringType_MODIFIED_RESTRUCTURING_get), 0);
  rb_define_singleton_method(mQuickfix, "RestructuringType_MODIFIED_MOD_RESTRUCTURING", VALUEFUNC(_wrap_RestructuringType_MODIFIED_MOD_RESTRUCTURING_get), 0);
  rb_define_singleton_method(mQuickfix, "RestructuringType_NO_RESTRUCTURING_SPECIFIED", VALUEFUNC(_wrap_RestructuringType_NO_RESTRUCTURING_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_SENIOR_SECURED", VALUEFUNC(_wrap_Seniority_SENIOR_SECURED_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_SENIOR", VALUEFUNC(_wrap_Seniority_SENIOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_SUBORDINATED", VALUEFUNC(_wrap_Seniority_SUBORDINATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_JUNIOR", VALUEFUNC(_wrap_Seniority_JUNIOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_MEZZANINE", VALUEFUNC(_wrap_Seniority_MEZZANINE_get), 0);
  rb_define_singleton_method(mQuickfix, "Seniority_SENIOR_NON_PREFERRED", VALUEFUNC(_wrap_Seniority_SENIOR_NON_PREFERRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListType_INDUSTRY_CLASSIFICATION", VALUEFUNC(_wrap_SecurityListType_INDUSTRY_CLASSIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListType_TRADING_LIST", VALUEFUNC(_wrap_SecurityListType_TRADING_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListType_MARKET", VALUEFUNC(_wrap_SecurityListType_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListType_NEWSPAPER_LIST", VALUEFUNC(_wrap_SecurityListType_NEWSPAPER_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListTypeSource_ICB", VALUEFUNC(_wrap_SecurityListTypeSource_ICB_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListTypeSource_NAICS", VALUEFUNC(_wrap_SecurityListTypeSource_NAICS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListTypeSource_GICS", VALUEFUNC(_wrap_SecurityListTypeSource_GICS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsCategory_COMPANY_NEWS", VALUEFUNC(_wrap_NewsCategory_COMPANY_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsCategory_MARKETPLACE_NEWS", VALUEFUNC(_wrap_NewsCategory_MARKETPLACE_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsCategory_FINANCIAL_MARKET_NEWS", VALUEFUNC(_wrap_NewsCategory_FINANCIAL_MARKET_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsCategory_TECHNICAL_NEWS", VALUEFUNC(_wrap_NewsCategory_TECHNICAL_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsCategory_OTHER_NEWS", VALUEFUNC(_wrap_NewsCategory_OTHER_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsRefType_REPLACEMENT", VALUEFUNC(_wrap_NewsRefType_REPLACEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsRefType_OTHER_LANGUAGE", VALUEFUNC(_wrap_NewsRefType_OTHER_LANGUAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsRefType_COMPLIMENTARY", VALUEFUNC(_wrap_NewsRefType_COMPLIMENTARY_get), 0);
  rb_define_singleton_method(mQuickfix, "NewsRefType_WITHDRAWAL", VALUEFUNC(_wrap_NewsRefType_WITHDRAWAL_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceDeterminationMethod_FIXED_STRIKE", VALUEFUNC(_wrap_StrikePriceDeterminationMethod_FIXED_STRIKE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceDeterminationMethod_STRIKE_SET_AT_EXPIRATION", VALUEFUNC(_wrap_StrikePriceDeterminationMethod_STRIKE_SET_AT_EXPIRATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceDeterminationMethod_STRIKE_SET_TO_AVERAGE_ACROSS_LIFE", VALUEFUNC(_wrap_StrikePriceDeterminationMethod_STRIKE_SET_TO_AVERAGE_ACROSS_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceDeterminationMethod_STRIKE_SET_TO_OPTIMAL_VALUE", VALUEFUNC(_wrap_StrikePriceDeterminationMethod_STRIKE_SET_TO_OPTIMAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceBoundaryMethod_LESS_THAN", VALUEFUNC(_wrap_StrikePriceBoundaryMethod_LESS_THAN_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceBoundaryMethod_LESS_THAN_OR_EQUAL", VALUEFUNC(_wrap_StrikePriceBoundaryMethod_LESS_THAN_OR_EQUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceBoundaryMethod_EQUAL", VALUEFUNC(_wrap_StrikePriceBoundaryMethod_EQUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceBoundaryMethod_GREATER_THAN_OR_EQUAL", VALUEFUNC(_wrap_StrikePriceBoundaryMethod_GREATER_THAN_OR_EQUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikePriceBoundaryMethod_GREATER_THAN", VALUEFUNC(_wrap_StrikePriceBoundaryMethod_GREATER_THAN_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingPriceDeterminationMethod_REGULAR", VALUEFUNC(_wrap_UnderlyingPriceDeterminationMethod_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingPriceDeterminationMethod_SPECIAL_REFERENCE", VALUEFUNC(_wrap_UnderlyingPriceDeterminationMethod_SPECIAL_REFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingPriceDeterminationMethod_OPTIMAL_VALUE", VALUEFUNC(_wrap_UnderlyingPriceDeterminationMethod_OPTIMAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingPriceDeterminationMethod_AVERAGE_VALUE", VALUEFUNC(_wrap_UnderlyingPriceDeterminationMethod_AVERAGE_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_VANILLA", VALUEFUNC(_wrap_OptPayoutType_VANILLA_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_CAPPED", VALUEFUNC(_wrap_OptPayoutType_CAPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_BINARY", VALUEFUNC(_wrap_OptPayoutType_BINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_ASIAN", VALUEFUNC(_wrap_OptPayoutType_ASIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_BARRIER", VALUEFUNC(_wrap_OptPayoutType_BARRIER_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_DIGITAL_BARRIER", VALUEFUNC(_wrap_OptPayoutType_DIGITAL_BARRIER_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_LOOKBACK", VALUEFUNC(_wrap_OptPayoutType_LOOKBACK_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_OTHER_PATH_DEPENDENT", VALUEFUNC(_wrap_OptPayoutType_OTHER_PATH_DEPENDENT_get), 0);
  rb_define_singleton_method(mQuickfix, "OptPayoutType_OTHER", VALUEFUNC(_wrap_OptPayoutType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_CAPPED", VALUEFUNC(_wrap_ComplexEventType_CAPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_TRIGGER", VALUEFUNC(_wrap_ComplexEventType_TRIGGER_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_KNOCK_IN_UP", VALUEFUNC(_wrap_ComplexEventType_KNOCK_IN_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_KNOCK_IN_DOWN", VALUEFUNC(_wrap_ComplexEventType_KNOCK_IN_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_KNOCK_OUT_UP", VALUEFUNC(_wrap_ComplexEventType_KNOCK_OUT_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_KNOCK_OUT_DOWN", VALUEFUNC(_wrap_ComplexEventType_KNOCK_OUT_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_UNDERLYING", VALUEFUNC(_wrap_ComplexEventType_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_RESET_BARRIER", VALUEFUNC(_wrap_ComplexEventType_RESET_BARRIER_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_ROLLING_BARRIER", VALUEFUNC(_wrap_ComplexEventType_ROLLING_BARRIER_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_ONE_TOUCH", VALUEFUNC(_wrap_ComplexEventType_ONE_TOUCH_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_NO_TOUCH", VALUEFUNC(_wrap_ComplexEventType_NO_TOUCH_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_DBL_ONE_TOUCH", VALUEFUNC(_wrap_ComplexEventType_DBL_ONE_TOUCH_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_DBL_NO_TOUCH", VALUEFUNC(_wrap_ComplexEventType_DBL_NO_TOUCH_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_FX_COMPOSITE", VALUEFUNC(_wrap_ComplexEventType_FX_COMPOSITE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_FX_QUANTO", VALUEFUNC(_wrap_ComplexEventType_FX_QUANTO_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_FX_CRSS_CCY", VALUEFUNC(_wrap_ComplexEventType_FX_CRSS_CCY_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_STRK_SPREAD", VALUEFUNC(_wrap_ComplexEventType_STRK_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_CLNDR_SPREAD", VALUEFUNC(_wrap_ComplexEventType_CLNDR_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_PX_OBSVTN", VALUEFUNC(_wrap_ComplexEventType_PX_OBSVTN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_PASS_THROUGH", VALUEFUNC(_wrap_ComplexEventType_PASS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_STRK_SCHED", VALUEFUNC(_wrap_ComplexEventType_STRK_SCHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_EQUITY_VALUATION", VALUEFUNC(_wrap_ComplexEventType_EQUITY_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventType_DIVIDEND_VALUATION", VALUEFUNC(_wrap_ComplexEventType_DIVIDEND_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceBoundaryMethod_LESS_THAN_COMPLEX_EVENT_PRICE", VALUEFUNC(_wrap_ComplexEventPriceBoundaryMethod_LESS_THAN_COMPLEX_EVENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceBoundaryMethod_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE", VALUEFUNC(_wrap_ComplexEventPriceBoundaryMethod_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceBoundaryMethod_EQUAL_TO_COMPLEX_EVENT_PRICE", VALUEFUNC(_wrap_ComplexEventPriceBoundaryMethod_EQUAL_TO_COMPLEX_EVENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceBoundaryMethod_GREATER_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE", VALUEFUNC(_wrap_ComplexEventPriceBoundaryMethod_GREATER_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceBoundaryMethod_GREATER_THAN_COMPLEX_EVENT_PRICE", VALUEFUNC(_wrap_ComplexEventPriceBoundaryMethod_GREATER_THAN_COMPLEX_EVENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_EXPIRATION", VALUEFUNC(_wrap_ComplexEventPriceTimeType_EXPIRATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_IMMEDIATE", VALUEFUNC(_wrap_ComplexEventPriceTimeType_IMMEDIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_SPECIFIED_DATE", VALUEFUNC(_wrap_ComplexEventPriceTimeType_SPECIFIED_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_CLOSE", VALUEFUNC(_wrap_ComplexEventPriceTimeType_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_OPEN", VALUEFUNC(_wrap_ComplexEventPriceTimeType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_OFFICIAL_SETTL_PRICE", VALUEFUNC(_wrap_ComplexEventPriceTimeType_OFFICIAL_SETTL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_DERIVATIVES_CLOSE", VALUEFUNC(_wrap_ComplexEventPriceTimeType_DERIVATIVES_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPriceTimeType_AS_SPECIFIED_MASTER_CONFIRMATION", VALUEFUNC(_wrap_ComplexEventPriceTimeType_AS_SPECIFIED_MASTER_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventCondition_AND", VALUEFUNC(_wrap_ComplexEventCondition_AND_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventCondition_OR", VALUEFUNC(_wrap_ComplexEventCondition_OR_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_NEW_CUSTOMER", VALUEFUNC(_wrap_StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_NEW_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_EXISTING_CUSTOMER", VALUEFUNC(_wrap_StreamAsgnReqType_STREAM_ASSIGNMENT_FOR_EXISTING_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnRejReason_UNKNOWN_CLIENT", VALUEFUNC(_wrap_StreamAsgnRejReason_UNKNOWN_CLIENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnRejReason_EXCEEDS_MAXIMUM_SIZE", VALUEFUNC(_wrap_StreamAsgnRejReason_EXCEEDS_MAXIMUM_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnRejReason_UNKNOWN_OR_INVALID_CURRENCY_PAIR", VALUEFUNC(_wrap_StreamAsgnRejReason_UNKNOWN_OR_INVALID_CURRENCY_PAIR_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnRejReason_NO_AVAILABLE_STREAM", VALUEFUNC(_wrap_StreamAsgnRejReason_NO_AVAILABLE_STREAM_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnRejReason_OTHER", VALUEFUNC(_wrap_StreamAsgnRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnAckType_ASSIGNMENT_ACCEPTED", VALUEFUNC(_wrap_StreamAsgnAckType_ASSIGNMENT_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnAckType_ASSIGNMENT_REJECTED", VALUEFUNC(_wrap_StreamAsgnAckType_ASSIGNMENT_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnType_ASSIGNMENT", VALUEFUNC(_wrap_StreamAsgnType_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnType_REJECTED", VALUEFUNC(_wrap_StreamAsgnType_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamAsgnType_TERMINATE", VALUEFUNC(_wrap_StreamAsgnType_TERMINATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchInst_MATCH", VALUEFUNC(_wrap_MatchInst_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchInst_DO_NOT_MATCH", VALUEFUNC(_wrap_MatchInst_DO_NOT_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_THIS_ORDER", VALUEFUNC(_wrap_TriggerScope_THIS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_OTHER_ORDER", VALUEFUNC(_wrap_TriggerScope_OTHER_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY", VALUEFUNC(_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_PRICE", VALUEFUNC(_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_SIDE", VALUEFUNC(_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_AND_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_PRICE_AND_SIDE", VALUEFUNC(_wrap_TriggerScope_ALL_OTHER_ORDERS_FOR_GIVEN_SECURITY_PRICE_AND_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_CREDIT_LIMIT", VALUEFUNC(_wrap_LimitAmtType_CREDIT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_GROSS_POSITION_LIMIT", VALUEFUNC(_wrap_LimitAmtType_GROSS_POSITION_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_NET_POSITION_LIMIT", VALUEFUNC(_wrap_LimitAmtType_NET_POSITION_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_RISK_EXPOSURE_LIMIT", VALUEFUNC(_wrap_LimitAmtType_RISK_EXPOSURE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_LONG_POSITION_LIMIT", VALUEFUNC(_wrap_LimitAmtType_LONG_POSITION_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LimitAmtType_SHORT_POSITION_LIMIT", VALUEFUNC(_wrap_LimitAmtType_SHORT_POSITION_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqQualifier_SUMMARY", VALUEFUNC(_wrap_MarginReqmtInqQualifier_SUMMARY_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqQualifier_DETAIL", VALUEFUNC(_wrap_MarginReqmtInqQualifier_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqQualifier_EXCESS_DEFICIT", VALUEFUNC(_wrap_MarginReqmtInqQualifier_EXCESS_DEFICIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqQualifier_NET_POSITION", VALUEFUNC(_wrap_MarginReqmtInqQualifier_NET_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtRptType_SUMMARY", VALUEFUNC(_wrap_MarginReqmtRptType_SUMMARY_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtRptType_DETAIL", VALUEFUNC(_wrap_MarginReqmtRptType_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtRptType_EXCESS_DEFICIT", VALUEFUNC(_wrap_MarginReqmtRptType_EXCESS_DEFICIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_SUCCESSFUL", VALUEFUNC(_wrap_MarginReqmtInqResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_INVALID_OR_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_MarginReqmtInqResult_INVALID_OR_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_INVALID_OR_UNKNOWN_MARGIN_CLASS", VALUEFUNC(_wrap_MarginReqmtInqResult_INVALID_OR_UNKNOWN_MARGIN_CLASS_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_INVALID_PARTIES", VALUEFUNC(_wrap_MarginReqmtInqResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_INVALID_TRANSPORT_TYPE_REQ", VALUEFUNC(_wrap_MarginReqmtInqResult_INVALID_TRANSPORT_TYPE_REQ_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_INVALID_DESTINATION_REQ", VALUEFUNC(_wrap_MarginReqmtInqResult_INVALID_DESTINATION_REQ_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_NO_MARGIN_REQ_FOUND", VALUEFUNC(_wrap_MarginReqmtInqResult_NO_MARGIN_REQ_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_MARGIN_REQ_INQUIRY_QUALIFIER_NOT_SUPPORTED", VALUEFUNC(_wrap_MarginReqmtInqResult_MARGIN_REQ_INQUIRY_QUALIFIER_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_UNAUTHORIZED_FOR_MARGIN_REQ_INQUIRY", VALUEFUNC(_wrap_MarginReqmtInqResult_UNAUTHORIZED_FOR_MARGIN_REQ_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginReqmtInqResult_OTHER", VALUEFUNC(_wrap_MarginReqmtInqResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_ADDITIONAL_MARGIN", VALUEFUNC(_wrap_MarginAmtType_ADDITIONAL_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_ADJUSTED_MARGIN", VALUEFUNC(_wrap_MarginAmtType_ADJUSTED_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_UNADJUSTED_MARGIN", VALUEFUNC(_wrap_MarginAmtType_UNADJUSTED_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_BINARY_ADD_ON_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_BINARY_ADD_ON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_CASH_BALANCE_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_CASH_BALANCE_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_CONCENTRATION_MARGIN", VALUEFUNC(_wrap_MarginAmtType_CONCENTRATION_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_CORE_MARGIN", VALUEFUNC(_wrap_MarginAmtType_CORE_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_DELIVERY_MARGIN", VALUEFUNC(_wrap_MarginAmtType_DELIVERY_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_DISCRETIONARY_MARGIN", VALUEFUNC(_wrap_MarginAmtType_DISCRETIONARY_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_FUTURES_SPREAD_MARGIN", VALUEFUNC(_wrap_MarginAmtType_FUTURES_SPREAD_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_INITIAL_MARGIN", VALUEFUNC(_wrap_MarginAmtType_INITIAL_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_LIQUIDATING_MARGIN", VALUEFUNC(_wrap_MarginAmtType_LIQUIDATING_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_MARGIN_CALL_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_MARGIN_CALL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_MARGIN_DEFICIT_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_MARGIN_DEFICIT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_MARGIN_EXCESS_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_MARGIN_EXCESS_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_OPTION_PREMIUM_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_OPTION_PREMIUM_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_PREMIUM_MARGIN", VALUEFUNC(_wrap_MarginAmtType_PREMIUM_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_RESERVE_MARGIN", VALUEFUNC(_wrap_MarginAmtType_RESERVE_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SECURITY_COLLATERAL_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_SECURITY_COLLATERAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_STRESS_TEST_ADD_ON_AMOUNT", VALUEFUNC(_wrap_MarginAmtType_STRESS_TEST_ADD_ON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SUPER_MARGIN", VALUEFUNC(_wrap_MarginAmtType_SUPER_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_TOTAL_MARGIN", VALUEFUNC(_wrap_MarginAmtType_TOTAL_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_VARIATION_MARGIN", VALUEFUNC(_wrap_MarginAmtType_VARIATION_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SECONDARY_VARIATION_MARGIN", VALUEFUNC(_wrap_MarginAmtType_SECONDARY_VARIATION_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_ROLLED_UP_MARGIN_DEFICIT", VALUEFUNC(_wrap_MarginAmtType_ROLLED_UP_MARGIN_DEFICIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SPREAD_RESPONSE_MARGIN", VALUEFUNC(_wrap_MarginAmtType_SPREAD_RESPONSE_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SYSTEMIC_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_SYSTEMIC_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_CURVE_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_CURVE_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_INDEX_SPREAD_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_INDEX_SPREAD_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_SECTOR_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_SECTOR_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_JUMP_TO_DEFAULT_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_JUMP_TO_DEFAULT_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_BASIS_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_BASIS_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_INTEREST_RATE_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_INTEREST_RATE_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_JUMP_TO_HEALTH_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_JUMP_TO_HEALTH_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginAmtType_OTHER_RISK_MARGIN", VALUEFUNC(_wrap_MarginAmtType_OTHER_RISK_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_HEDGES_FOR_INSTRUMENT", VALUEFUNC(_wrap_RelatedInstrumentType_HEDGES_FOR_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_UNDERLIER", VALUEFUNC(_wrap_RelatedInstrumentType_UNDERLIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_EQUITY_EQUIVALENT", VALUEFUNC(_wrap_RelatedInstrumentType_EQUITY_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_NEAREST_EXCHANGE_TRADED_CONTRACT", VALUEFUNC(_wrap_RelatedInstrumentType_NEAREST_EXCHANGE_TRADED_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_RETAIL_EQUIVALENT", VALUEFUNC(_wrap_RelatedInstrumentType_RETAIL_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedInstrumentType_LEG", VALUEFUNC(_wrap_RelatedInstrumentType_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketMakerActivity_NO_PARTICIPATION", VALUEFUNC(_wrap_MarketMakerActivity_NO_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketMakerActivity_BUY_PARTICIPATION", VALUEFUNC(_wrap_MarketMakerActivity_BUY_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketMakerActivity_SELL_PARTICIPATION", VALUEFUNC(_wrap_MarketMakerActivity_SELL_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketMakerActivity_BOTH_BUY_AND_SELL_PARTICIPATION", VALUEFUNC(_wrap_MarketMakerActivity_BOTH_BUY_AND_SELL_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_VALID_REQUEST", VALUEFUNC(_wrap_RequestResult_VALID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_INVALID_OR_UNSUPPORTED_REQUEST", VALUEFUNC(_wrap_RequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_NO_DATA_FOUND", VALUEFUNC(_wrap_RequestResult_NO_DATA_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_NOT_AUTHORIZED", VALUEFUNC(_wrap_RequestResult_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_DATA_TEMPORARILY_UNAVAILABLE", VALUEFUNC(_wrap_RequestResult_DATA_TEMPORARILY_UNAVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_REQUEST_FOR_DATA_NOT_SUPPORTED", VALUEFUNC(_wrap_RequestResult_REQUEST_FOR_DATA_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RequestResult_OTHER", VALUEFUNC(_wrap_RequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_IS_ALSO", VALUEFUNC(_wrap_PartyRelationship_IS_ALSO_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_CLEARS_FOR", VALUEFUNC(_wrap_PartyRelationship_CLEARS_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_CLEARS_THROUGH", VALUEFUNC(_wrap_PartyRelationship_CLEARS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_TRADES_FOR", VALUEFUNC(_wrap_PartyRelationship_TRADES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_TRADES_THROUGH", VALUEFUNC(_wrap_PartyRelationship_TRADES_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_SPONSORS", VALUEFUNC(_wrap_PartyRelationship_SPONSORS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_SPONSORED_THROUGH", VALUEFUNC(_wrap_PartyRelationship_SPONSORED_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PROVIDES_GUARANTEE_FOR", VALUEFUNC(_wrap_PartyRelationship_PROVIDES_GUARANTEE_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_IS_GUARANTEED_BY", VALUEFUNC(_wrap_PartyRelationship_IS_GUARANTEED_BY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_MEMBER_OF", VALUEFUNC(_wrap_PartyRelationship_MEMBER_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_HAS_MEMBERS", VALUEFUNC(_wrap_PartyRelationship_HAS_MEMBERS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PROVIDES_MARKETPLACE_FOR", VALUEFUNC(_wrap_PartyRelationship_PROVIDES_MARKETPLACE_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PARTICIPANT_OF_MARKETPLACE", VALUEFUNC(_wrap_PartyRelationship_PARTICIPANT_OF_MARKETPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_CARRIES_POSITIONS_FOR", VALUEFUNC(_wrap_PartyRelationship_CARRIES_POSITIONS_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_POSTS_TRADES_TO", VALUEFUNC(_wrap_PartyRelationship_POSTS_TRADES_TO_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_ENTERS_TRADES_FOR", VALUEFUNC(_wrap_PartyRelationship_ENTERS_TRADES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_ENTERS_TRADES_THROUGH", VALUEFUNC(_wrap_PartyRelationship_ENTERS_TRADES_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PROVIDES_QUOTES_TO", VALUEFUNC(_wrap_PartyRelationship_PROVIDES_QUOTES_TO_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_REQUESTS_QUOTES_FROM", VALUEFUNC(_wrap_PartyRelationship_REQUESTS_QUOTES_FROM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_INVESTS_FOR", VALUEFUNC(_wrap_PartyRelationship_INVESTS_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_INVESTS_THROUGH", VALUEFUNC(_wrap_PartyRelationship_INVESTS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_BROKERS_TRADES_FOR", VALUEFUNC(_wrap_PartyRelationship_BROKERS_TRADES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_BROKERS_TRADES_THROUGH", VALUEFUNC(_wrap_PartyRelationship_BROKERS_TRADES_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PROVIDES_TRADING_SERVICES_FOR", VALUEFUNC(_wrap_PartyRelationship_PROVIDES_TRADING_SERVICES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_USES_TRADING_SERVICES_OF", VALUEFUNC(_wrap_PartyRelationship_USES_TRADING_SERVICES_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_APPROVES_OF", VALUEFUNC(_wrap_PartyRelationship_APPROVES_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_APPROVED_BY", VALUEFUNC(_wrap_PartyRelationship_APPROVED_BY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_PARENT_FIRM_FOR", VALUEFUNC(_wrap_PartyRelationship_PARENT_FIRM_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_SUBSIDIARY_OF", VALUEFUNC(_wrap_PartyRelationship_SUBSIDIARY_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_REGULATORY_OWNER_OF", VALUEFUNC(_wrap_PartyRelationship_REGULATORY_OWNER_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_OWNED_BY_REGULATORY", VALUEFUNC(_wrap_PartyRelationship_OWNED_BY_REGULATORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_CONTROLS", VALUEFUNC(_wrap_PartyRelationship_CONTROLS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_IS_CONTROLLED_BY", VALUEFUNC(_wrap_PartyRelationship_IS_CONTROLLED_BY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_LEGAL_OWNER_OF", VALUEFUNC(_wrap_PartyRelationship_LEGAL_OWNER_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_OWNED_BY_LEGAL", VALUEFUNC(_wrap_PartyRelationship_OWNED_BY_LEGAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_BENEFICIAL_OWNER_OF", VALUEFUNC(_wrap_PartyRelationship_BENEFICIAL_OWNER_OF_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_OWNED_BY_BENEFICIAL", VALUEFUNC(_wrap_PartyRelationship_OWNED_BY_BENEFICIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_SETTLES_FOR", VALUEFUNC(_wrap_PartyRelationship_SETTLES_FOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRelationship_SETTLES_THROUGH", VALUEFUNC(_wrap_PartyRelationship_SETTLES_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_CREDIT_LIMIT", VALUEFUNC(_wrap_RiskLimitType_CREDIT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_GROSS_LIMIT", VALUEFUNC(_wrap_RiskLimitType_GROSS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_NET_LIMIT", VALUEFUNC(_wrap_RiskLimitType_NET_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_EXPOSURE", VALUEFUNC(_wrap_RiskLimitType_EXPOSURE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_LONG_LIMIT", VALUEFUNC(_wrap_RiskLimitType_LONG_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_SHORT_LIMIT", VALUEFUNC(_wrap_RiskLimitType_SHORT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_CASH_MARGIN", VALUEFUNC(_wrap_RiskLimitType_CASH_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_ADDITIONAL_MARGIN", VALUEFUNC(_wrap_RiskLimitType_ADDITIONAL_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_TOTAL_MARGIN", VALUEFUNC(_wrap_RiskLimitType_TOTAL_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_LIMIT_CONSUMED", VALUEFUNC(_wrap_RiskLimitType_LIMIT_CONSUMED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_CLIP_SIZE", VALUEFUNC(_wrap_RiskLimitType_CLIP_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_MAX_NOTIONAL_ORDER_SIZE", VALUEFUNC(_wrap_RiskLimitType_MAX_NOTIONAL_ORDER_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_DV01_PV01_LIMIT", VALUEFUNC(_wrap_RiskLimitType_DV01_PV01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_CS01_LIMIT", VALUEFUNC(_wrap_RiskLimitType_CS01_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_VOLUME_LIMIT_PER_TIME_PERIOD", VALUEFUNC(_wrap_RiskLimitType_VOLUME_LIMIT_PER_TIME_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_VOL_FILLED_PCT_ORD_VOL_TM_PERIOD", VALUEFUNC(_wrap_RiskLimitType_VOL_FILLED_PCT_ORD_VOL_TM_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_NOTL_FILLED_PCT_NOTL_TM_PERIOD", VALUEFUNC(_wrap_RiskLimitType_NOTL_FILLED_PCT_NOTL_TM_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitType_TRANSACTION_EXECUTION_LIMIT_PER_TIME_PERIOD", VALUEFUNC(_wrap_RiskLimitType_TRANSACTION_EXECUTION_LIMIT_PER_TIME_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrumentScopeOperator_INCLUDE", VALUEFUNC(_wrap_InstrumentScopeOperator_INCLUDE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrumentScopeOperator_EXCLUDE", VALUEFUNC(_wrap_InstrumentScopeOperator_EXCLUDE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailStatus_ACTIVE", VALUEFUNC(_wrap_PartyDetailStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailStatus_SUSPENDED", VALUEFUNC(_wrap_PartyDetailStatus_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailStatus_HALTED", VALUEFUNC(_wrap_PartyDetailStatus_HALTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_FIRM_OR_LEGAL_ENTITY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_FIRM_OR_LEGAL_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_CURRENT", VALUEFUNC(_wrap_PartyDetailRoleQualifier_CURRENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_NEW", VALUEFUNC(_wrap_PartyDetailRoleQualifier_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_NATURAL_PERSON", VALUEFUNC(_wrap_PartyDetailRoleQualifier_NATURAL_PERSON_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_AGENCY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_PRINCIPAL", VALUEFUNC(_wrap_PartyDetailRoleQualifier_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_PartyDetailRoleQualifier_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_EXCHANGE_ORDER_SUBMITTER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_EXCHANGE_ORDER_SUBMITTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_PRIMARY_TRD_REPOSITORY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_PRIMARY_TRD_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_ORIG_TRD_REPOSITORY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_ORIG_TRD_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_ADDTNL_INTL_TRD_REPOSITORY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_ADDTNL_INTL_TRD_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_ADDTNL_DOMESTIC_TRD_REPOSITORY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_ADDTNL_DOMESTIC_TRD_REPOSITORY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_REGULAR_TRADER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_REGULAR_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_HEAD_TRADER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_HEAD_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_SUPERVISOR", VALUEFUNC(_wrap_PartyDetailRoleQualifier_SUPERVISOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_ALGORITHM", VALUEFUNC(_wrap_PartyDetailRoleQualifier_ALGORITHM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_RELATED_EXCHANGE", VALUEFUNC(_wrap_PartyDetailRoleQualifier_RELATED_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_OPTIONS_EXCHANGE", VALUEFUNC(_wrap_PartyDetailRoleQualifier_OPTIONS_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_SPECIFIED_EXCHANGE", VALUEFUNC(_wrap_PartyDetailRoleQualifier_SPECIFIED_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_CONSTITUENT_EXCHANGE", VALUEFUNC(_wrap_PartyDetailRoleQualifier_CONSTITUENT_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_BANK", VALUEFUNC(_wrap_PartyDetailRoleQualifier_BANK_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_HUB", VALUEFUNC(_wrap_PartyDetailRoleQualifier_HUB_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_TRI_PARTY", VALUEFUNC(_wrap_PartyDetailRoleQualifier_TRI_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_LENDER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_LENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_GENERAL_CLEARING_MEMBER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_GENERAL_CLEARING_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_INDIVIDUAL_CLEARING_MEMBER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_INDIVIDUAL_CLEARING_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_PREFERRED_MARKET_MAKER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_PREFERRED_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_DIRECTED_MARKET_MAKER", VALUEFUNC(_wrap_PartyDetailRoleQualifier_DIRECTED_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_DESIGNATED_SPONSOR", VALUEFUNC(_wrap_PartyDetailRoleQualifier_DESIGNATED_SPONSOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_SPECIALIST", VALUEFUNC(_wrap_PartyDetailRoleQualifier_SPECIALIST_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRoleQualifier_EXEMPT_FROM_TRADE_REPORTING", VALUEFUNC(_wrap_PartyDetailRoleQualifier_EXEMPT_FROM_TRADE_REPORTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdAckStatus_ACCEPTED", VALUEFUNC(_wrap_TrdAckStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdAckStatus_REJECTED", VALUEFUNC(_wrap_TrdAckStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdAckStatus_RECEIVED", VALUEFUNC(_wrap_TrdAckStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_FEE", VALUEFUNC(_wrap_SecurityClassificationReason_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_CREDIT_CONTROLS", VALUEFUNC(_wrap_SecurityClassificationReason_CREDIT_CONTROLS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_MARGIN", VALUEFUNC(_wrap_SecurityClassificationReason_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_ENTITLEMENT_OR_ELIGIBILITY", VALUEFUNC(_wrap_SecurityClassificationReason_ENTITLEMENT_OR_ELIGIBILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_MARKET_DATA", VALUEFUNC(_wrap_SecurityClassificationReason_MARKET_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_ACCOUNT_SELECTION", VALUEFUNC(_wrap_SecurityClassificationReason_ACCOUNT_SELECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_DELIVERY_PROCESS", VALUEFUNC(_wrap_SecurityClassificationReason_DELIVERY_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityClassificationReason_SECTOR", VALUEFUNC(_wrap_SecurityClassificationReason_SECTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_OPTIONS_SETTLEMENT", VALUEFUNC(_wrap_PosAmtReason_OPTIONS_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_PENDING_EROSION_ADJUSTMENT", VALUEFUNC(_wrap_PosAmtReason_PENDING_EROSION_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_FINAL_EROSION_ADJUSTMENT", VALUEFUNC(_wrap_PosAmtReason_FINAL_EROSION_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_TEAR_UP_COUPON_AMOUNT", VALUEFUNC(_wrap_PosAmtReason_TEAR_UP_COUPON_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_PRICE_ALIGNMENT_INTEREST", VALUEFUNC(_wrap_PosAmtReason_PRICE_ALIGNMENT_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_DELIVERY_INVOICE_CHARGES", VALUEFUNC(_wrap_PosAmtReason_DELIVERY_INVOICE_CHARGES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtReason_DELIVERY_STORAGE_CHARGES", VALUEFUNC(_wrap_PosAmtReason_DELIVERY_STORAGE_CHARGES_get), 0);
  rb_define_singleton_method(mQuickfix, "SideClearingTradePriceType_TRADE_CLEARING_AT_EXECUTION_PRICE", VALUEFUNC(_wrap_SideClearingTradePriceType_TRADE_CLEARING_AT_EXECUTION_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "SideClearingTradePriceType_TRADE_CLEARING_AT_ALTERNATE_CLEARING_PRICE", VALUEFUNC(_wrap_SideClearingTradePriceType_TRADE_CLEARING_AT_ALTERNATE_CLEARING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_INSTRUMENT_REQUESTED", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_INSTRUMENT_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INSTRUMENT_ALREADY_EXISTS", VALUEFUNC(_wrap_SecurityRejectReason_INSTRUMENT_ALREADY_EXISTS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_REQUEST_TYPE_NOT_SUPPORTED", VALUEFUNC(_wrap_SecurityRejectReason_REQUEST_TYPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_SYSTEM_UNAVAILABLE_FOR_INSTRUMENT_CREATION", VALUEFUNC(_wrap_SecurityRejectReason_SYSTEM_UNAVAILABLE_FOR_INSTRUMENT_CREATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INELIGIBLE_INSTRUMENT_GROUP", VALUEFUNC(_wrap_SecurityRejectReason_INELIGIBLE_INSTRUMENT_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INSTRUMENT_ID_UNAVAILABLE", VALUEFUNC(_wrap_SecurityRejectReason_INSTRUMENT_ID_UNAVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_OPTION_LEG", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_OPTION_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FUTURE_LEG", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FUTURE_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FX_LEG", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_OR_MISSING_DATA_ON_FX_LEG_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_LEG_PRICE_SPECIFIED", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_LEG_PRICE_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRejectReason_INVALID_INSTRUMENT_STRUCTURE_SPECIFIED", VALUEFUNC(_wrap_SecurityRejectReason_INVALID_INSTRUMENT_STRUCTURE_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleStatus_THROTTLE_LIMIT_NOT_EXCEEDED_NOT_QUEUED", VALUEFUNC(_wrap_ThrottleStatus_THROTTLE_LIMIT_NOT_EXCEEDED_NOT_QUEUED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleStatus_QUEUED_DUE_TO_THROTTLE_LIMIT_EXCEEDED", VALUEFUNC(_wrap_ThrottleStatus_QUEUED_DUE_TO_THROTTLE_LIMIT_EXCEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleAction_QUEUE_INBOUND", VALUEFUNC(_wrap_ThrottleAction_QUEUE_INBOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleAction_QUEUE_OUTBOUND", VALUEFUNC(_wrap_ThrottleAction_QUEUE_OUTBOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleAction_REJECT", VALUEFUNC(_wrap_ThrottleAction_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleAction_DISCONNECT", VALUEFUNC(_wrap_ThrottleAction_DISCONNECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleAction_WARNING", VALUEFUNC(_wrap_ThrottleAction_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleType_INBOUND_RATE", VALUEFUNC(_wrap_ThrottleType_INBOUND_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleType_OUTSTANDING_REQUESTS", VALUEFUNC(_wrap_ThrottleType_OUTSTANDING_REQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleInst_REJECT_IF_THROTTLE_LIMIT_EXCEEDED", VALUEFUNC(_wrap_ThrottleInst_REJECT_IF_THROTTLE_LIMIT_EXCEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleInst_QUEUE_IF_THROTTLE_LIMIT_EXCEEDED", VALUEFUNC(_wrap_ThrottleInst_QUEUE_IF_THROTTLE_LIMIT_EXCEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleCountIndicator_OUTSTANDING_REQUESTS_UNCHANGED", VALUEFUNC(_wrap_ThrottleCountIndicator_OUTSTANDING_REQUESTS_UNCHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "ThrottleCountIndicator_OUTSTANDING_REQUESTS_DECREASED", VALUEFUNC(_wrap_ThrottleCountIndicator_OUTSTANDING_REQUESTS_DECREASED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocationRollupInstruction_ROLLUP", VALUEFUNC(_wrap_AllocationRollupInstruction_ROLLUP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocationRollupInstruction_DO_NOT_ROLL_UP", VALUEFUNC(_wrap_AllocationRollupInstruction_DO_NOT_ROLL_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReversalStatus_COMPLETED", VALUEFUNC(_wrap_AllocReversalStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReversalStatus_REFUSED", VALUEFUNC(_wrap_AllocReversalStatus_REFUSED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReversalStatus_CANCELLED", VALUEFUNC(_wrap_AllocReversalStatus_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "ObligationType_BOND", VALUEFUNC(_wrap_ObligationType_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "ObligationType_CONVERT_BOND", VALUEFUNC(_wrap_ObligationType_CONVERT_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "ObligationType_MORTGAGE", VALUEFUNC(_wrap_ObligationType_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ObligationType_LOAN", VALUEFUNC(_wrap_ObligationType_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_PERCENT_PAR", VALUEFUNC(_wrap_TradePriceNegotiationMethod_PERCENT_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_DEAL_SPREAD", VALUEFUNC(_wrap_TradePriceNegotiationMethod_DEAL_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_UPFRONT_PNTS", VALUEFUNC(_wrap_TradePriceNegotiationMethod_UPFRONT_PNTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_UPFRONT_AMT", VALUEFUNC(_wrap_TradePriceNegotiationMethod_UPFRONT_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_PAR_UPFRONT_AMT", VALUEFUNC(_wrap_TradePriceNegotiationMethod_PAR_UPFRONT_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_SPREAD_UPFRONT_AMT", VALUEFUNC(_wrap_TradePriceNegotiationMethod_SPREAD_UPFRONT_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceNegotiationMethod_UPFRONT_PNTS_AMT", VALUEFUNC(_wrap_TradePriceNegotiationMethod_UPFRONT_PNTS_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "UpfrontPriceType_PERCENTAGE", VALUEFUNC(_wrap_UpfrontPriceType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "UpfrontPriceType_FIXED_AMOUNT", VALUEFUNC(_wrap_UpfrontPriceType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleRestriction_NO_RESTRICTIONS", VALUEFUNC(_wrap_ShortSaleRestriction_NO_RESTRICTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleRestriction_SECURITY_NOT_SHORTABLE", VALUEFUNC(_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleRestriction_SECURITY_NOT_SHORTABLE_AT_OR_BELOW_BEST_BID", VALUEFUNC(_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_AT_OR_BELOW_BEST_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleRestriction_SECURITY_NOT_SHORTABLE_WITHOUT_PRE_BORROW", VALUEFUNC(_wrap_ShortSaleRestriction_SECURITY_NOT_SHORTABLE_WITHOUT_PRE_BORROW_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_EXEMPTION_REASON_UNKNOWN", VALUEFUNC(_wrap_ShortSaleExemptionReason_EXEMPTION_REASON_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_INCOMING_SSE", VALUEFUNC(_wrap_ShortSaleExemptionReason_INCOMING_SSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_ABOVE_NATIONAL_BEST_BID", VALUEFUNC(_wrap_ShortSaleExemptionReason_ABOVE_NATIONAL_BEST_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_DELAYED_DELIVERY", VALUEFUNC(_wrap_ShortSaleExemptionReason_DELAYED_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_ODD_LOT", VALUEFUNC(_wrap_ShortSaleExemptionReason_ODD_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_DOMESTIC_ARBITRAGE", VALUEFUNC(_wrap_ShortSaleExemptionReason_DOMESTIC_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_INTERNATIONAL_ARBITRAGE", VALUEFUNC(_wrap_ShortSaleExemptionReason_INTERNATIONAL_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_UNDERWRITER_OR_SYNDICATE_DISTRIBUTION", VALUEFUNC(_wrap_ShortSaleExemptionReason_UNDERWRITER_OR_SYNDICATE_DISTRIBUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_ShortSaleExemptionReason_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleExemptionReason_VWAP", VALUEFUNC(_wrap_ShortSaleExemptionReason_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplLevelRecoveryIndicator_NO_APPL_RECOVERY_NEEDED", VALUEFUNC(_wrap_ApplLevelRecoveryIndicator_NO_APPL_RECOVERY_NEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplLevelRecoveryIndicator_APPL_RECOVERY_NEEDED", VALUEFUNC(_wrap_ApplLevelRecoveryIndicator_APPL_RECOVERY_NEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestType_DEFINITIONS", VALUEFUNC(_wrap_RiskLimitRequestType_DEFINITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestType_UTILIZATION", VALUEFUNC(_wrap_RiskLimitRequestType_UTILIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestType_DEFINITIONS_AND_UTILIZATIONS", VALUEFUNC(_wrap_RiskLimitRequestType_DEFINITIONS_AND_UTILIZATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_RiskLimitRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_PARTY", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RELATED_PARTY", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RELATED_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RISK_LIMIT_TYPE", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RISK_LIMIT_ID", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RISK_LIMIT_AMOUNT", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RISK_LIMIT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RISK_WARNING_LEVEL_ACTION", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RISK_WARNING_LEVEL_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INVALID_RISK_INSTRUMENT_SCOPE", VALUEFUNC(_wrap_RiskLimitRequestResult_INVALID_RISK_INSTRUMENT_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_RISK_LIMIT_ACTIONS_NOT_SUPPORTED", VALUEFUNC(_wrap_RiskLimitRequestResult_RISK_LIMIT_ACTIONS_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_WARNING_LEVELS_NOT_SUPPORTED", VALUEFUNC(_wrap_RiskLimitRequestResult_WARNING_LEVELS_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_WARNING_LEVEL_ACTIONS_NOT_SUPPORTED", VALUEFUNC(_wrap_RiskLimitRequestResult_WARNING_LEVEL_ACTIONS_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_RISK_INSTRUMENT_SCOPE_NOT_SUPPORTED", VALUEFUNC(_wrap_RiskLimitRequestResult_RISK_INSTRUMENT_SCOPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_RISK_LIMIT_NOT_APPROVED_FOR_PARTY", VALUEFUNC(_wrap_RiskLimitRequestResult_RISK_LIMIT_NOT_APPROVED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_RISK_LIMIT_ALREADY_DEFINED_FOR_PARTY", VALUEFUNC(_wrap_RiskLimitRequestResult_RISK_LIMIT_ALREADY_DEFINED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY", VALUEFUNC(_wrap_RiskLimitRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_NOT_AUTHORIZED", VALUEFUNC(_wrap_RiskLimitRequestResult_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitRequestResult_OTHER", VALUEFUNC(_wrap_RiskLimitRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_QUEUE_INBOUND", VALUEFUNC(_wrap_RiskLimitAction_QUEUE_INBOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_QUEUE_OUTBOUND", VALUEFUNC(_wrap_RiskLimitAction_QUEUE_OUTBOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_REJECT", VALUEFUNC(_wrap_RiskLimitAction_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_DISCONNECT", VALUEFUNC(_wrap_RiskLimitAction_DISCONNECT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_WARNING", VALUEFUNC(_wrap_RiskLimitAction_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_PING_CREDIT_CHECK_WITH_REVALIDATION", VALUEFUNC(_wrap_RiskLimitAction_PING_CREDIT_CHECK_WITH_REVALIDATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_PING_CREDIT_CHECK_NO_REVALIDATION", VALUEFUNC(_wrap_RiskLimitAction_PING_CREDIT_CHECK_NO_REVALIDATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_PUSH_CREDIT_CHECK_WITH_REVALIDATION", VALUEFUNC(_wrap_RiskLimitAction_PUSH_CREDIT_CHECK_WITH_REVALIDATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_PUSH_CREDIT_CHECK_NO_REVALIDATION", VALUEFUNC(_wrap_RiskLimitAction_PUSH_CREDIT_CHECK_NO_REVALIDATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_SUSPEND", VALUEFUNC(_wrap_RiskLimitAction_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitAction_HALT_TRADING", VALUEFUNC(_wrap_RiskLimitAction_HALT_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_TRADE", VALUEFUNC(_wrap_EntitlementType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_MAKE_MARKETS", VALUEFUNC(_wrap_EntitlementType_MAKE_MARKETS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_HOLD_POSITIONS", VALUEFUNC(_wrap_EntitlementType_HOLD_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_PERFORM_GIVE_UPS", VALUEFUNC(_wrap_EntitlementType_PERFORM_GIVE_UPS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_SUBMIT_IO_IS", VALUEFUNC(_wrap_EntitlementType_SUBMIT_IO_IS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_SUBSCRIBE_MARKET_DATA", VALUEFUNC(_wrap_EntitlementType_SUBSCRIBE_MARKET_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_SHORT_WITH_PRE_BORROW", VALUEFUNC(_wrap_EntitlementType_SHORT_WITH_PRE_BORROW_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_SUBMIT_QUOTE_REQUESTS", VALUEFUNC(_wrap_EntitlementType_SUBMIT_QUOTE_REQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementType_RESPOND_TO_QUOTE_REQUESTS", VALUEFUNC(_wrap_EntitlementType_RESPOND_TO_QUOTE_REQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_TENOR", VALUEFUNC(_wrap_EntitlementAttribDatatype_TENOR_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_PATTERN", VALUEFUNC(_wrap_EntitlementAttribDatatype_PATTERN_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_RESERVED100_PLUS", VALUEFUNC(_wrap_EntitlementAttribDatatype_RESERVED100_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_RESERVED1000_PLUS", VALUEFUNC(_wrap_EntitlementAttribDatatype_RESERVED1000_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_RESERVED4000_PLUS", VALUEFUNC(_wrap_EntitlementAttribDatatype_RESERVED4000_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_STRING", VALUEFUNC(_wrap_EntitlementAttribDatatype_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_MULTIPLE_CHAR_VALUE", VALUEFUNC(_wrap_EntitlementAttribDatatype_MULTIPLE_CHAR_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_CURRENCY", VALUEFUNC(_wrap_EntitlementAttribDatatype_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_EXCHANGE", VALUEFUNC(_wrap_EntitlementAttribDatatype_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_MONTH_YEAR", VALUEFUNC(_wrap_EntitlementAttribDatatype_MONTH_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_UTC_TIMESTAMP", VALUEFUNC(_wrap_EntitlementAttribDatatype_UTC_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_UTC_TIME_ONLY", VALUEFUNC(_wrap_EntitlementAttribDatatype_UTC_TIME_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_LOCAL_MKT_DATE", VALUEFUNC(_wrap_EntitlementAttribDatatype_LOCAL_MKT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_UTC_DATE_ONLY", VALUEFUNC(_wrap_EntitlementAttribDatatype_UTC_DATE_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_DATA", VALUEFUNC(_wrap_EntitlementAttribDatatype_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_MULTIPLE_STRING_VALUE", VALUEFUNC(_wrap_EntitlementAttribDatatype_MULTIPLE_STRING_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_COUNTRY", VALUEFUNC(_wrap_EntitlementAttribDatatype_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_LANGUAGE", VALUEFUNC(_wrap_EntitlementAttribDatatype_LANGUAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_TZ_TIME_ONLY", VALUEFUNC(_wrap_EntitlementAttribDatatype_TZ_TIME_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_TZ_TIMESTAMP", VALUEFUNC(_wrap_EntitlementAttribDatatype_TZ_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_XML_DATA", VALUEFUNC(_wrap_EntitlementAttribDatatype_XML_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_CHAR", VALUEFUNC(_wrap_EntitlementAttribDatatype_CHAR_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_BOOLEAN", VALUEFUNC(_wrap_EntitlementAttribDatatype_BOOLEAN_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_FLOAT", VALUEFUNC(_wrap_EntitlementAttribDatatype_FLOAT_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_QTY", VALUEFUNC(_wrap_EntitlementAttribDatatype_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_PRICE", VALUEFUNC(_wrap_EntitlementAttribDatatype_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_PRICE_OFFSET", VALUEFUNC(_wrap_EntitlementAttribDatatype_PRICE_OFFSET_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_AMT", VALUEFUNC(_wrap_EntitlementAttribDatatype_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_PERCENTAGE", VALUEFUNC(_wrap_EntitlementAttribDatatype_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_INT", VALUEFUNC(_wrap_EntitlementAttribDatatype_INT_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_LENGTH", VALUEFUNC(_wrap_EntitlementAttribDatatype_LENGTH_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_NUM_IN_GROUP", VALUEFUNC(_wrap_EntitlementAttribDatatype_NUM_IN_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_SEQ_NUM", VALUEFUNC(_wrap_EntitlementAttribDatatype_SEQ_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_TAG_NUM", VALUEFUNC(_wrap_EntitlementAttribDatatype_TAG_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementAttribDatatype_DAY_OF_MONTH", VALUEFUNC(_wrap_EntitlementAttribDatatype_DAY_OF_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesControl_AUTOMATIC", VALUEFUNC(_wrap_TradSesControl_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesControl_MANUAL", VALUEFUNC(_wrap_TradSesControl_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeVolType_NUMBER_OF_UNITS", VALUEFUNC(_wrap_TradeVolType_NUMBER_OF_UNITS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeVolType_NUMBER_OF_ROUND_LOTS", VALUEFUNC(_wrap_TradeVolType_NUMBER_OF_ROUND_LOTS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_ADDED", VALUEFUNC(_wrap_OrderEventType_ADDED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_MODIFIED", VALUEFUNC(_wrap_OrderEventType_MODIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_DELETED", VALUEFUNC(_wrap_OrderEventType_DELETED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_PARTIALLY_FILLED", VALUEFUNC(_wrap_OrderEventType_PARTIALLY_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_FILLED", VALUEFUNC(_wrap_OrderEventType_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_SUSPENDED", VALUEFUNC(_wrap_OrderEventType_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_RELEASED", VALUEFUNC(_wrap_OrderEventType_RELEASED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_RESTATED", VALUEFUNC(_wrap_OrderEventType_RESTATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_LOCKED", VALUEFUNC(_wrap_OrderEventType_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_TRIGGERED", VALUEFUNC(_wrap_OrderEventType_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventType_ACTIVATED", VALUEFUNC(_wrap_OrderEventType_ACTIVATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ADD_ORDER_REQUEST", VALUEFUNC(_wrap_OrderEventReason_ADD_ORDER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_MODIFY_ORDER_REQUEST", VALUEFUNC(_wrap_OrderEventReason_MODIFY_ORDER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_DELETE_ORDER_REQUEST", VALUEFUNC(_wrap_OrderEventReason_DELETE_ORDER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ORDER_ENTERED_OOB", VALUEFUNC(_wrap_OrderEventReason_ORDER_ENTERED_OOB_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ORDER_MODIFIED_OOB", VALUEFUNC(_wrap_OrderEventReason_ORDER_MODIFIED_OOB_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ORDER_DELETED_OOB", VALUEFUNC(_wrap_OrderEventReason_ORDER_DELETED_OOB_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ORDER_ACTIVATED_OR_TRIGGERED", VALUEFUNC(_wrap_OrderEventReason_ORDER_ACTIVATED_OR_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_ORDER_EXPIRED", VALUEFUNC(_wrap_OrderEventReason_ORDER_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_RESERVE_ORDER_REFRESHED", VALUEFUNC(_wrap_OrderEventReason_RESERVE_ORDER_REFRESHED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_AWAY_MARKET_BETTER", VALUEFUNC(_wrap_OrderEventReason_AWAY_MARKET_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_CORPORATE_ACTION", VALUEFUNC(_wrap_OrderEventReason_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_START_OF_DAY", VALUEFUNC(_wrap_OrderEventReason_START_OF_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEventReason_END_OF_DAY", VALUEFUNC(_wrap_OrderEventReason_END_OF_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_NONE", VALUEFUNC(_wrap_AuctionType_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_BLOCK_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_BLOCK_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_DIRECTED_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_DIRECTED_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_EXPOSURE_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_EXPOSURE_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_FLASH_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_FLASH_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_FACILITATION_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_FACILITATION_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_SOLICITATION_ORDER_AUCTION", VALUEFUNC(_wrap_AuctionType_SOLICITATION_ORDER_AUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_PRICE_IMPROVEMENT_MECHANISM", VALUEFUNC(_wrap_AuctionType_PRICE_IMPROVEMENT_MECHANISM_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionType_DIRECTED_ORDER_PRICE_IMPROVEMENT_MECHANISM", VALUEFUNC(_wrap_AuctionType_DIRECTED_ORDER_PRICE_IMPROVEMENT_MECHANISM_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionInstruction_AUTOMATED_AUCTION_PERMITTED", VALUEFUNC(_wrap_AuctionInstruction_AUTOMATED_AUCTION_PERMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AuctionInstruction_AUTOMATED_AUCTION_NOT_PERMITTED", VALUEFUNC(_wrap_AuctionInstruction_AUTOMATED_AUCTION_NOT_PERMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_NOT_LOCKED", VALUEFUNC(_wrap_LockType_NOT_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_AWAY_MARKET_NETTER", VALUEFUNC(_wrap_LockType_AWAY_MARKET_NETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_THREE_TICK_LOCKED", VALUEFUNC(_wrap_LockType_THREE_TICK_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_LOCKED_BY_MARKET_MAKER", VALUEFUNC(_wrap_LockType_LOCKED_BY_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_DIRECTED_ORDER_LOCK", VALUEFUNC(_wrap_LockType_DIRECTED_ORDER_LOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_MULTILEG_LOCK", VALUEFUNC(_wrap_LockType_MULTILEG_LOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_MARKET_ORDER_LOCK", VALUEFUNC(_wrap_LockType_MARKET_ORDER_LOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "LockType_PRE_ASSIGNMENT_LOCK", VALUEFUNC(_wrap_LockType_PRE_ASSIGNMENT_LOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "ReleaseInstruction_ISO", VALUEFUNC(_wrap_ReleaseInstruction_ISO_get), 0);
  rb_define_singleton_method(mQuickfix, "ReleaseInstruction_NO_AWAY_MARKET_BETTER_CHECK", VALUEFUNC(_wrap_ReleaseInstruction_NO_AWAY_MARKET_BETTER_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_VOLUME", VALUEFUNC(_wrap_DisclosureType_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_PRICE", VALUEFUNC(_wrap_DisclosureType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_SIDE", VALUEFUNC(_wrap_DisclosureType_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_AON", VALUEFUNC(_wrap_DisclosureType_AON_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_GENERAL", VALUEFUNC(_wrap_DisclosureType_GENERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_CLEARING_ACCOUNT", VALUEFUNC(_wrap_DisclosureType_CLEARING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureType_CMTA_ACCOUNT", VALUEFUNC(_wrap_DisclosureType_CMTA_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureInstruction_NO", VALUEFUNC(_wrap_DisclosureInstruction_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureInstruction_YES", VALUEFUNC(_wrap_DisclosureInstruction_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "DisclosureInstruction_USE_DEFAULT_SETTING", VALUEFUNC(_wrap_DisclosureInstruction_USE_DEFAULT_SETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_CUSTOMER", VALUEFUNC(_wrap_TradingCapacity_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_CUSTOMER_PROFESSIONAL", VALUEFUNC(_wrap_TradingCapacity_CUSTOMER_PROFESSIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_BROKER_DEALER", VALUEFUNC(_wrap_TradingCapacity_BROKER_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_CUSTOMER_BROKER_DEALER", VALUEFUNC(_wrap_TradingCapacity_CUSTOMER_BROKER_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_PRINCIPAL", VALUEFUNC(_wrap_TradingCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_MARKET_MAKER", VALUEFUNC(_wrap_TradingCapacity_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_AWAY_MARKET_MAKER", VALUEFUNC(_wrap_TradingCapacity_AWAY_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradingCapacity_SYSTEMATIC_INTERNALISER", VALUEFUNC(_wrap_TradingCapacity_SYSTEMATIC_INTERNALISER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingAccountType_CUSTOMER", VALUEFUNC(_wrap_ClearingAccountType_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingAccountType_FIRM", VALUEFUNC(_wrap_ClearingAccountType_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingAccountType_MARKET_MAKER", VALUEFUNC(_wrap_ClearingAccountType_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedPriceSource_NB_BID", VALUEFUNC(_wrap_RelatedPriceSource_NB_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedPriceSource_NB_OFFER", VALUEFUNC(_wrap_RelatedPriceSource_NB_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MinQtyMethod_ONCE", VALUEFUNC(_wrap_MinQtyMethod_ONCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MinQtyMethod_MULTIPLE", VALUEFUNC(_wrap_MinQtyMethod_MULTIPLE_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_NOT_TRIGGERED", VALUEFUNC(_wrap_Triggered_NOT_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_TRIGGERED", VALUEFUNC(_wrap_Triggered_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_STOP_ORDER_TRIGGERED", VALUEFUNC(_wrap_Triggered_STOP_ORDER_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_OCO_ORDER_TRIGGERED", VALUEFUNC(_wrap_Triggered_OCO_ORDER_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_OTO_ORDER_TRIGGERED", VALUEFUNC(_wrap_Triggered_OTO_ORDER_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "Triggered_OUO_ORDER_TRIGGERED", VALUEFUNC(_wrap_Triggered_OUO_ORDER_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_HOUR", VALUEFUNC(_wrap_EventTimeUnit_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_MINUTE", VALUEFUNC(_wrap_EventTimeUnit_MINUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_SECOND", VALUEFUNC(_wrap_EventTimeUnit_SECOND_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_DAY", VALUEFUNC(_wrap_EventTimeUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_WEEK", VALUEFUNC(_wrap_EventTimeUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_MONTH", VALUEFUNC(_wrap_EventTimeUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "EventTimeUnit_YEAR", VALUEFUNC(_wrap_EventTimeUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_WITHIN_FIRM", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_WITHIN_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_ANOTHER_BROKER_DEALER", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_ANOTHER_BROKER_DEALER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_OR_WITH_FIRM", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_CUSTOMER_OR_WITH_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_DIRECT_ACCESS_CUSTOMER", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_DIRECT_ACCESS_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_FOREIGN_DEALER_EQUIVALENT", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_FOREIGN_DEALER_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOrigination_ORDER_RECEIVED_FROM_EXECUTION_ONLY_SERVICE", VALUEFUNC(_wrap_OrderOrigination_ORDER_RECEIVED_FROM_EXECUTION_ONLY_SERVICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearedIndicator_NOT_CLEARED", VALUEFUNC(_wrap_ClearedIndicator_NOT_CLEARED_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearedIndicator_CLEARED", VALUEFUNC(_wrap_ClearedIndicator_CLEARED_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearedIndicator_SUBMITTED", VALUEFUNC(_wrap_ClearedIndicator_SUBMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearedIndicator_REJECTED", VALUEFUNC(_wrap_ClearedIndicator_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractRefPosType_TWO_COMPONENT_INTERCOMMODITY_SPREAD", VALUEFUNC(_wrap_ContractRefPosType_TWO_COMPONENT_INTERCOMMODITY_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractRefPosType_INDEX_OR_BASKET", VALUEFUNC(_wrap_ContractRefPosType_INDEX_OR_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractRefPosType_TWO_COMPONENT_LOCATION_BASIS", VALUEFUNC(_wrap_ContractRefPosType_TWO_COMPONENT_LOCATION_BASIS_get), 0);
  rb_define_singleton_method(mQuickfix, "ContractRefPosType_OTHER", VALUEFUNC(_wrap_ContractRefPosType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionCapacity_PRINCIPAL", VALUEFUNC(_wrap_PositionCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionCapacity_AGENT", VALUEFUNC(_wrap_PositionCapacity_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionCapacity_CUSTOMER", VALUEFUNC(_wrap_PositionCapacity_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionCapacity_COUNTERPARTY", VALUEFUNC(_wrap_PositionCapacity_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_CUM_DIVIDEND", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_CUM_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_CUM_RIGHTS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_CUM_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_EX_DIVIDEND", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_EX_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_EX_RIGHTS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_EX_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_CUM_COUPON", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_CUM_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_CUM_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_CUM_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_EX_COUPON", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_EX_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_EX_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_EX_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_CASH_SETTLEMENT", VALUEFUNC(_wrap_TradePriceCondition_CASH_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_CUM_BONUS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_CUM_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_PRICE", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_EX_BONUS", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_EX_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_GUARANTEED_DELIVERY", VALUEFUNC(_wrap_TradePriceCondition_GUARANTEED_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_SPECIAL_DIVIDEND", VALUEFUNC(_wrap_TradePriceCondition_SPECIAL_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_PRICE_IMPROVEMENT", VALUEFUNC(_wrap_TradePriceCondition_PRICE_IMPROVEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_NON_PRICE_FORMING_TRADE", VALUEFUNC(_wrap_TradePriceCondition_NON_PRICE_FORMING_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_TRADE_EXEMPTED_FROM_TRADING_OBLIGATION", VALUEFUNC(_wrap_TradePriceCondition_TRADE_EXEMPTED_FROM_TRADING_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_PRICE_PENDING", VALUEFUNC(_wrap_TradePriceCondition_PRICE_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradePriceCondition_PRICE_NOT_APPLICABLE", VALUEFUNC(_wrap_TradePriceCondition_PRICE_NOT_APPLICABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocStatus_PENDING_CLEAR", VALUEFUNC(_wrap_TradeAllocStatus_PENDING_CLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocStatus_CLAIMED", VALUEFUNC(_wrap_TradeAllocStatus_CLAIMED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocStatus_CLEARED", VALUEFUNC(_wrap_TradeAllocStatus_CLEARED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocStatus_REJECTED", VALUEFUNC(_wrap_TradeAllocStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_CLEARED_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_CLEARED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_LONG_SIDE_CLAIMED_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_LONG_SIDE_CLAIMED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_SHORT_SIDE_CLAIMED_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_SHORT_SIDE_CLAIMED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_LONG_SIDE_REJECTED_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_LONG_SIDE_REJECTED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_SHORT_SIDE_REJECTED_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_SHORT_SIDE_REJECTED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_PENDING_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_PENDING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_TRANSACTION_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_TRANSACTION_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_REMAINING_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_REMAINING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeQtyType_PREVIOUS_REMAINING_QUANTITY", VALUEFUNC(_wrap_TradeQtyType_PREVIOUS_REMAINING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocGroupInstruction_ADD", VALUEFUNC(_wrap_TradeAllocGroupInstruction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocGroupInstruction_DO_NOT_ADD", VALUEFUNC(_wrap_TradeAllocGroupInstruction_DO_NOT_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "OffsetInstruction_OFFSET", VALUEFUNC(_wrap_OffsetInstruction_OFFSET_get), 0);
  rb_define_singleton_method(mQuickfix, "OffsetInstruction_ONSET", VALUEFUNC(_wrap_OffsetInstruction_ONSET_get), 0);
  rb_define_singleton_method(mQuickfix, "SideAvgPxIndicator_NO_AVG_PRICING", VALUEFUNC(_wrap_SideAvgPxIndicator_NO_AVG_PRICING_get), 0);
  rb_define_singleton_method(mQuickfix, "SideAvgPxIndicator_TRADE_IS_PART_AVG_PRICE_GRP", VALUEFUNC(_wrap_SideAvgPxIndicator_TRADE_IS_PART_AVG_PRICE_GRP_get), 0);
  rb_define_singleton_method(mQuickfix, "SideAvgPxIndicator_LAST_TRADE_IS_PART_AVG_PRICE_GRP", VALUEFUNC(_wrap_SideAvgPxIndicator_LAST_TRADE_IS_PART_AVG_PRICE_GRP_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_NON_FIX_SOURCE", VALUEFUNC(_wrap_RelatedTradeIDSource_NON_FIX_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_TRADE_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_SECONDARY_TRADE_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_SECONDARY_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_TRADE_REPORT_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_TRADE_REPORT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_FIRM_TRADE_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_FIRM_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_SECONDARY_FIRM_TRADE_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_SECONDARY_FIRM_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedTradeIDSource_REGULATORY_TRADE_ID", VALUEFUNC(_wrap_RelatedTradeIDSource_REGULATORY_TRADE_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedPositionIDSource_POS_MAINT_RPT_ID", VALUEFUNC(_wrap_RelatedPositionIDSource_POS_MAINT_RPT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedPositionIDSource_TRANSFER_ID", VALUEFUNC(_wrap_RelatedPositionIDSource_TRANSFER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedPositionIDSource_POSITION_ENTITY_ID", VALUEFUNC(_wrap_RelatedPositionIDSource_POSITION_ENTITY_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckType_PRICE_CHECK", VALUEFUNC(_wrap_ValueCheckType_PRICE_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckType_NOTIONAL_VALUE_CHECK", VALUEFUNC(_wrap_ValueCheckType_NOTIONAL_VALUE_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckType_QUANTITY_CHECK", VALUEFUNC(_wrap_ValueCheckType_QUANTITY_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckAction_DO_NOT_CHECK", VALUEFUNC(_wrap_ValueCheckAction_DO_NOT_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckAction_CHECK", VALUEFUNC(_wrap_ValueCheckAction_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "ValueCheckAction_BEST_EFFORT", VALUEFUNC(_wrap_ValueCheckAction_BEST_EFFORT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_PartyDetailRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_INVALID_PARTY", VALUEFUNC(_wrap_PartyDetailRequestResult_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_INVALID_RELATED_PARTY", VALUEFUNC(_wrap_PartyDetailRequestResult_INVALID_RELATED_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_INVALID_PARTY_STATUS", VALUEFUNC(_wrap_PartyDetailRequestResult_INVALID_PARTY_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_NOT_AUTHORIZED", VALUEFUNC(_wrap_PartyDetailRequestResult_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestResult_OTHER", VALUEFUNC(_wrap_PartyDetailRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestStatus_ACCEPTED", VALUEFUNC(_wrap_PartyDetailRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestStatus_ACCEPTED_WITH_CHANGES", VALUEFUNC(_wrap_PartyDetailRequestStatus_ACCEPTED_WITH_CHANGES_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestStatus_REJECTED", VALUEFUNC(_wrap_PartyDetailRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailRequestStatus_ACCEPTANCE_PENDING", VALUEFUNC(_wrap_PartyDetailRequestStatus_ACCEPTANCE_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailDefinitionStatus_ACCEPTED", VALUEFUNC(_wrap_PartyDetailDefinitionStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailDefinitionStatus_ACCEPTED_WITH_CHANGES", VALUEFUNC(_wrap_PartyDetailDefinitionStatus_ACCEPTED_WITH_CHANGES_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyDetailDefinitionStatus_REJECTED", VALUEFUNC(_wrap_PartyDetailDefinitionStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_EntitlementRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_PARTY", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_RELATED_PARTY", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_RELATED_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_ENTITLEMENT_TYPE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_ENTITLEMENT_ID", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_ENTITLEMENT_ATTRIBUTE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_ENTITLEMENT_ATTRIBUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_INSTRUMENT_SCOPE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_INSTRUMENT_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_MARKET_SEGMENT_SCOPE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_MARKET_SEGMENT_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_START_DATE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_START_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INVALID_END_DATE", VALUEFUNC(_wrap_EntitlementRequestResult_INVALID_END_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INSTRUMENT_SCOPE_NOT_SUPPORTED", VALUEFUNC(_wrap_EntitlementRequestResult_INSTRUMENT_SCOPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_MARKET_SEGMENT_SCOPE_NOT_SUPPORTED", VALUEFUNC(_wrap_EntitlementRequestResult_MARKET_SEGMENT_SCOPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_ENTITLEMENT_NOT_APPROVED_FOR_PARTY", VALUEFUNC(_wrap_EntitlementRequestResult_ENTITLEMENT_NOT_APPROVED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_ENTITLEMENT_ALREADY_DEFINED_FOR_PARTY", VALUEFUNC(_wrap_EntitlementRequestResult_ENTITLEMENT_ALREADY_DEFINED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY", VALUEFUNC(_wrap_EntitlementRequestResult_INSTRUMENT_NOT_APPROVED_FOR_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_NOT_AUTHORIZED", VALUEFUNC(_wrap_EntitlementRequestResult_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementRequestResult_OTHER", VALUEFUNC(_wrap_EntitlementRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_ACCEPTED", VALUEFUNC(_wrap_EntitlementStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_ACCEPTED_WITH_CHANGES", VALUEFUNC(_wrap_EntitlementStatus_ACCEPTED_WITH_CHANGES_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_REJECTED", VALUEFUNC(_wrap_EntitlementStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_PENDING", VALUEFUNC(_wrap_EntitlementStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_REQUESTED", VALUEFUNC(_wrap_EntitlementStatus_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementStatus_DEFERRED", VALUEFUNC(_wrap_EntitlementStatus_DEFERRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchAckStatus_RECEIVED_NOT_PROCESSED", VALUEFUNC(_wrap_TradeMatchAckStatus_RECEIVED_NOT_PROCESSED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchAckStatus_ACCEPTED", VALUEFUNC(_wrap_TradeMatchAckStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchAckStatus_REJECTED", VALUEFUNC(_wrap_TradeMatchAckStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_SUCCESSFUL", VALUEFUNC(_wrap_TradeMatchRejectReason_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_INVALID_PARTY_INFORMATION", VALUEFUNC(_wrap_TradeMatchRejectReason_INVALID_PARTY_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TradeMatchRejectReason_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_UNAUTHORIZED", VALUEFUNC(_wrap_TradeMatchRejectReason_UNAUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_INVALID_TRADE_TYPE", VALUEFUNC(_wrap_TradeMatchRejectReason_INVALID_TRADE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeMatchRejectReason_OTHER", VALUEFUNC(_wrap_TradeMatchRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceMovementType_AMOUNT", VALUEFUNC(_wrap_PriceMovementType_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceMovementType_PERCENTAGE", VALUEFUNC(_wrap_PriceMovementType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_INITIAL_BLOCK_TRADE", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_INITIAL_BLOCK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_ALLOCATION", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_CLEARING", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_COMPRESSION", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_COMPRESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_NOVATION", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_NOVATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_TERMINATION", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDEvent_POST_TRD_VAL", VALUEFUNC(_wrap_RegulatoryTradeIDEvent_POST_TRD_VAL_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDSource_UNIQUE_TRANSACTION_IDENTIFIER", VALUEFUNC(_wrap_RegulatoryTradeIDSource_UNIQUE_TRANSACTION_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_CURRENT", VALUEFUNC(_wrap_RegulatoryTradeIDType_CURRENT_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_PREVIOUS", VALUEFUNC(_wrap_RegulatoryTradeIDType_PREVIOUS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_BLOCK", VALUEFUNC(_wrap_RegulatoryTradeIDType_BLOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_RELATED", VALUEFUNC(_wrap_RegulatoryTradeIDType_RELATED_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_CLEARED_BLOCK_TRADE", VALUEFUNC(_wrap_RegulatoryTradeIDType_CLEARED_BLOCK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDType_TRADING_VENUE_TRANSACTION_IDENTIFIER", VALUEFUNC(_wrap_RegulatoryTradeIDType_TRADING_VENUE_TRANSACTION_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingIntention_DO_NOT_INTEND_TO_CLEAR", VALUEFUNC(_wrap_ClearingIntention_DO_NOT_INTEND_TO_CLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingIntention_INTEND_TO_CLEAR", VALUEFUNC(_wrap_ClearingIntention_INTEND_TO_CLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmationMethod_NON_ELECTRONIC", VALUEFUNC(_wrap_ConfirmationMethod_NON_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmationMethod_ELECTRONIC", VALUEFUNC(_wrap_ConfirmationMethod_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmationMethod_UNCONFIRMED", VALUEFUNC(_wrap_ConfirmationMethod_UNCONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "VerificationMethod_NON_ELECTRONIC", VALUEFUNC(_wrap_VerificationMethod_NON_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "VerificationMethod_ELECTRONIC", VALUEFUNC(_wrap_VerificationMethod_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_NO_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_NO_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_END_USER_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_END_USER_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_INTER_AFFILIATE_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_INTER_AFFILIATE_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_TREASURY_AFFILIATE_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_TREASURY_AFFILIATE_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingRequirementException_COOPERATIVE_EXCEPTION", VALUEFUNC(_wrap_ClearingRequirementException_COOPERATIVE_EXCEPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "IRSDirection_PAY", VALUEFUNC(_wrap_IRSDirection_PAY_get), 0);
  rb_define_singleton_method(mQuickfix, "IRSDirection_RCV", VALUEFUNC(_wrap_IRSDirection_RCV_get), 0);
  rb_define_singleton_method(mQuickfix, "IRSDirection_NA", VALUEFUNC(_wrap_IRSDirection_NA_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_RT", VALUEFUNC(_wrap_RegulatoryReportType_RT_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_PET", VALUEFUNC(_wrap_RegulatoryReportType_PET_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_SNAPSHOT", VALUEFUNC(_wrap_RegulatoryReportType_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_CONFIRMATION", VALUEFUNC(_wrap_RegulatoryReportType_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_RTPET", VALUEFUNC(_wrap_RegulatoryReportType_RTPET_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_PET_CONFIRMATION", VALUEFUNC(_wrap_RegulatoryReportType_PET_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_RTPET_CONFIRMATION", VALUEFUNC(_wrap_RegulatoryReportType_RTPET_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_POST_TRADE", VALUEFUNC(_wrap_RegulatoryReportType_POST_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_VERIFICATION", VALUEFUNC(_wrap_RegulatoryReportType_VERIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_PST_TRD_EVNT", VALUEFUNC(_wrap_RegulatoryReportType_PST_TRD_EVNT_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_PST_TRD_EVNT_RT_REPORTABLE", VALUEFUNC(_wrap_RegulatoryReportType_PST_TRD_EVNT_RT_REPORTABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_LMTF", VALUEFUNC(_wrap_RegulatoryReportType_LMTF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_DATF", VALUEFUNC(_wrap_RegulatoryReportType_DATF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_VOLO", VALUEFUNC(_wrap_RegulatoryReportType_VOLO_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_FWAF", VALUEFUNC(_wrap_RegulatoryReportType_FWAF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_IDAF", VALUEFUNC(_wrap_RegulatoryReportType_IDAF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_VOLW", VALUEFUNC(_wrap_RegulatoryReportType_VOLW_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_FULF", VALUEFUNC(_wrap_RegulatoryReportType_FULF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_FULA", VALUEFUNC(_wrap_RegulatoryReportType_FULA_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_FULV", VALUEFUNC(_wrap_RegulatoryReportType_FULV_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_FULJ", VALUEFUNC(_wrap_RegulatoryReportType_FULJ_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_COAF", VALUEFUNC(_wrap_RegulatoryReportType_COAF_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_ORDER", VALUEFUNC(_wrap_RegulatoryReportType_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_CHILD_ORDER", VALUEFUNC(_wrap_RegulatoryReportType_CHILD_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_ORDER_ROUTE", VALUEFUNC(_wrap_RegulatoryReportType_ORDER_ROUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_TRADE", VALUEFUNC(_wrap_RegulatoryReportType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_QUOTE", VALUEFUNC(_wrap_RegulatoryReportType_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_SUPPLEMENT", VALUEFUNC(_wrap_RegulatoryReportType_SUPPLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_NEW_TRANSACTION", VALUEFUNC(_wrap_RegulatoryReportType_NEW_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_TRANSACTION_CORRECTION", VALUEFUNC(_wrap_RegulatoryReportType_TRANSACTION_CORRECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_TRANSACTION_MODIFICATION", VALUEFUNC(_wrap_RegulatoryReportType_TRANSACTION_MODIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_COLLATERAL_UPDATE", VALUEFUNC(_wrap_RegulatoryReportType_COLLATERAL_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_MARGIN_UPDATE", VALUEFUNC(_wrap_RegulatoryReportType_MARGIN_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_TRANSACTION_REPORTED_IN_ERROR", VALUEFUNC(_wrap_RegulatoryReportType_TRANSACTION_REPORTED_IN_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryReportType_TERMINATION_EARLY_TERMINATION", VALUEFUNC(_wrap_RegulatoryReportType_TERMINATION_EARLY_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCollateralization_UNCOLLATERALIZED", VALUEFUNC(_wrap_TradeCollateralization_UNCOLLATERALIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCollateralization_PARTIALLY_COLLATERALIZED", VALUEFUNC(_wrap_TradeCollateralization_PARTIALLY_COLLATERALIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCollateralization_ONE_WAY_COLLATERALLIZATION", VALUEFUNC(_wrap_TradeCollateralization_ONE_WAY_COLLATERALLIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCollateralization_FULLY_COLLATERALIZED", VALUEFUNC(_wrap_TradeCollateralization_FULLY_COLLATERALIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCollateralization_NET_EXPOSURE", VALUEFUNC(_wrap_TradeCollateralization_NET_EXPOSURE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_NOVATION", VALUEFUNC(_wrap_TradeContinuation_NOVATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_PARTIAL_NOVATION", VALUEFUNC(_wrap_TradeContinuation_PARTIAL_NOVATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_TRADE_UNWIND", VALUEFUNC(_wrap_TradeContinuation_TRADE_UNWIND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_PARTIAL_TRADE_UNWIND", VALUEFUNC(_wrap_TradeContinuation_PARTIAL_TRADE_UNWIND_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_EXERCISE", VALUEFUNC(_wrap_TradeContinuation_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_NETTING", VALUEFUNC(_wrap_TradeContinuation_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_FULL_NETTING", VALUEFUNC(_wrap_TradeContinuation_FULL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_PARTIAL_NETTING", VALUEFUNC(_wrap_TradeContinuation_PARTIAL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_AMENDMENT", VALUEFUNC(_wrap_TradeContinuation_AMENDMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_INCREASE", VALUEFUNC(_wrap_TradeContinuation_INCREASE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_CREDIT_EVENT", VALUEFUNC(_wrap_TradeContinuation_CREDIT_EVENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_STRATEGIC_RESTRUCTURING", VALUEFUNC(_wrap_TradeContinuation_STRATEGIC_RESTRUCTURING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_SUCCESSION_EVENT_REORGANIZATION", VALUEFUNC(_wrap_TradeContinuation_SUCCESSION_EVENT_REORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_SUCCESSION_EVENT_RENAMING", VALUEFUNC(_wrap_TradeContinuation_SUCCESSION_EVENT_RENAMING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_PORTING", VALUEFUNC(_wrap_TradeContinuation_PORTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_WITHDRAWL", VALUEFUNC(_wrap_TradeContinuation_WITHDRAWL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_VOID", VALUEFUNC(_wrap_TradeContinuation_VOID_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_ACCOUNT_TRANSFER", VALUEFUNC(_wrap_TradeContinuation_ACCOUNT_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_GIVE_UP", VALUEFUNC(_wrap_TradeContinuation_GIVE_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_TAKE_UP", VALUEFUNC(_wrap_TradeContinuation_TAKE_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_AVERAGE_PRICING", VALUEFUNC(_wrap_TradeContinuation_AVERAGE_PRICING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_REVERSAL", VALUEFUNC(_wrap_TradeContinuation_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_ALLOC_TRD_POSTING", VALUEFUNC(_wrap_TradeContinuation_ALLOC_TRD_POSTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_CASCADE", VALUEFUNC(_wrap_TradeContinuation_CASCADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_DELIVERY", VALUEFUNC(_wrap_TradeContinuation_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_OPTION_ASGN", VALUEFUNC(_wrap_TradeContinuation_OPTION_ASGN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_EXPIRATION", VALUEFUNC(_wrap_TradeContinuation_EXPIRATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_MATURITY", VALUEFUNC(_wrap_TradeContinuation_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_EQUAL_POS_ADJ", VALUEFUNC(_wrap_TradeContinuation_EQUAL_POS_ADJ_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_UNEQUAL_POS_ADJ", VALUEFUNC(_wrap_TradeContinuation_UNEQUAL_POS_ADJ_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_CORRECTION", VALUEFUNC(_wrap_TradeContinuation_CORRECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_EARLY_TERMINATION", VALUEFUNC(_wrap_TradeContinuation_EARLY_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_RERATE", VALUEFUNC(_wrap_TradeContinuation_RERATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContinuation_OTHER", VALUEFUNC(_wrap_TradeContinuation_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_INTEREST_RATE", VALUEFUNC(_wrap_AssetClass_INTEREST_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_CURRENCY", VALUEFUNC(_wrap_AssetClass_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_CREDIT", VALUEFUNC(_wrap_AssetClass_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_EQUITY", VALUEFUNC(_wrap_AssetClass_EQUITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_COMMODITY", VALUEFUNC(_wrap_AssetClass_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_OTHER", VALUEFUNC(_wrap_AssetClass_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_CASH", VALUEFUNC(_wrap_AssetClass_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_DEBT", VALUEFUNC(_wrap_AssetClass_DEBT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_FUND", VALUEFUNC(_wrap_AssetClass_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_LOAN_FACILITY", VALUEFUNC(_wrap_AssetClass_LOAN_FACILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetClass_INDEX", VALUEFUNC(_wrap_AssetClass_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_METALS", VALUEFUNC(_wrap_AssetSubClass_METALS_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_BULLION", VALUEFUNC(_wrap_AssetSubClass_BULLION_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_ENERGY", VALUEFUNC(_wrap_AssetSubClass_ENERGY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_COMMODITY_INDEX", VALUEFUNC(_wrap_AssetSubClass_COMMODITY_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_AGRICULTURAL", VALUEFUNC(_wrap_AssetSubClass_AGRICULTURAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_ENVIRONMENTAL", VALUEFUNC(_wrap_AssetSubClass_ENVIRONMENTAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FREIGHT", VALUEFUNC(_wrap_AssetSubClass_FREIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FERTILIZER", VALUEFUNC(_wrap_AssetSubClass_FERTILIZER_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_INDUSTRIAL_PRODUCT", VALUEFUNC(_wrap_AssetSubClass_INDUSTRIAL_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_INFLATION", VALUEFUNC(_wrap_AssetSubClass_INFLATION_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_PAPER", VALUEFUNC(_wrap_AssetSubClass_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_POLYPROPYLENE", VALUEFUNC(_wrap_AssetSubClass_POLYPROPYLENE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_OFFICIAL_ECONOMIC_STATISTICS", VALUEFUNC(_wrap_AssetSubClass_OFFICIAL_ECONOMIC_STATISTICS_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_SINGLE_NAME", VALUEFUNC(_wrap_AssetSubClass_SINGLE_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_CREDIT_INDEX", VALUEFUNC(_wrap_AssetSubClass_CREDIT_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_INDEX_TRANCHE", VALUEFUNC(_wrap_AssetSubClass_INDEX_TRANCHE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_CREDIT_BASKET", VALUEFUNC(_wrap_AssetSubClass_CREDIT_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_BASKET", VALUEFUNC(_wrap_AssetSubClass_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FX_CROSS_RATES", VALUEFUNC(_wrap_AssetSubClass_FX_CROSS_RATES_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FX_EMERGING_MARKETS", VALUEFUNC(_wrap_AssetSubClass_FX_EMERGING_MARKETS_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FX_MAJORS", VALUEFUNC(_wrap_AssetSubClass_FX_MAJORS_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_GOVERNMENT", VALUEFUNC(_wrap_AssetSubClass_GOVERNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_AGENCY", VALUEFUNC(_wrap_AssetSubClass_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_CORPORATE", VALUEFUNC(_wrap_AssetSubClass_CORPORATE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_FINANCING", VALUEFUNC(_wrap_AssetSubClass_FINANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_MONEY_MARKET", VALUEFUNC(_wrap_AssetSubClass_MONEY_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_MORTGAGE", VALUEFUNC(_wrap_AssetSubClass_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_MUNICIPAL", VALUEFUNC(_wrap_AssetSubClass_MUNICIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_COMMON", VALUEFUNC(_wrap_AssetSubClass_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_PREFERRED", VALUEFUNC(_wrap_AssetSubClass_PREFERRED_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_EQUITY_INDEX", VALUEFUNC(_wrap_AssetSubClass_EQUITY_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_EQUITY_BASKET", VALUEFUNC(_wrap_AssetSubClass_EQUITY_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_DIVIDEND_INDEX", VALUEFUNC(_wrap_AssetSubClass_DIVIDEND_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_STOCK_DIVIDEND", VALUEFUNC(_wrap_AssetSubClass_STOCK_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_EXCHANGE_TRADED_FUND", VALUEFUNC(_wrap_AssetSubClass_EXCHANGE_TRADED_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_VOLATILITY_INDEX", VALUEFUNC(_wrap_AssetSubClass_VOLATILITY_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_MUTUAL_FUND", VALUEFUNC(_wrap_AssetSubClass_MUTUAL_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_COLLECTIVE_INVESTMENT_VEHICLE", VALUEFUNC(_wrap_AssetSubClass_COLLECTIVE_INVESTMENT_VEHICLE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_INVESTMENT_PROGRAM", VALUEFUNC(_wrap_AssetSubClass_INVESTMENT_PROGRAM_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_SPECIALIZED_ACCOUNT_PROGRAM", VALUEFUNC(_wrap_AssetSubClass_SPECIALIZED_ACCOUNT_PROGRAM_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_SINGLE_CURRENCY", VALUEFUNC(_wrap_AssetSubClass_SINGLE_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_CROSS_CURRENCY", VALUEFUNC(_wrap_AssetSubClass_CROSS_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_TERM_LOAN", VALUEFUNC(_wrap_AssetSubClass_TERM_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_BRIDGE_LOAN", VALUEFUNC(_wrap_AssetSubClass_BRIDGE_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_LETTER_OF_CREDIT", VALUEFUNC(_wrap_AssetSubClass_LETTER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_EXOTIC", VALUEFUNC(_wrap_AssetSubClass_EXOTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_OTHER_C10", VALUEFUNC(_wrap_AssetSubClass_OTHER_C10_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetSubClass_OTHER", VALUEFUNC(_wrap_AssetSubClass_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapClass_BASIS_SWAP", VALUEFUNC(_wrap_SwapClass_BASIS_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapClass_INDEX_SWAP", VALUEFUNC(_wrap_SwapClass_INDEX_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapClass_BROAD_BASED_SECURITY_SWAP", VALUEFUNC(_wrap_SwapClass_BROAD_BASED_SECURITY_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapClass_BASKET_SWAP", VALUEFUNC(_wrap_SwapClass_BASKET_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponType_ZERO", VALUEFUNC(_wrap_CouponType_ZERO_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponType_FIXED_RATE", VALUEFUNC(_wrap_CouponType_FIXED_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponType_FLOATING_RATE", VALUEFUNC(_wrap_CouponType_FLOATING_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponType_STRUCTURED", VALUEFUNC(_wrap_CouponType_STRUCTURED_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_DAY", VALUEFUNC(_wrap_CouponFrequencyUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_WEEK", VALUEFUNC(_wrap_CouponFrequencyUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_MONTH", VALUEFUNC(_wrap_CouponFrequencyUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_YEAR", VALUEFUNC(_wrap_CouponFrequencyUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_HOUR", VALUEFUNC(_wrap_CouponFrequencyUnit_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_MINUTE", VALUEFUNC(_wrap_CouponFrequencyUnit_MINUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_SECOND", VALUEFUNC(_wrap_CouponFrequencyUnit_SECOND_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponFrequencyUnit_TERM", VALUEFUNC(_wrap_CouponFrequencyUnit_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ONE_ONE", VALUEFUNC(_wrap_CouponDayCount_ONE_ONE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_THREE_SIXTY_US", VALUEFUNC(_wrap_CouponDayCount_THIRTY_THREE_SIXTY_US_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_THREE_SIXTY_SIA", VALUEFUNC(_wrap_CouponDayCount_THIRTY_THREE_SIXTY_SIA_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_THREE_SIXTY_M", VALUEFUNC(_wrap_CouponDayCount_THIRTY_THREE_SIXTY_M_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_E_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_THIRTY_E_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_E_THREE_SIXTY_ISDA", VALUEFUNC(_wrap_CouponDayCount_THIRTY_E_THREE_SIXTY_ISDA_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_ACT_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_THREE_SIXTY_FIVE_FIXED", VALUEFUNC(_wrap_CouponDayCount_ACT_THREE_SIXTY_FIVE_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_ACT_AFB", VALUEFUNC(_wrap_CouponDayCount_ACT_ACT_AFB_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_ACT_ICMA", VALUEFUNC(_wrap_CouponDayCount_ACT_ACT_ICMA_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_ACT_ISMA_ULTIMO", VALUEFUNC(_wrap_CouponDayCount_ACT_ACT_ISMA_ULTIMO_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_ACT_ISDA", VALUEFUNC(_wrap_CouponDayCount_ACT_ACT_ISDA_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_BUS_TWO_FIFTY_TWO", VALUEFUNC(_wrap_CouponDayCount_BUS_TWO_FIFTY_TWO_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_E_PLUS_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_THIRTY_E_PLUS_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT_THREE_SIXTY_FIVE_L", VALUEFUNC(_wrap_CouponDayCount_ACT_THREE_SIXTY_FIVE_L_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_NL_THREE_SIXTY_FIVE", VALUEFUNC(_wrap_CouponDayCount_NL_THREE_SIXTY_FIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_NL_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_NL_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_ACT364", VALUEFUNC(_wrap_CouponDayCount_ACT364_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_THREE_SIXTY_FIVE", VALUEFUNC(_wrap_CouponDayCount_THIRTY_THREE_SIXTY_FIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_ACTUAL", VALUEFUNC(_wrap_CouponDayCount_THIRTY_ACTUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_THREE_SIXTY_ICMA", VALUEFUNC(_wrap_CouponDayCount_THIRTY_THREE_SIXTY_ICMA_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_E_TWO_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_THIRTY_E_TWO_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_THIRTY_E_THREE_THREE_SIXTY", VALUEFUNC(_wrap_CouponDayCount_THIRTY_E_THREE_THREE_SIXTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CouponDayCount_OTHER", VALUEFUNC(_wrap_CouponDayCount_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "LienSeniority_UNKNOWN", VALUEFUNC(_wrap_LienSeniority_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "LienSeniority_FIRST_LIEN", VALUEFUNC(_wrap_LienSeniority_FIRST_LIEN_get), 0);
  rb_define_singleton_method(mQuickfix, "LienSeniority_SECOND_LIEN", VALUEFUNC(_wrap_LienSeniority_SECOND_LIEN_get), 0);
  rb_define_singleton_method(mQuickfix, "LienSeniority_THIRD_LIEN", VALUEFUNC(_wrap_LienSeniority_THIRD_LIEN_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_BRIDGE_LOAN", VALUEFUNC(_wrap_LoanFacility_BRIDGE_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_LETTER_OF_CREDIT", VALUEFUNC(_wrap_LoanFacility_LETTER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_REVOLVING_LOAN", VALUEFUNC(_wrap_LoanFacility_REVOLVING_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_SWINGLINE_FUNDING", VALUEFUNC(_wrap_LoanFacility_SWINGLINE_FUNDING_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_TERM_LOAN", VALUEFUNC(_wrap_LoanFacility_TERM_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "LoanFacility_TRADE_CLAIM", VALUEFUNC(_wrap_LoanFacility_TRADE_CLAIM_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_ASIAN", VALUEFUNC(_wrap_ReferenceEntityType_ASIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_AUSTRALIAN_NEW_ZEALAND", VALUEFUNC(_wrap_ReferenceEntityType_AUSTRALIAN_NEW_ZEALAND_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_EUROPEAN_EMERGING_MARKETS", VALUEFUNC(_wrap_ReferenceEntityType_EUROPEAN_EMERGING_MARKETS_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_JAPANESE", VALUEFUNC(_wrap_ReferenceEntityType_JAPANESE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_NORTH_AMERICAN_HIGH_YIELD", VALUEFUNC(_wrap_ReferenceEntityType_NORTH_AMERICAN_HIGH_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_NORTH_AMERICAN_INSURANCE", VALUEFUNC(_wrap_ReferenceEntityType_NORTH_AMERICAN_INSURANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_NORTH_AMERICAN_INVESTMENT_GRADE", VALUEFUNC(_wrap_ReferenceEntityType_NORTH_AMERICAN_INVESTMENT_GRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_SINGAPOREAN", VALUEFUNC(_wrap_ReferenceEntityType_SINGAPOREAN_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_WESTERN_EUROPEAN", VALUEFUNC(_wrap_ReferenceEntityType_WESTERN_EUROPEAN_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceEntityType_WESTERN_EUROPEAN_INSURANCE", VALUEFUNC(_wrap_ReferenceEntityType_WESTERN_EUROPEAN_INSURANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "BlockTrdAllocIndicator_BLOCK_TO_BE_ALLOCATED", VALUEFUNC(_wrap_BlockTrdAllocIndicator_BLOCK_TO_BE_ALLOCATED_get), 0);
  rb_define_singleton_method(mQuickfix, "BlockTrdAllocIndicator_BLOCK_NOT_TO_BE_ALLOCATED", VALUEFUNC(_wrap_BlockTrdAllocIndicator_BLOCK_NOT_TO_BE_ALLOCATED_get), 0);
  rb_define_singleton_method(mQuickfix, "BlockTrdAllocIndicator_ALLOCATED_TRADE", VALUEFUNC(_wrap_BlockTrdAllocIndicator_ALLOCATED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingObligationType_BOND", VALUEFUNC(_wrap_UnderlyingObligationType_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingObligationType_CONVERTIBLE_BOND", VALUEFUNC(_wrap_UnderlyingObligationType_CONVERTIBLE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingObligationType_MORTGAGE", VALUEFUNC(_wrap_UnderlyingObligationType_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingObligationType_LOAN", VALUEFUNC(_wrap_UnderlyingObligationType_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlQuoteMethod_BID", VALUEFUNC(_wrap_CashSettlQuoteMethod_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlQuoteMethod_MID", VALUEFUNC(_wrap_CashSettlQuoteMethod_MID_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlQuoteMethod_OFFER", VALUEFUNC(_wrap_CashSettlQuoteMethod_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_MARKET", VALUEFUNC(_wrap_CashSettlValuationMethod_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_HIGHEST", VALUEFUNC(_wrap_CashSettlValuationMethod_HIGHEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_AVERAGE_MARKET", VALUEFUNC(_wrap_CashSettlValuationMethod_AVERAGE_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_AVERAGE_HIGHEST", VALUEFUNC(_wrap_CashSettlValuationMethod_AVERAGE_HIGHEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_BLENDED_MARKET", VALUEFUNC(_wrap_CashSettlValuationMethod_BLENDED_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_BLENDED_HIGHEST", VALUEFUNC(_wrap_CashSettlValuationMethod_BLENDED_HIGHEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_AVERAGE_BLENDED_MARKET", VALUEFUNC(_wrap_CashSettlValuationMethod_AVERAGE_BLENDED_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlValuationMethod_AVERAGE_BLENDED_HIGHEST", VALUEFUNC(_wrap_CashSettlValuationMethod_AVERAGE_BLENDED_HIGHEST_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamType_PAYMENT_CASH_SETTLEMENT", VALUEFUNC(_wrap_StreamType_PAYMENT_CASH_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamType_PHYSICAL_DELIVERY", VALUEFUNC(_wrap_StreamType_PHYSICAL_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_MANDATORY_EARLY_TERMINATION", VALUEFUNC(_wrap_ProvisionType_MANDATORY_EARLY_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_OPTIONAL_EARLY_TERMINATION", VALUEFUNC(_wrap_ProvisionType_OPTIONAL_EARLY_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_CANCELABLE", VALUEFUNC(_wrap_ProvisionType_CANCELABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_EXTENDABLE", VALUEFUNC(_wrap_ProvisionType_EXTENDABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_MUTUAL_EARLY_TERMINATION", VALUEFUNC(_wrap_ProvisionType_MUTUAL_EARLY_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_EVERGREEN", VALUEFUNC(_wrap_ProvisionType_EVERGREEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_CALLABLE", VALUEFUNC(_wrap_ProvisionType_CALLABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionType_PUTTABLE", VALUEFUNC(_wrap_ProvisionType_PUTTABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionDateTenorUnit_DAY", VALUEFUNC(_wrap_ProvisionDateTenorUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionDateTenorUnit_WEEK", VALUEFUNC(_wrap_ProvisionDateTenorUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionDateTenorUnit_MONTH", VALUEFUNC(_wrap_ProvisionDateTenorUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionDateTenorUnit_YEAR", VALUEFUNC(_wrap_ProvisionDateTenorUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCalculationAgent_EXERCISING_PARTY", VALUEFUNC(_wrap_ProvisionCalculationAgent_EXERCISING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCalculationAgent_NON_EXERCISING_PARTY", VALUEFUNC(_wrap_ProvisionCalculationAgent_NON_EXERCISING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCalculationAgent_MASTER_AGREEENT", VALUEFUNC(_wrap_ProvisionCalculationAgent_MASTER_AGREEENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCalculationAgent_SUPPLEMENT", VALUEFUNC(_wrap_ProvisionCalculationAgent_SUPPLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionSinglePartyBuyerSide_BUY", VALUEFUNC(_wrap_ProvisionOptionSinglePartyBuyerSide_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionSinglePartyBuyerSide_SELL", VALUEFUNC(_wrap_ProvisionOptionSinglePartyBuyerSide_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_CASH_PRICE", VALUEFUNC(_wrap_ProvisionCashSettlMethod_CASH_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_CASH_PRICE_ALTERNATE", VALUEFUNC(_wrap_ProvisionCashSettlMethod_CASH_PRICE_ALTERNATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_PAR_YIELD_CURVE_ADJUSTED", VALUEFUNC(_wrap_ProvisionCashSettlMethod_PAR_YIELD_CURVE_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_ZERO_COUPON_YIELD_CURVE_ADJUSTED", VALUEFUNC(_wrap_ProvisionCashSettlMethod_ZERO_COUPON_YIELD_CURVE_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_PAR_YIELD_CURVE_UNADJUSTED", VALUEFUNC(_wrap_ProvisionCashSettlMethod_PAR_YIELD_CURVE_UNADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_CROSS_CURRENCY", VALUEFUNC(_wrap_ProvisionCashSettlMethod_CROSS_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlMethod_COLLATERALIZED_PRICE", VALUEFUNC(_wrap_ProvisionCashSettlMethod_COLLATERALIZED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlQuoteType_BID", VALUEFUNC(_wrap_ProvisionCashSettlQuoteType_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlQuoteType_MID", VALUEFUNC(_wrap_ProvisionCashSettlQuoteType_MID_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlQuoteType_OFFER", VALUEFUNC(_wrap_ProvisionCashSettlQuoteType_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlQuoteType_EXERCISING_PARTY_PAYS", VALUEFUNC(_wrap_ProvisionCashSettlQuoteType_EXERCISING_PARTY_PAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseEarliestDateOffsetUnit_DAY", VALUEFUNC(_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseEarliestDateOffsetUnit_WEEK", VALUEFUNC(_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseEarliestDateOffsetUnit_MONTH", VALUEFUNC(_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseEarliestDateOffsetUnit_YEAR", VALUEFUNC(_wrap_ProvisionOptionExerciseEarliestDateOffsetUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseFixedDateType_UNADJUSTED", VALUEFUNC(_wrap_ProvisionOptionExerciseFixedDateType_UNADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionOptionExerciseFixedDateType_ADJUSTED", VALUEFUNC(_wrap_ProvisionOptionExerciseFixedDateType_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlPaymentDateType_UNADJUSTED", VALUEFUNC(_wrap_ProvisionCashSettlPaymentDateType_UNADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionCashSettlPaymentDateType_ADJUSTED", VALUEFUNC(_wrap_ProvisionCashSettlPaymentDateType_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventUnit_DAY", VALUEFUNC(_wrap_ProtectionTermEventUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventUnit_WEEK", VALUEFUNC(_wrap_ProtectionTermEventUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventUnit_MONTH", VALUEFUNC(_wrap_ProtectionTermEventUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventUnit_YEAR", VALUEFUNC(_wrap_ProtectionTermEventUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_BUSINESS", VALUEFUNC(_wrap_ProtectionTermEventDayType_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_CALENDAR", VALUEFUNC(_wrap_ProtectionTermEventDayType_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_COMMODITY_BUSINESS", VALUEFUNC(_wrap_ProtectionTermEventDayType_COMMODITY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_CURRENCY_BUSINESS", VALUEFUNC(_wrap_ProtectionTermEventDayType_CURRENCY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_EXCHANGE_BUSINESS", VALUEFUNC(_wrap_ProtectionTermEventDayType_EXCHANGE_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventDayType_SCHEDULED_TRADING_DAY", VALUEFUNC(_wrap_ProtectionTermEventDayType_SCHEDULED_TRADING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_HOLDING_OBLIGATIONS", VALUEFUNC(_wrap_ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_HOLDING_OBLIGATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_CREDIT_EVENT_NOTICES", VALUEFUNC(_wrap_ProtectionTermEventQualifier_RESTRUCTURING_MULTIPLE_CREDIT_EVENT_NOTICES_get), 0);
  rb_define_singleton_method(mQuickfix, "ProtectionTermEventQualifier_FLOATING_RATE_INTEREST_SHORTFALL", VALUEFUNC(_wrap_ProtectionTermEventQualifier_FLOATING_RATE_INTEREST_SHORTFALL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_BROKERAGE", VALUEFUNC(_wrap_PaymentType_BROKERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_UPFRONT_FEE", VALUEFUNC(_wrap_PaymentType_UPFRONT_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_INDEPENDENT_AMOUNT_COLLATERAL", VALUEFUNC(_wrap_PaymentType_INDEPENDENT_AMOUNT_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_PRINCIPAL_EXCHANGE", VALUEFUNC(_wrap_PaymentType_PRINCIPAL_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_NOVATION_TERMINATION", VALUEFUNC(_wrap_PaymentType_NOVATION_TERMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_EARLY_TERMINATION_PROVISION", VALUEFUNC(_wrap_PaymentType_EARLY_TERMINATION_PROVISION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_CANCELABLE_PROVISION", VALUEFUNC(_wrap_PaymentType_CANCELABLE_PROVISION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_EXTENDIBLE_PROVISION", VALUEFUNC(_wrap_PaymentType_EXTENDIBLE_PROVISION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_CAP_RATE_PROVISION", VALUEFUNC(_wrap_PaymentType_CAP_RATE_PROVISION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_FLOOR_RATE_PROVISION", VALUEFUNC(_wrap_PaymentType_FLOOR_RATE_PROVISION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_OPTION_PREMIUM", VALUEFUNC(_wrap_PaymentType_OPTION_PREMIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_SETTLEMENT_PAYMENT", VALUEFUNC(_wrap_PaymentType_SETTLEMENT_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_CASH_SETTL", VALUEFUNC(_wrap_PaymentType_CASH_SETTL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_SECURITY_LENDING", VALUEFUNC(_wrap_PaymentType_SECURITY_LENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_REBATE", VALUEFUNC(_wrap_PaymentType_REBATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentType_OTHER", VALUEFUNC(_wrap_PaymentType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentPaySide_BUY", VALUEFUNC(_wrap_PaymentPaySide_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentPaySide_SELL", VALUEFUNC(_wrap_PaymentPaySide_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSettlStyle_STANDARD", VALUEFUNC(_wrap_PaymentSettlStyle_STANDARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSettlStyle_NET", VALUEFUNC(_wrap_PaymentSettlStyle_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSettlStyle_STANDARDF_NET", VALUEFUNC(_wrap_PaymentSettlStyle_STANDARDF_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_PERIODIC", VALUEFUNC(_wrap_PaymentStreamType_PERIODIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_INITIAL", VALUEFUNC(_wrap_PaymentStreamType_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_SINGLE", VALUEFUNC(_wrap_PaymentStreamType_SINGLE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_DIVIDEND", VALUEFUNC(_wrap_PaymentStreamType_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_INTEREST", VALUEFUNC(_wrap_PaymentStreamType_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_DIVIDEND_RETURN", VALUEFUNC(_wrap_PaymentStreamType_DIVIDEND_RETURN_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_PRICE_RETURN", VALUEFUNC(_wrap_PaymentStreamType_PRICE_RETURN_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_TOTAL_RETURN", VALUEFUNC(_wrap_PaymentStreamType_TOTAL_RETURN_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_VARIANCE", VALUEFUNC(_wrap_PaymentStreamType_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamType_CORRELATION", VALUEFUNC(_wrap_PaymentStreamType_CORRELATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamDiscountType_STANDARD", VALUEFUNC(_wrap_PaymentStreamDiscountType_STANDARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamDiscountType_FRA", VALUEFUNC(_wrap_PaymentStreamDiscountType_FRA_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCompoundingMethod_NONE", VALUEFUNC(_wrap_PaymentStreamCompoundingMethod_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCompoundingMethod_FLAT", VALUEFUNC(_wrap_PaymentStreamCompoundingMethod_FLAT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCompoundingMethod_STRAIGHT", VALUEFUNC(_wrap_PaymentStreamCompoundingMethod_STRAIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCompoundingMethod_SPREAD_EXCLUSIVE", VALUEFUNC(_wrap_PaymentStreamCompoundingMethod_SPREAD_EXCLUSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentFrequencyUnit_DAY", VALUEFUNC(_wrap_PaymentStreamPaymentFrequencyUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentFrequencyUnit_WEEK", VALUEFUNC(_wrap_PaymentStreamPaymentFrequencyUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentFrequencyUnit_MONTH", VALUEFUNC(_wrap_PaymentStreamPaymentFrequencyUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentFrequencyUnit_YEAR", VALUEFUNC(_wrap_PaymentStreamPaymentFrequencyUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentFrequencyUnit_TERM", VALUEFUNC(_wrap_PaymentStreamPaymentFrequencyUnit_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetUnit_DAY", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetUnit_WEEK", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetUnit_MONTH", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetUnit_YEAR", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_MONDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_MONDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_TUESDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_TUESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_WEDNESDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_WEDNESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_THURSDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_THURSDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_FRIDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_FRIDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_SATURDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_SATURDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamResetWeeklyRollConvention_SUNDAY", VALUEFUNC(_wrap_PaymentStreamResetWeeklyRollConvention_SUNDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexSource_BLOOMBERG", VALUEFUNC(_wrap_PaymentStreamRateIndexSource_BLOOMBERG_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexSource_REUTERS", VALUEFUNC(_wrap_PaymentStreamRateIndexSource_REUTERS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexSource_TELERATE", VALUEFUNC(_wrap_PaymentStreamRateIndexSource_TELERATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexSource_OTHER", VALUEFUNC(_wrap_PaymentStreamRateIndexSource_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexCurveUnit_DAY", VALUEFUNC(_wrap_PaymentStreamRateIndexCurveUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexCurveUnit_WEEK", VALUEFUNC(_wrap_PaymentStreamRateIndexCurveUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexCurveUnit_MONTH", VALUEFUNC(_wrap_PaymentStreamRateIndexCurveUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateIndexCurveUnit_YEAR", VALUEFUNC(_wrap_PaymentStreamRateIndexCurveUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateSpreadPositionType_SHORT", VALUEFUNC(_wrap_PaymentStreamRateSpreadPositionType_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateSpreadPositionType_LONG", VALUEFUNC(_wrap_PaymentStreamRateSpreadPositionType_LONG_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateTreatment_BOND_EQUIVALENT_YIELD", VALUEFUNC(_wrap_PaymentStreamRateTreatment_BOND_EQUIVALENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateTreatment_MONEY_MARKET_YIELD", VALUEFUNC(_wrap_PaymentStreamRateTreatment_MONEY_MARKET_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCapRateBuySide_BUYER", VALUEFUNC(_wrap_PaymentStreamCapRateBuySide_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamCapRateBuySide_SELLER", VALUEFUNC(_wrap_PaymentStreamCapRateBuySide_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamFloorRateBuySide_BUYER", VALUEFUNC(_wrap_PaymentStreamFloorRateBuySide_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamFloorRateBuySide_SELLER", VALUEFUNC(_wrap_PaymentStreamFloorRateBuySide_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamAveragingMethod_UNWEIGHTED", VALUEFUNC(_wrap_PaymentStreamAveragingMethod_UNWEIGHTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamAveragingMethod_WEIGHTED", VALUEFUNC(_wrap_PaymentStreamAveragingMethod_WEIGHTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamNegativeRateTreatment_ZERO_INTEREST_RATE_METHOD", VALUEFUNC(_wrap_PaymentStreamNegativeRateTreatment_ZERO_INTEREST_RATE_METHOD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamNegativeRateTreatment_NEGATIVE_INTEREST_RATE_METHOD", VALUEFUNC(_wrap_PaymentStreamNegativeRateTreatment_NEGATIVE_INTEREST_RATE_METHOD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagUnit_DAY", VALUEFUNC(_wrap_PaymentStreamInflationLagUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagUnit_WEEK", VALUEFUNC(_wrap_PaymentStreamInflationLagUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagUnit_MONTH", VALUEFUNC(_wrap_PaymentStreamInflationLagUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagUnit_YEAR", VALUEFUNC(_wrap_PaymentStreamInflationLagUnit_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_BUSINESS", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_CALENDAR", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_COMMODITY_BUSINESS", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_COMMODITY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_CURRENCY_BUSINESS", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_CURRENCY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_EXCHANGE_BUSINESS", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_EXCHANGE_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationLagDayType_SCHEDULED_TRADING_DAY", VALUEFUNC(_wrap_PaymentStreamInflationLagDayType_SCHEDULED_TRADING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationInterpolationMethod_NONE", VALUEFUNC(_wrap_PaymentStreamInflationInterpolationMethod_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInflationInterpolationMethod_LINEAR_ZERO_YIELD", VALUEFUNC(_wrap_PaymentStreamInflationInterpolationMethod_LINEAR_ZERO_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamFRADiscounting_NONE", VALUEFUNC(_wrap_PaymentStreamFRADiscounting_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamFRADiscounting_ISDA", VALUEFUNC(_wrap_PaymentStreamFRADiscounting_ISDA_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamFRADiscounting_AFMA", VALUEFUNC(_wrap_PaymentStreamFRADiscounting_AFMA_get), 0);
  rb_define_singleton_method(mQuickfix, "NonDeliverableFixingDateType_UNADJUSTED", VALUEFUNC(_wrap_NonDeliverableFixingDateType_UNADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "NonDeliverableFixingDateType_ADJUSTED", VALUEFUNC(_wrap_NonDeliverableFixingDateType_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_NOTIONAL", VALUEFUNC(_wrap_PaymentScheduleType_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_CASH_FLOW", VALUEFUNC(_wrap_PaymentScheduleType_CASH_FLOW_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_FX_LINKED_NOTIONAL", VALUEFUNC(_wrap_PaymentScheduleType_FX_LINKED_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_FIXED_RATE", VALUEFUNC(_wrap_PaymentScheduleType_FIXED_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_FUTURE_VALUE_NOTIONAL", VALUEFUNC(_wrap_PaymentScheduleType_FUTURE_VALUE_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_KNOWN_AMOUNT", VALUEFUNC(_wrap_PaymentScheduleType_KNOWN_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_FLOATING_RATE_MULTIPLIER", VALUEFUNC(_wrap_PaymentScheduleType_FLOATING_RATE_MULTIPLIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_SPREAD", VALUEFUNC(_wrap_PaymentScheduleType_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_CAP_RATE", VALUEFUNC(_wrap_PaymentScheduleType_CAP_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_FLOOR_RATE", VALUEFUNC(_wrap_PaymentScheduleType_FLOOR_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_NON_DELIVERABLE_SETTL_PAYMENT_DATES", VALUEFUNC(_wrap_PaymentScheduleType_NON_DELIVERABLE_SETTL_PAYMENT_DATES_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_NON_DELIVERABLE_SETTL_CALCULATION_DATES", VALUEFUNC(_wrap_PaymentScheduleType_NON_DELIVERABLE_SETTL_CALCULATION_DATES_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_NON_DELIVERABLE_FX_FIXING_DATES", VALUEFUNC(_wrap_PaymentScheduleType_NON_DELIVERABLE_FX_FIXING_DATES_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_SETTL_PERIOD_NOTNL", VALUEFUNC(_wrap_PaymentScheduleType_SETTL_PERIOD_NOTNL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_SETTL_PERIOD_PX", VALUEFUNC(_wrap_PaymentScheduleType_SETTL_PERIOD_PX_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_CALC_PERIOD", VALUEFUNC(_wrap_PaymentScheduleType_CALC_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_MULTIPLIER", VALUEFUNC(_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_MULTIPLIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_SPREAD", VALUEFUNC(_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_RATE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_DIVIDEND_ACCRUAL_CAP_RATE", VALUEFUNC(_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_CAP_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_DIVIDEND_ACCRUAL_FLOOR_RATE", VALUEFUNC(_wrap_PaymentScheduleType_DIVIDEND_ACCRUAL_FLOOR_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_COMPOUNDING_RATE_MULTIPLIER", VALUEFUNC(_wrap_PaymentScheduleType_COMPOUNDING_RATE_MULTIPLIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_COMPOUNDING_RATE_SPREAD", VALUEFUNC(_wrap_PaymentScheduleType_COMPOUNDING_RATE_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_COMPOUNDING_CAP_RATE", VALUEFUNC(_wrap_PaymentScheduleType_COMPOUNDING_CAP_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleType_COMPOUNDING_FLOOR_RATE", VALUEFUNC(_wrap_PaymentScheduleType_COMPOUNDING_FLOOR_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleStepRelativeTo_INITIAL", VALUEFUNC(_wrap_PaymentScheduleStepRelativeTo_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentScheduleStepRelativeTo_PREVIOUS", VALUEFUNC(_wrap_PaymentScheduleStepRelativeTo_PREVIOUS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubType_INITIAL", VALUEFUNC(_wrap_PaymentStubType_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubType_FINAL", VALUEFUNC(_wrap_PaymentStubType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubType_COMPOUNDING_INITIAL", VALUEFUNC(_wrap_PaymentStubType_COMPOUNDING_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubType_COMPOUNDING_FINAL", VALUEFUNC(_wrap_PaymentStubType_COMPOUNDING_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubLength_SHORT", VALUEFUNC(_wrap_PaymentStubLength_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStubLength_LONG", VALUEFUNC(_wrap_PaymentStubLength_LONG_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_BUSINESS", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_CALENDAR", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_COMMODITY_BUSINESS", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_COMMODITY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_CURRENCY_BUSINESS", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_CURRENCY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_EXCHANGE_BUSINESS", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_EXCHANGE_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPaymentDateOffsetDayType_SCHEDULED_TRADING_DAY", VALUEFUNC(_wrap_PaymentStreamPaymentDateOffsetDayType_SCHEDULED_TRADING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_NOT_APPLICABLE", VALUEFUNC(_wrap_BusinessDayConvention_NOT_APPLICABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_NONE", VALUEFUNC(_wrap_BusinessDayConvention_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_FOLLOWING_DAY", VALUEFUNC(_wrap_BusinessDayConvention_FOLLOWING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_FLOATING_RATE_NOTE", VALUEFUNC(_wrap_BusinessDayConvention_FLOATING_RATE_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_MODIFIED_FOLLOWING_DAY", VALUEFUNC(_wrap_BusinessDayConvention_MODIFIED_FOLLOWING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_PRECEDING_DAY", VALUEFUNC(_wrap_BusinessDayConvention_PRECEDING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_MODIFIED_PRECEDING_DAY", VALUEFUNC(_wrap_BusinessDayConvention_MODIFIED_PRECEDING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessDayConvention_NEAREST_DAY", VALUEFUNC(_wrap_BusinessDayConvention_NEAREST_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FIRST_DAY", VALUEFUNC(_wrap_DateRollConvention_FIRST_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SECOND_DAY", VALUEFUNC(_wrap_DateRollConvention_SECOND_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_THIRD_DAY", VALUEFUNC(_wrap_DateRollConvention_THIRD_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FOURTH_DAY", VALUEFUNC(_wrap_DateRollConvention_FOURTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FIFTH_DAY", VALUEFUNC(_wrap_DateRollConvention_FIFTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SIXTH_DAY", VALUEFUNC(_wrap_DateRollConvention_SIXTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SEVENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_SEVENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_EIGHTH_DAY", VALUEFUNC(_wrap_DateRollConvention_EIGHTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_NINTH_DAY", VALUEFUNC(_wrap_DateRollConvention_NINTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_ELEVENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_ELEVENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWELVTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWELVTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_THIRTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_THIRTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FORTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_FORTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FIFTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_FIFTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SIXTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_SIXTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SEVENTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_SEVENTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_EIGHTEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_EIGHTEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_NINETEENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_NINETEENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTIETH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTIETH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_FIRST_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_FIRST_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_SECOND_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_SECOND_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_THIRD_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_THIRD_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_FOURTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_FOURTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_FIFTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_FIFTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_SIXTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_SIXTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_SEVENTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_SEVENTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_EIGTH_DA28Y", VALUEFUNC(_wrap_DateRollConvention_TWENTY_EIGTH_DA28Y_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TWENTY_NINTH_DAY", VALUEFUNC(_wrap_DateRollConvention_TWENTY_NINTH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_THIRTIETH_DAY", VALUEFUNC(_wrap_DateRollConvention_THIRTIETH_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_EOM", VALUEFUNC(_wrap_DateRollConvention_EOM_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FRN", VALUEFUNC(_wrap_DateRollConvention_FRN_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_IMM", VALUEFUNC(_wrap_DateRollConvention_IMM_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_IMMCAD", VALUEFUNC(_wrap_DateRollConvention_IMMCAD_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_IMMAUD", VALUEFUNC(_wrap_DateRollConvention_IMMAUD_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_IMMNZD", VALUEFUNC(_wrap_DateRollConvention_IMMNZD_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SFE", VALUEFUNC(_wrap_DateRollConvention_SFE_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_NONE", VALUEFUNC(_wrap_DateRollConvention_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TBILL", VALUEFUNC(_wrap_DateRollConvention_TBILL_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_MON", VALUEFUNC(_wrap_DateRollConvention_MON_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_TUE", VALUEFUNC(_wrap_DateRollConvention_TUE_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_WED", VALUEFUNC(_wrap_DateRollConvention_WED_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_THU", VALUEFUNC(_wrap_DateRollConvention_THU_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_FRI", VALUEFUNC(_wrap_DateRollConvention_FRI_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SAT", VALUEFUNC(_wrap_DateRollConvention_SAT_get), 0);
  rb_define_singleton_method(mQuickfix, "DateRollConvention_SUN", VALUEFUNC(_wrap_DateRollConvention_SUN_get), 0);
  rb_define_singleton_method(mQuickfix, "AttachmentEncodingType_BASE64", VALUEFUNC(_wrap_AttachmentEncodingType_BASE64_get), 0);
  rb_define_singleton_method(mQuickfix, "AttachmentEncodingType_RAW_BINARY", VALUEFUNC(_wrap_AttachmentEncodingType_RAW_BINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "NegotiationMethod_AUTO_SPOT", VALUEFUNC(_wrap_NegotiationMethod_AUTO_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "NegotiationMethod_NEGOTIATED_SPOT", VALUEFUNC(_wrap_NegotiationMethod_NEGOTIATED_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "NegotiationMethod_PHONE_SPOT", VALUEFUNC(_wrap_NegotiationMethod_PHONE_SPOT_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_ASIAN_OUT", VALUEFUNC(_wrap_ComplexEventPeriodType_ASIAN_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_ASIAN_IN", VALUEFUNC(_wrap_ComplexEventPeriodType_ASIAN_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_BARRIER_CAP", VALUEFUNC(_wrap_ComplexEventPeriodType_BARRIER_CAP_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_BARRIER_FLOOR", VALUEFUNC(_wrap_ComplexEventPeriodType_BARRIER_FLOOR_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_KNOCK_OUT", VALUEFUNC(_wrap_ComplexEventPeriodType_KNOCK_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPeriodType_KNOCK_IN", VALUEFUNC(_wrap_ComplexEventPeriodType_KNOCK_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_BUSINESS", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_CALENDAR", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_COMMODITY_BUSINESS", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_COMMODITY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_CURRENCY_BUSINESS", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_CURRENCY_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_EXCHANGE_BUSINESS", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_EXCHANGE_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventDateOffsetDayType_SCHEDULED_TRADING_DAY", VALUEFUNC(_wrap_ComplexEventDateOffsetDayType_SCHEDULED_TRADING_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_CLOSE", VALUEFUNC(_wrap_ComplexOptPayoutTime_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_OPEN", VALUEFUNC(_wrap_ComplexOptPayoutTime_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_OFFICIAL_SETTL", VALUEFUNC(_wrap_ComplexOptPayoutTime_OFFICIAL_SETTL_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_VALUATION_TIME", VALUEFUNC(_wrap_ComplexOptPayoutTime_VALUATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_EXCAHGNE_SETTL_TIME", VALUEFUNC(_wrap_ComplexOptPayoutTime_EXCAHGNE_SETTL_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_DERIVATIVES_CLOSE", VALUEFUNC(_wrap_ComplexOptPayoutTime_DERIVATIVES_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexOptPayoutTime_AS_SPECIFIED", VALUEFUNC(_wrap_ComplexOptPayoutTime_AS_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventQuoteBasis_CURRENCY1_PER_CURRENCY2", VALUEFUNC(_wrap_ComplexEventQuoteBasis_CURRENCY1_PER_CURRENCY2_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventQuoteBasis_CURRENCY2_PER_CURRENCY1", VALUEFUNC(_wrap_ComplexEventQuoteBasis_CURRENCY2_PER_CURRENCY1_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventCreditEventNotifyingParty_SELLER_NOTIFIES", VALUEFUNC(_wrap_ComplexEventCreditEventNotifyingParty_SELLER_NOTIFIES_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventCreditEventNotifyingParty_BUYER_NOTIFIES", VALUEFUNC(_wrap_ComplexEventCreditEventNotifyingParty_BUYER_NOTIFIES_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventCreditEventNotifyingParty_SELLER_OR_BUYER_NOTIFIES", VALUEFUNC(_wrap_ComplexEventCreditEventNotifyingParty_SELLER_OR_BUYER_NOTIFIES_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleType_NOTIONAL", VALUEFUNC(_wrap_DeliveryScheduleType_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleType_DELIVERY", VALUEFUNC(_wrap_DeliveryScheduleType_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleType_PHYSICAL_SETTL_PERIODS", VALUEFUNC(_wrap_DeliveryScheduleType_PHYSICAL_SETTL_PERIODS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleToleranceType_ABSOLUTE", VALUEFUNC(_wrap_DeliveryScheduleToleranceType_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleToleranceType_PERCENTAGE", VALUEFUNC(_wrap_DeliveryScheduleToleranceType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_ALL_TIMES", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_ALL_TIMES_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_ON_PEAK", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_ON_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_OFF_PEAK", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_OFF_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_BASE", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_BASE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_BLOCK_HOURS", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_BLOCK_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlFlowType_OTHER", VALUEFUNC(_wrap_DeliveryScheduleSettlFlowType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlHolidaysProcessingInstruction_DO_NOT_INCLUDE_HOLIDAYS", VALUEFUNC(_wrap_DeliveryScheduleSettlHolidaysProcessingInstruction_DO_NOT_INCLUDE_HOLIDAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlHolidaysProcessingInstruction_INCLUDE_HOLIDAYS", VALUEFUNC(_wrap_DeliveryScheduleSettlHolidaysProcessingInstruction_INCLUDE_HOLIDAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_MONDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_MONDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_TUESDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_TUESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_WEDNESDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_WEDNESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_THURSDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_THURSDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_FRIDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_FRIDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_SATURDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_SATURDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_SUNDAY", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_SUNDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_ALL_WEEKDAYS", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_ALL_WEEKDAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_ALL_DAYS", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_ALL_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlDay_ALL_WEEKENDS", VALUEFUNC(_wrap_DeliveryScheduleSettlDay_ALL_WEEKENDS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlTimeType_HOUR", VALUEFUNC(_wrap_DeliveryScheduleSettlTimeType_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryScheduleSettlTimeType_TIMESTAMP", VALUEFUNC(_wrap_DeliveryScheduleSettlTimeType_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamType_PERIODIC", VALUEFUNC(_wrap_DeliveryStreamType_PERIODIC_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamType_INITIAL", VALUEFUNC(_wrap_DeliveryStreamType_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamType_SINGLE", VALUEFUNC(_wrap_DeliveryStreamType_SINGLE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryRestriction_FIRM", VALUEFUNC(_wrap_DeliveryStreamDeliveryRestriction_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryRestriction_NON_FIRM", VALUEFUNC(_wrap_DeliveryStreamDeliveryRestriction_NON_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryRestriction_FORCE_MAJEURE", VALUEFUNC(_wrap_DeliveryStreamDeliveryRestriction_FORCE_MAJEURE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryRestriction_SYSTEM_FIRM", VALUEFUNC(_wrap_DeliveryStreamDeliveryRestriction_SYSTEM_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryRestriction_UNIT_FIRM", VALUEFUNC(_wrap_DeliveryStreamDeliveryRestriction_UNIT_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamTitleTransferCondition_TRANSFERS", VALUEFUNC(_wrap_DeliveryStreamTitleTransferCondition_TRANSFERS_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamTitleTransferCondition_DOES_NOT_TRANSFER", VALUEFUNC(_wrap_DeliveryStreamTitleTransferCondition_DOES_NOT_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamToleranceOptionSide_BUYER", VALUEFUNC(_wrap_DeliveryStreamToleranceOptionSide_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamToleranceOptionSide_SELLER", VALUEFUNC(_wrap_DeliveryStreamToleranceOptionSide_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamElectingPartySide_BUYER", VALUEFUNC(_wrap_DeliveryStreamElectingPartySide_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamElectingPartySide_SELLER", VALUEFUNC(_wrap_DeliveryStreamElectingPartySide_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapSubClass_AMORTIZING", VALUEFUNC(_wrap_SwapSubClass_AMORTIZING_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapSubClass_COMPOUNDING", VALUEFUNC(_wrap_SwapSubClass_COMPOUNDING_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapSubClass_CONSTANT_NOTIONAL_SCHEDULE", VALUEFUNC(_wrap_SwapSubClass_CONSTANT_NOTIONAL_SCHEDULE_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapSubClass_ACCRETING_NOTIONAL_SCHEDULE", VALUEFUNC(_wrap_SwapSubClass_ACCRETING_NOTIONAL_SCHEDULE_get), 0);
  rb_define_singleton_method(mQuickfix, "SwapSubClass_CUSTOM_NOTIONAL_SCHEDULE", VALUEFUNC(_wrap_SwapSubClass_CUSTOM_NOTIONAL_SCHEDULE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_STRADDLE", VALUEFUNC(_wrap_StrategyType_STRADDLE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_STRANGLE", VALUEFUNC(_wrap_StrategyType_STRANGLE_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_BUTTERFLY", VALUEFUNC(_wrap_StrategyType_BUTTERFLY_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_CONDOR", VALUEFUNC(_wrap_StrategyType_CONDOR_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_CALLABLE_INVERSIBLE_SNOWBALL", VALUEFUNC(_wrap_StrategyType_CALLABLE_INVERSIBLE_SNOWBALL_get), 0);
  rb_define_singleton_method(mQuickfix, "StrategyType_OTHER", VALUEFUNC(_wrap_StrategyType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDisruptionProvision_NEGOTIATION", VALUEFUNC(_wrap_SettlDisruptionProvision_NEGOTIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDisruptionProvision_CANCELLATION", VALUEFUNC(_wrap_SettlDisruptionProvision_CANCELLATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionProvision_NOT_APPLICABLE", VALUEFUNC(_wrap_MarketDisruptionProvision_NOT_APPLICABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionProvision_APPLICABLE", VALUEFUNC(_wrap_MarketDisruptionProvision_APPLICABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionProvision_AS_IN_MASTER_AGREEMENT", VALUEFUNC(_wrap_MarketDisruptionProvision_AS_IN_MASTER_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionProvision_AS_IN_CONFIRMATION", VALUEFUNC(_wrap_MarketDisruptionProvision_AS_IN_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackProvision_MASTER_AGREEMENT", VALUEFUNC(_wrap_MarketDisruptionFallbackProvision_MASTER_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackProvision_CONFIRMATION", VALUEFUNC(_wrap_MarketDisruptionFallbackProvision_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_BASKET", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_BASKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_BOND", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_CASH", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_COMMODITY", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_CONVERTIBLE_BOND", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_CONVERTIBLE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_EQUITY", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_EQUITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_EXCHANGE_TRADED_FUND", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_EXCHANGE_TRADED_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_FUTURE", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_INDEX", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_LOAN", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_MORTGAGE", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketDisruptionFallbackUnderlierType_MUTUAL_FUND", VALUEFUNC(_wrap_MarketDisruptionFallbackUnderlierType_MUTUAL_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseConfirmationMethod_NOT_REQUIRED", VALUEFUNC(_wrap_ExerciseConfirmationMethod_NOT_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseConfirmationMethod_NON_ELECTRONIC", VALUEFUNC(_wrap_ExerciseConfirmationMethod_NON_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseConfirmationMethod_ELECTRONIC", VALUEFUNC(_wrap_ExerciseConfirmationMethod_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseConfirmationMethod_UNKNOWN", VALUEFUNC(_wrap_ExerciseConfirmationMethod_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "OptionExerciseDateType_UNADJUSTED", VALUEFUNC(_wrap_OptionExerciseDateType_UNADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OptionExerciseDateType_ADJUSTED", VALUEFUNC(_wrap_OptionExerciseDateType_ADJUSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_BUSINESS", VALUEFUNC(_wrap_PaymentDateOffsetDayType_BUSINESS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_CALENDAR", VALUEFUNC(_wrap_PaymentDateOffsetDayType_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_COMMODITY", VALUEFUNC(_wrap_PaymentDateOffsetDayType_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_CURRENCY", VALUEFUNC(_wrap_PaymentDateOffsetDayType_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_EXCHANGE", VALUEFUNC(_wrap_PaymentDateOffsetDayType_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentDateOffsetDayType_SCHEDULED", VALUEFUNC(_wrap_PaymentDateOffsetDayType_SCHEDULED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentForwardStartType_PREPAID", VALUEFUNC(_wrap_PaymentForwardStartType_PREPAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentForwardStartType_POSTPAID", VALUEFUNC(_wrap_PaymentForwardStartType_POSTPAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentForwardStartType_VARIABLE", VALUEFUNC(_wrap_PaymentForwardStartType_VARIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentForwardStartType_FIXED", VALUEFUNC(_wrap_PaymentForwardStartType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamSettlLevel_AVERAGE", VALUEFUNC(_wrap_PaymentStreamSettlLevel_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamSettlLevel_MAXIMUM", VALUEFUNC(_wrap_PaymentStreamSettlLevel_MAXIMUM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamSettlLevel_MINIMUM", VALUEFUNC(_wrap_PaymentStreamSettlLevel_MINIMUM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamSettlLevel_CUMULATIVE", VALUEFUNC(_wrap_PaymentStreamSettlLevel_CUMULATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateSpreadType_ABSOLUTE", VALUEFUNC(_wrap_PaymentStreamRateSpreadType_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRateSpreadType_PERCENTAGE", VALUEFUNC(_wrap_PaymentStreamRateSpreadType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayDistribution_ALL", VALUEFUNC(_wrap_PaymentStreamPricingDayDistribution_ALL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayDistribution_FIRST", VALUEFUNC(_wrap_PaymentStreamPricingDayDistribution_FIRST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayDistribution_LAST", VALUEFUNC(_wrap_PaymentStreamPricingDayDistribution_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayDistribution_PENULTIMATE", VALUEFUNC(_wrap_PaymentStreamPricingDayDistribution_PENULTIMATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_EVERY_DAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_EVERY_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_MONDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_MONDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_TUESDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_TUESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_WEDNESDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_WEDNESDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_THURSDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_THURSDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_FRIDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_FRIDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_SATURDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_SATURDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamPricingDayOfWeek_SUNDAY", VALUEFUNC(_wrap_PaymentStreamPricingDayOfWeek_SUNDAY_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityNearbySettlDayUnit_WEEK", VALUEFUNC(_wrap_StreamCommodityNearbySettlDayUnit_WEEK_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityNearbySettlDayUnit_MONTH", VALUEFUNC(_wrap_StreamCommodityNearbySettlDayUnit_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommoditySettlDateRollUnit_DAY", VALUEFUNC(_wrap_StreamCommoditySettlDateRollUnit_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityDataSourceIDType_CITY", VALUEFUNC(_wrap_StreamCommodityDataSourceIDType_CITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityDataSourceIDType_AIRPORT", VALUEFUNC(_wrap_StreamCommodityDataSourceIDType_AIRPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityDataSourceIDType_WEATHER_STATION", VALUEFUNC(_wrap_StreamCommodityDataSourceIDType_WEATHER_STATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamCommodityDataSourceIDType_WEATHER_INDEX", VALUEFUNC(_wrap_StreamCommodityDataSourceIDType_WEATHER_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_TERM", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_BUSINESS_DAY", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_BUSINESS_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_CALCULATION_PERIOD", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_CALCULATION_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_SETTL_PERIOD", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_SETTL_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_CALENDAR_DAY", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_CALENDAR_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_HOUR", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_HOUR_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalCommodityFrequency_PER_MONTH", VALUEFUNC(_wrap_StreamNotionalCommodityFrequency_PER_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitReportStatus_ACCEPTED", VALUEFUNC(_wrap_RiskLimitReportStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitReportStatus_REJECTED", VALUEFUNC(_wrap_RiskLimitReportStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitReportRejectReason_UNK_RISK_LMT_RPRT_ID", VALUEFUNC(_wrap_RiskLimitReportRejectReason_UNK_RISK_LMT_RPRT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitReportRejectReason_UNK_PTY", VALUEFUNC(_wrap_RiskLimitReportRejectReason_UNK_PTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitReportRejectReason_OTHER", VALUEFUNC(_wrap_RiskLimitReportRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckTransType_NEW", VALUEFUNC(_wrap_RiskLimitCheckTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckTransType_CANCEL", VALUEFUNC(_wrap_RiskLimitCheckTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckTransType_REPLACE", VALUEFUNC(_wrap_RiskLimitCheckTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckType_SUBMIT", VALUEFUNC(_wrap_RiskLimitCheckType_SUBMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckType_LIMIT_CONSUMED", VALUEFUNC(_wrap_RiskLimitCheckType_LIMIT_CONSUMED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestType_ALL_OR_NONE", VALUEFUNC(_wrap_RiskLimitCheckRequestType_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestType_PARTIAL", VALUEFUNC(_wrap_RiskLimitCheckRequestType_PARTIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestStatus_APPROVED", VALUEFUNC(_wrap_RiskLimitCheckRequestStatus_APPROVED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestStatus_PARTIALLY_APPROVED", VALUEFUNC(_wrap_RiskLimitCheckRequestStatus_PARTIALLY_APPROVED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestStatus_REJECTED", VALUEFUNC(_wrap_RiskLimitCheckRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestStatus_APPROVAL_PENDING", VALUEFUNC(_wrap_RiskLimitCheckRequestStatus_APPROVAL_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestStatus_CANCELLED", VALUEFUNC(_wrap_RiskLimitCheckRequestStatus_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_INVALID_PARTY", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_REQ_EXCEEDS_CREDIT_LIMIT", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_CREDIT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_REQ_EXCEEDS_CLIP_SIZE_LIMIT", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_CLIP_SIZE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_REQ_EXCEEDS_MAX_NOTIONAL", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_REQ_EXCEEDS_MAX_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckRequestResult_OTHER", VALUEFUNC(_wrap_RiskLimitCheckRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionType_SUSPEND", VALUEFUNC(_wrap_PartyActionType_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionType_HALT_TRADING", VALUEFUNC(_wrap_PartyActionType_HALT_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionType_REINSTATE", VALUEFUNC(_wrap_PartyActionType_REINSTATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionResponse_ACCEPTED", VALUEFUNC(_wrap_PartyActionResponse_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionResponse_COMPLETED", VALUEFUNC(_wrap_PartyActionResponse_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionResponse_REJECTED", VALUEFUNC(_wrap_PartyActionResponse_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionRejectReason_INVALID_PARTY", VALUEFUNC(_wrap_PartyActionRejectReason_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionRejectReason_UNK_REQ_PARTY", VALUEFUNC(_wrap_PartyActionRejectReason_UNK_REQ_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionRejectReason_NOT_AUTHORIZED", VALUEFUNC(_wrap_PartyActionRejectReason_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyActionRejectReason_OTHER", VALUEFUNC(_wrap_PartyActionRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RefRiskLimitCheckIDType_RISK_LIMIT_REQUEST_ID", VALUEFUNC(_wrap_RefRiskLimitCheckIDType_RISK_LIMIT_REQUEST_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefRiskLimitCheckIDType_RISK_LIMIT_CHECK_ID", VALUEFUNC(_wrap_RefRiskLimitCheckIDType_RISK_LIMIT_CHECK_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RefRiskLimitCheckIDType_OUT_OF_BAND_ID", VALUEFUNC(_wrap_RefRiskLimitCheckIDType_OUT_OF_BAND_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckModelType_NONE", VALUEFUNC(_wrap_RiskLimitCheckModelType_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckModelType_PLUS_ONE_MODEL", VALUEFUNC(_wrap_RiskLimitCheckModelType_PLUS_ONE_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckModelType_PING_MODEL", VALUEFUNC(_wrap_RiskLimitCheckModelType_PING_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckModelType_PUSH_MODEL", VALUEFUNC(_wrap_RiskLimitCheckModelType_PUSH_MODEL_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_ACCEPTED", VALUEFUNC(_wrap_RiskLimitCheckStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_REJECTED", VALUEFUNC(_wrap_RiskLimitCheckStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_CLAIM_REQUIRED", VALUEFUNC(_wrap_RiskLimitCheckStatus_CLAIM_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_SUCCEEDED", VALUEFUNC(_wrap_RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_SUCCEEDED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_FAILED", VALUEFUNC(_wrap_RiskLimitCheckStatus_PRE_DEFINED_LIMIT_CHECK_FAILED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PRE_DEFINED_AUTO_ACCEPT_RULE_INVOKED", VALUEFUNC(_wrap_RiskLimitCheckStatus_PRE_DEFINED_AUTO_ACCEPT_RULE_INVOKED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PRE_DEFINED_AUTO_REJECT_RULE_INVOKED", VALUEFUNC(_wrap_RiskLimitCheckStatus_PRE_DEFINED_AUTO_REJECT_RULE_INVOKED_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_ACCEPTED_BY_CLEARING_FIRM", VALUEFUNC(_wrap_RiskLimitCheckStatus_ACCEPTED_BY_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_REJECTED_BY_CLEARING_FIRM", VALUEFUNC(_wrap_RiskLimitCheckStatus_REJECTED_BY_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PENDING", VALUEFUNC(_wrap_RiskLimitCheckStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_ACCEPTED_BY_CREDIT_HUB", VALUEFUNC(_wrap_RiskLimitCheckStatus_ACCEPTED_BY_CREDIT_HUB_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_REJECTED_BY_CREDIT_HUB", VALUEFUNC(_wrap_RiskLimitCheckStatus_REJECTED_BY_CREDIT_HUB_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_PENDING_CREDIT_HUB_CHECK", VALUEFUNC(_wrap_RiskLimitCheckStatus_PENDING_CREDIT_HUB_CHECK_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_ACCEPTED_BY_EXEC_VENUE", VALUEFUNC(_wrap_RiskLimitCheckStatus_ACCEPTED_BY_EXEC_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "RiskLimitCheckStatus_REJECTED_BY_EXEC_VENUE", VALUEFUNC(_wrap_RiskLimitCheckStatus_REJECTED_BY_EXEC_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTransactionType_NONE", VALUEFUNC(_wrap_RegulatoryTransactionType_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTransactionType_SEF_REQUIRED_TRANSACTION", VALUEFUNC(_wrap_RegulatoryTransactionType_SEF_REQUIRED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTransactionType_SEF_PERMITTED_TRANSACTION", VALUEFUNC(_wrap_RegulatoryTransactionType_SEF_PERMITTED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "BatchProcessMode_UPDATE", VALUEFUNC(_wrap_BatchProcessMode_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "BatchProcessMode_SNAPSHOT", VALUEFUNC(_wrap_BatchProcessMode_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryPointSource_PROPRIETARY", VALUEFUNC(_wrap_DeliveryStreamDeliveryPointSource_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryStreamDeliveryPointSource_EIC", VALUEFUNC(_wrap_DeliveryStreamDeliveryPointSource_EIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxonomyType_ISIN_OR_ALT_INSTRMT_ID", VALUEFUNC(_wrap_TaxonomyType_ISIN_OR_ALT_INSTRMT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxonomyType_INTERIM_TAXONOMY", VALUEFUNC(_wrap_TaxonomyType_INTERIM_TAXONOMY_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDScope_CLEARING_MEMBER", VALUEFUNC(_wrap_RegulatoryTradeIDScope_CLEARING_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegulatoryTradeIDScope_CLIENT", VALUEFUNC(_wrap_RegulatoryTradeIDScope_CLIENT_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_ORDER_ENTRY", VALUEFUNC(_wrap_EntitlementSubType_ORDER_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_H_IT_LIFT", VALUEFUNC(_wrap_EntitlementSubType_H_IT_LIFT_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_VIEW_INDICATIVE_PX", VALUEFUNC(_wrap_EntitlementSubType_VIEW_INDICATIVE_PX_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_VIEW_EXECUTABLE_PX", VALUEFUNC(_wrap_EntitlementSubType_VIEW_EXECUTABLE_PX_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_SINGLE_QUOTE", VALUEFUNC(_wrap_EntitlementSubType_SINGLE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_STREAMING_QUOTES", VALUEFUNC(_wrap_EntitlementSubType_STREAMING_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_SINGLE_BROKER", VALUEFUNC(_wrap_EntitlementSubType_SINGLE_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "EntitlementSubType_MULTI_BROKERS", VALUEFUNC(_wrap_EntitlementSubType_MULTI_BROKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteModelType_QUOTE_ENTRY", VALUEFUNC(_wrap_QuoteModelType_QUOTE_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteModelType_QUOTE_MODIFICATION", VALUEFUNC(_wrap_QuoteModelType_QUOTE_MODIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecMethod_UNSPECIFIED", VALUEFUNC(_wrap_ExecMethod_UNSPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecMethod_MANUAL", VALUEFUNC(_wrap_ExecMethod_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecMethod_AUTOMATED", VALUEFUNC(_wrap_ExecMethod_AUTOMATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecMethod_VOICE_BROKERED", VALUEFUNC(_wrap_ExecMethod_VOICE_BROKERED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContingency_DOES_NOT_APPLY", VALUEFUNC(_wrap_TradeContingency_DOES_NOT_APPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContingency_CONTINGENT_TRADE", VALUEFUNC(_wrap_TradeContingency_CONTINGENT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeContingency_NON_CONTINGENT_TRADE", VALUEFUNC(_wrap_TradeContingency_NON_CONTINGENT_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_INITIAL", VALUEFUNC(_wrap_PaymentSubType_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_INTERMEDIATE", VALUEFUNC(_wrap_PaymentSubType_INTERMEDIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_FINAL", VALUEFUNC(_wrap_PaymentSubType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_PREPAID", VALUEFUNC(_wrap_PaymentSubType_PREPAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_POSTPAID", VALUEFUNC(_wrap_PaymentSubType_POSTPAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_VARIABLE", VALUEFUNC(_wrap_PaymentSubType_VARIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_FIXED", VALUEFUNC(_wrap_PaymentSubType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_SWAP", VALUEFUNC(_wrap_PaymentSubType_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_CONDITIONAL", VALUEFUNC(_wrap_PaymentSubType_CONDITIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_FIXED_RATE", VALUEFUNC(_wrap_PaymentSubType_FIXED_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentSubType_FLOATING_RATE", VALUEFUNC(_wrap_PaymentSubType_FLOATING_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestStatus_ACCEPTED", VALUEFUNC(_wrap_MassOrderRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestStatus_ACCEPTED_WITH_ADDITIONAL_EVENTS", VALUEFUNC(_wrap_MassOrderRequestStatus_ACCEPTED_WITH_ADDITIONAL_EVENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestStatus_REJECTED", VALUEFUNC(_wrap_MassOrderRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_MassOrderRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestResult_RESPONSE_LEVEL_NOT_SUPPORTED", VALUEFUNC(_wrap_MassOrderRequestResult_RESPONSE_LEVEL_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestResult_INVALID_MARKET", VALUEFUNC(_wrap_MassOrderRequestResult_INVALID_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestResult_INVALID_MARKET_SEGMENT", VALUEFUNC(_wrap_MassOrderRequestResult_INVALID_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassOrderRequestResult_OTHER", VALUEFUNC(_wrap_MassOrderRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderResponseLevel_NO_ACK", VALUEFUNC(_wrap_OrderResponseLevel_NO_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderResponseLevel_MINIMUM_ACK", VALUEFUNC(_wrap_OrderResponseLevel_MINIMUM_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderResponseLevel_ACK_EACH", VALUEFUNC(_wrap_OrderResponseLevel_ACK_EACH_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderResponseLevel_SUMMARY_ACK", VALUEFUNC(_wrap_OrderResponseLevel_SUMMARY_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEntryAction_ADD", VALUEFUNC(_wrap_OrderEntryAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEntryAction_MODIFY", VALUEFUNC(_wrap_OrderEntryAction_MODIFY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEntryAction_DELETE", VALUEFUNC(_wrap_OrderEntryAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEntryAction_SUSPEND", VALUEFUNC(_wrap_OrderEntryAction_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderEntryAction_RELEASE", VALUEFUNC(_wrap_OrderEntryAction_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_ADDED_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_ORD_ADDED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_REPLACED_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_ORD_REPLACED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_CXLD_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_ORD_CXLD_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_UNSOLICITED_ORD_CXL", VALUEFUNC(_wrap_ExecTypeReason_UNSOLICITED_ORD_CXL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_NON_RESTING_ORD_ADDED_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_NON_RESTING_ORD_ADDED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_REPLACED_WITH_NON_RESTING_ORD_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_ORD_REPLACED_WITH_NON_RESTING_ORD_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_TRIGGER_ORD_REPLACED_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_TRIGGER_ORD_REPLACED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_SUSPENDED_ORD_REPLACED_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_SUSPENDED_ORD_REPLACED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_SUSPENDED_ORD_CXLD_ON_REQUEST", VALUEFUNC(_wrap_ExecTypeReason_SUSPENDED_ORD_CXLD_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_CXL_PENDING", VALUEFUNC(_wrap_ExecTypeReason_ORD_CXL_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_PENDING_CXL_EXECUTED", VALUEFUNC(_wrap_ExecTypeReason_PENDING_CXL_EXECUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_RESTING_ORD_TRIGGERED", VALUEFUNC(_wrap_ExecTypeReason_RESTING_ORD_TRIGGERED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_SUSPENDED_ORD_ACTIVATED", VALUEFUNC(_wrap_ExecTypeReason_SUSPENDED_ORD_ACTIVATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ACTIVE_ORD_SUSPENDED", VALUEFUNC(_wrap_ExecTypeReason_ACTIVE_ORD_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTypeReason_ORD_EXPIRED", VALUEFUNC(_wrap_ExecTypeReason_ORD_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferTransType_NEW", VALUEFUNC(_wrap_TransferTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferTransType_REPLACE", VALUEFUNC(_wrap_TransferTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferTransType_CANCEL", VALUEFUNC(_wrap_TransferTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferType_REQUEST_TRANSFER", VALUEFUNC(_wrap_TransferType_REQUEST_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferType_ACCEPT_TRANSFER", VALUEFUNC(_wrap_TransferType_ACCEPT_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferType_DECLINE_TRANSFER", VALUEFUNC(_wrap_TransferType_DECLINE_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferScope_INTER_FIRM_TRANSFER", VALUEFUNC(_wrap_TransferScope_INTER_FIRM_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferScope_INTRA_FIRM_TRANSFER", VALUEFUNC(_wrap_TransferScope_INTRA_FIRM_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferScope_CMTA", VALUEFUNC(_wrap_TransferScope_CMTA_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_RECEIVED", VALUEFUNC(_wrap_TransferStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_REJECTED_BY_INTERMEDIARY", VALUEFUNC(_wrap_TransferStatus_REJECTED_BY_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_ACCEPT_PENDING", VALUEFUNC(_wrap_TransferStatus_ACCEPT_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_ACCEPTED", VALUEFUNC(_wrap_TransferStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_DECLINED", VALUEFUNC(_wrap_TransferStatus_DECLINED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferStatus_CANCELLED", VALUEFUNC(_wrap_TransferStatus_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_SUCCESS", VALUEFUNC(_wrap_TransferRejectReason_SUCCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_INVALID_PARTY", VALUEFUNC(_wrap_TransferRejectReason_INVALID_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TransferRejectReason_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_UNAUTHORIZED_TO_SUBMIT_XFER", VALUEFUNC(_wrap_TransferRejectReason_UNAUTHORIZED_TO_SUBMIT_XFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_UNKNOWN_POSITION", VALUEFUNC(_wrap_TransferRejectReason_UNKNOWN_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferRejectReason_OTHER", VALUEFUNC(_wrap_TransferRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferReportType_SUBMIT", VALUEFUNC(_wrap_TransferReportType_SUBMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TransferReportType_ALLEGED", VALUEFUNC(_wrap_TransferReportType_ALLEGED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_COUNT", VALUEFUNC(_wrap_MDStatisticType_COUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_AVERAGE_VOLUME", VALUEFUNC(_wrap_MDStatisticType_AVERAGE_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TOTAL_VOLUME", VALUEFUNC(_wrap_MDStatisticType_TOTAL_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_DISTRIBUTION", VALUEFUNC(_wrap_MDStatisticType_DISTRIBUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_RATIO", VALUEFUNC(_wrap_MDStatisticType_RATIO_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_LIQUIDITY", VALUEFUNC(_wrap_MDStatisticType_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_VWAP", VALUEFUNC(_wrap_MDStatisticType_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_VOLATILITY", VALUEFUNC(_wrap_MDStatisticType_VOLATILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_DURATION", VALUEFUNC(_wrap_MDStatisticType_DURATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TICK", VALUEFUNC(_wrap_MDStatisticType_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_AVERAGE_VALUE", VALUEFUNC(_wrap_MDStatisticType_AVERAGE_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TOTAL_VALUE", VALUEFUNC(_wrap_MDStatisticType_TOTAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_HIGH", VALUEFUNC(_wrap_MDStatisticType_HIGH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_LOW", VALUEFUNC(_wrap_MDStatisticType_LOW_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_MIDPOINT", VALUEFUNC(_wrap_MDStatisticType_MIDPOINT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_FIRST", VALUEFUNC(_wrap_MDStatisticType_FIRST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_LAST", VALUEFUNC(_wrap_MDStatisticType_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_FINAL", VALUEFUNC(_wrap_MDStatisticType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_EXCHANGE_BEST", VALUEFUNC(_wrap_MDStatisticType_EXCHANGE_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_EXCHANGE_BEST_WITH_VOLUME", VALUEFUNC(_wrap_MDStatisticType_EXCHANGE_BEST_WITH_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_CONSOLIDATED_BEST", VALUEFUNC(_wrap_MDStatisticType_CONSOLIDATED_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_CONSOLIDATED_BEST_WITH_VOLUME", VALUEFUNC(_wrap_MDStatisticType_CONSOLIDATED_BEST_WITH_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TWAP", VALUEFUNC(_wrap_MDStatisticType_TWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_AVERAGE_DURATION", VALUEFUNC(_wrap_MDStatisticType_AVERAGE_DURATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_AVERAGE_PRICE", VALUEFUNC(_wrap_MDStatisticType_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TOTAL_FEES", VALUEFUNC(_wrap_MDStatisticType_TOTAL_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_TOTAL_BENEFITS", VALUEFUNC(_wrap_MDStatisticType_TOTAL_BENEFITS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_MEDIAN_VALUE", VALUEFUNC(_wrap_MDStatisticType_MEDIAN_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_AVERAGE_LIQUIDITY", VALUEFUNC(_wrap_MDStatisticType_AVERAGE_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticType_MEDIAN_DURATION", VALUEFUNC(_wrap_MDStatisticType_MEDIAN_DURATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_BID_PRICES", VALUEFUNC(_wrap_MDStatisticScope_BID_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_OFFER_PRICES", VALUEFUNC(_wrap_MDStatisticScope_OFFER_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_BID_DEPTH", VALUEFUNC(_wrap_MDStatisticScope_BID_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_OFFER_DEPTH", VALUEFUNC(_wrap_MDStatisticScope_OFFER_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_ORDERS", VALUEFUNC(_wrap_MDStatisticScope_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_QUOTES", VALUEFUNC(_wrap_MDStatisticScope_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_ORDERS_AND_QUOTES", VALUEFUNC(_wrap_MDStatisticScope_ORDERS_AND_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADES", VALUEFUNC(_wrap_MDStatisticScope_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADE_PRICES", VALUEFUNC(_wrap_MDStatisticScope_TRADE_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_AUCTION_PRICES", VALUEFUNC(_wrap_MDStatisticScope_AUCTION_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_OPENING_PRICES", VALUEFUNC(_wrap_MDStatisticScope_OPENING_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_CLOSING_PRICES", VALUEFUNC(_wrap_MDStatisticScope_CLOSING_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_SETTLEMENT_PRICES", VALUEFUNC(_wrap_MDStatisticScope_SETTLEMENT_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_UNDERLYING_PRICES", VALUEFUNC(_wrap_MDStatisticScope_UNDERLYING_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_OPEN_INTEREST", VALUEFUNC(_wrap_MDStatisticScope_OPEN_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_INDEX_VALUES", VALUEFUNC(_wrap_MDStatisticScope_INDEX_VALUES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_MARGIN_RATES", VALUEFUNC(_wrap_MDStatisticScope_MARGIN_RATES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_OUTAGES", VALUEFUNC(_wrap_MDStatisticScope_OUTAGES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_SCHEDULED_AUCTIONS", VALUEFUNC(_wrap_MDStatisticScope_SCHEDULED_AUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_REFERENCE_PRICES", VALUEFUNC(_wrap_MDStatisticScope_REFERENCE_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADE_VALUE", VALUEFUNC(_wrap_MDStatisticScope_TRADE_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_MARKET_DATA_FEE_ITEMS", VALUEFUNC(_wrap_MDStatisticScope_MARKET_DATA_FEE_ITEMS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_REBATES", VALUEFUNC(_wrap_MDStatisticScope_REBATES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_DISCOUNTS", VALUEFUNC(_wrap_MDStatisticScope_DISCOUNTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_PAYMENTS", VALUEFUNC(_wrap_MDStatisticScope_PAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TAXES", VALUEFUNC(_wrap_MDStatisticScope_TAXES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_LEVIES", VALUEFUNC(_wrap_MDStatisticScope_LEVIES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_BENEFITS", VALUEFUNC(_wrap_MDStatisticScope_BENEFITS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_FEES", VALUEFUNC(_wrap_MDStatisticScope_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_ORDERS_RF_QS", VALUEFUNC(_wrap_MDStatisticScope_ORDERS_RF_QS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_MARKET_MAKERS", VALUEFUNC(_wrap_MDStatisticScope_MARKET_MAKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADING_INTERRUPTIONS", VALUEFUNC(_wrap_MDStatisticScope_TRADING_INTERRUPTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADING_SUSPENSIONS", VALUEFUNC(_wrap_MDStatisticScope_TRADING_SUSPENSIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_NO_QUOTES", VALUEFUNC(_wrap_MDStatisticScope_NO_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_REQUEST_FOR_QUOTES", VALUEFUNC(_wrap_MDStatisticScope_REQUEST_FOR_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScope_TRADE_VOLUME", VALUEFUNC(_wrap_MDStatisticScope_TRADE_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_VISIBLE", VALUEFUNC(_wrap_MDStatisticSubScope_VISIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_HIDDEN", VALUEFUNC(_wrap_MDStatisticSubScope_HIDDEN_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_INDICATIVE", VALUEFUNC(_wrap_MDStatisticSubScope_INDICATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_TRADEABLE", VALUEFUNC(_wrap_MDStatisticSubScope_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_PASSIVE", VALUEFUNC(_wrap_MDStatisticSubScope_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_MARKET_CONSENSUS", VALUEFUNC(_wrap_MDStatisticSubScope_MARKET_CONSENSUS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_POWER", VALUEFUNC(_wrap_MDStatisticSubScope_POWER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_HARDWARE_ERROR", VALUEFUNC(_wrap_MDStatisticSubScope_HARDWARE_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_SOFTWARE_ERROR", VALUEFUNC(_wrap_MDStatisticSubScope_SOFTWARE_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_NETWORK_ERROR", VALUEFUNC(_wrap_MDStatisticSubScope_NETWORK_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_FAILED", VALUEFUNC(_wrap_MDStatisticSubScope_FAILED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_EXECUTED", VALUEFUNC(_wrap_MDStatisticSubScope_EXECUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_ENTERED", VALUEFUNC(_wrap_MDStatisticSubScope_ENTERED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_MODIFIED", VALUEFUNC(_wrap_MDStatisticSubScope_MODIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_CANCELLED", VALUEFUNC(_wrap_MDStatisticSubScope_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_MARKET_DATA_ACCESS", VALUEFUNC(_wrap_MDStatisticSubScope_MARKET_DATA_ACCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_TERMINAL_ACCESS", VALUEFUNC(_wrap_MDStatisticSubScope_TERMINAL_ACCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_VOLUME", VALUEFUNC(_wrap_MDStatisticSubScope_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_CLEARED", VALUEFUNC(_wrap_MDStatisticSubScope_CLEARED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_SETTLED", VALUEFUNC(_wrap_MDStatisticSubScope_SETTLED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_OTHER", VALUEFUNC(_wrap_MDStatisticSubScope_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_MONETARY", VALUEFUNC(_wrap_MDStatisticSubScope_MONETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_NON_MONETARY", VALUEFUNC(_wrap_MDStatisticSubScope_NON_MONETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_GROSS", VALUEFUNC(_wrap_MDStatisticSubScope_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_LARGE_IN_SCALE", VALUEFUNC(_wrap_MDStatisticSubScope_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_NEITHER_HIDDEN_NOR_LARGE_IN_SCALE", VALUEFUNC(_wrap_MDStatisticSubScope_NEITHER_HIDDEN_NOR_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_CORPORATE_ACTION", VALUEFUNC(_wrap_MDStatisticSubScope_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_VENUE_DECISION", VALUEFUNC(_wrap_MDStatisticSubScope_VENUE_DECISION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_MINIMUM_TIME_PERIOD", VALUEFUNC(_wrap_MDStatisticSubScope_MINIMUM_TIME_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_OPEN", VALUEFUNC(_wrap_MDStatisticSubScope_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_NOT_EXECUTED", VALUEFUNC(_wrap_MDStatisticSubScope_NOT_EXECUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_AGGRESSIVE", VALUEFUNC(_wrap_MDStatisticSubScope_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticSubScope_DIRECTED", VALUEFUNC(_wrap_MDStatisticSubScope_DIRECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScopeType_ENTRY_RATE", VALUEFUNC(_wrap_MDStatisticScopeType_ENTRY_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScopeType_MODIFICATION_RATE", VALUEFUNC(_wrap_MDStatisticScopeType_MODIFICATION_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScopeType_CANCEL_RATE", VALUEFUNC(_wrap_MDStatisticScopeType_CANCEL_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScopeType_DOWNWARD_MOVE", VALUEFUNC(_wrap_MDStatisticScopeType_DOWNWARD_MOVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticScopeType_UPWARD_MOVE", VALUEFUNC(_wrap_MDStatisticScopeType_UPWARD_MOVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_SLIDING_WINDOW", VALUEFUNC(_wrap_MDStatisticIntervalType_SLIDING_WINDOW_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_SLIDING_WINDOW_PEAK", VALUEFUNC(_wrap_MDStatisticIntervalType_SLIDING_WINDOW_PEAK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_FIXED_DATE_RANGE", VALUEFUNC(_wrap_MDStatisticIntervalType_FIXED_DATE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_FIXED_TIME_RANGE", VALUEFUNC(_wrap_MDStatisticIntervalType_FIXED_TIME_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_CURRENT_TIME_UNIT", VALUEFUNC(_wrap_MDStatisticIntervalType_CURRENT_TIME_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_PREVIOUS_TIME_UNIT", VALUEFUNC(_wrap_MDStatisticIntervalType_PREVIOUS_TIME_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_MAXIMUM_RANGE", VALUEFUNC(_wrap_MDStatisticIntervalType_MAXIMUM_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticIntervalType_MAXIMUM_RANGE_UP_TO_PREVIOUS_TIME_UNIT", VALUEFUNC(_wrap_MDStatisticIntervalType_MAXIMUM_RANGE_UP_TO_PREVIOUS_TIME_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_BUYERS_TO_SELLERS", VALUEFUNC(_wrap_MDStatisticRatioType_BUYERS_TO_SELLERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_UPTICKS_TO_DOWNTICKS", VALUEFUNC(_wrap_MDStatisticRatioType_UPTICKS_TO_DOWNTICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_MARKET_MAKER_TO_NON_MARKET_MAKER", VALUEFUNC(_wrap_MDStatisticRatioType_MARKET_MAKER_TO_NON_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_AUTOMATED_TO_NON_AUTOMATED", VALUEFUNC(_wrap_MDStatisticRatioType_AUTOMATED_TO_NON_AUTOMATED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_ORDERS_TO_TRADES", VALUEFUNC(_wrap_MDStatisticRatioType_ORDERS_TO_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_QUOTES_TO_TRADES", VALUEFUNC(_wrap_MDStatisticRatioType_QUOTES_TO_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_ORDERS_AND_QUOTES_TO_TRADES", VALUEFUNC(_wrap_MDStatisticRatioType_ORDERS_AND_QUOTES_TO_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_FAILED_TO_TOTAL_TRADED_VALUE", VALUEFUNC(_wrap_MDStatisticRatioType_FAILED_TO_TOTAL_TRADED_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_BENEFITS_TO_TOTAL_TRADED_VALUE", VALUEFUNC(_wrap_MDStatisticRatioType_BENEFITS_TO_TOTAL_TRADED_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_FEES_TO_TOTAL_TRADED_VALUE", VALUEFUNC(_wrap_MDStatisticRatioType_FEES_TO_TOTAL_TRADED_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_TRADE_VOLUME_TO_TOTAL_TRADED_VOLUME", VALUEFUNC(_wrap_MDStatisticRatioType_TRADE_VOLUME_TO_TOTAL_TRADED_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRatioType_ORDERS_TO_TOTAL_NUMBER_ORDERS", VALUEFUNC(_wrap_MDStatisticRatioType_ORDERS_TO_TOTAL_NUMBER_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_MDStatisticRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_SEGMENT", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_MARKET_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_SECURITY_LIST", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_SECURITY_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_INSTRUMENTS", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_INSTRUMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_PARTIES", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_TRADE_DATE_OUT_OF_SUPPORTED_RANGE", VALUEFUNC(_wrap_MDStatisticRequestResult_TRADE_DATE_OUT_OF_SUPPORTED_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TYPE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_SCOPE_OR_SUB_SCOPE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_SCOPE_OR_SUB_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_SCOPE_TYPE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_SCOPE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_MARKET_DEPTH_NOT_SUPPORTED", VALUEFUNC(_wrap_MDStatisticRequestResult_MARKET_DEPTH_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_FREQUENCY_NOT_SUPPORTED", VALUEFUNC(_wrap_MDStatisticRequestResult_FREQUENCY_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_STATISTIC_INTERVAL", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_INTERVAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_STATISTIC_DATE_RANGE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_DATE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TIME_RANGE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_STATISTIC_TIME_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNSUPPORTED_RATIO_TYPE", VALUEFUNC(_wrap_MDStatisticRequestResult_UNSUPPORTED_RATIO_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADE_INPUT_SOURCE", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADE_INPUT_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADING_SESSION", VALUEFUNC(_wrap_MDStatisticRequestResult_INVALID_OR_UNKNOWN_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_UNAUTHORIZED_FOR_STATISTIC_REQUEST", VALUEFUNC(_wrap_MDStatisticRequestResult_UNAUTHORIZED_FOR_STATISTIC_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticRequestResult_OTHER", VALUEFUNC(_wrap_MDStatisticRequestResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticStatus_ACTIVE", VALUEFUNC(_wrap_MDStatisticStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticStatus_INACTIVE", VALUEFUNC(_wrap_MDStatisticStatus_INACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticValueType_ABSOLUTE", VALUEFUNC(_wrap_MDStatisticValueType_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDStatisticValueType_PERCENTAGE", VALUEFUNC(_wrap_MDStatisticValueType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetGroup_FINANCIALS", VALUEFUNC(_wrap_AssetGroup_FINANCIALS_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetGroup_COMMODITIES", VALUEFUNC(_wrap_AssetGroup_COMMODITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "AssetGroup_ALTERNATIVE_INVESTMENTS", VALUEFUNC(_wrap_AssetGroup_ALTERNATIVE_INVESTMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_UNKNOWN_TRADE", VALUEFUNC(_wrap_CollRptRejectReason_UNKNOWN_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_CollRptRejectReason_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_UNKNOWN_COUNTERPARTY", VALUEFUNC(_wrap_CollRptRejectReason_UNKNOWN_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_UNKNOWN_POSITION", VALUEFUNC(_wrap_CollRptRejectReason_UNKNOWN_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_UNACCEPTABLE_COLLATERAL", VALUEFUNC(_wrap_CollRptRejectReason_UNACCEPTABLE_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptRejectReason_OTHER", VALUEFUNC(_wrap_CollRptRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptStatus_ACCEPTED", VALUEFUNC(_wrap_CollRptStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptStatus_RECEIVED", VALUEFUNC(_wrap_CollRptStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollRptStatus_REJECTED", VALUEFUNC(_wrap_CollRptStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_ASW_SPREAD", VALUEFUNC(_wrap_RelativeValueType_ASW_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_OIS", VALUEFUNC(_wrap_RelativeValueType_OIS_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_Z_SPREAD", VALUEFUNC(_wrap_RelativeValueType_Z_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_DISCOUNT_MARGIN", VALUEFUNC(_wrap_RelativeValueType_DISCOUNT_MARGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_I_SPREAD", VALUEFUNC(_wrap_RelativeValueType_I_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_OAS", VALUEFUNC(_wrap_RelativeValueType_OAS_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_G_SPREAD", VALUEFUNC(_wrap_RelativeValueType_G_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_CDS_BASIS", VALUEFUNC(_wrap_RelativeValueType_CDS_BASIS_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_CDS_INTERPOLATED_BASIS", VALUEFUNC(_wrap_RelativeValueType_CDS_INTERPOLATED_BASIS_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_DV01", VALUEFUNC(_wrap_RelativeValueType_DV01_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_PV01", VALUEFUNC(_wrap_RelativeValueType_PV01_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueType_CS01", VALUEFUNC(_wrap_RelativeValueType_CS01_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueSide_BID", VALUEFUNC(_wrap_RelativeValueSide_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueSide_MID", VALUEFUNC(_wrap_RelativeValueSide_MID_get), 0);
  rb_define_singleton_method(mQuickfix, "RelativeValueSide_OFFER", VALUEFUNC(_wrap_RelativeValueSide_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_INSTRUMENT_REF_DATA", VALUEFUNC(_wrap_MDReportEvent_START_INSTRUMENT_REF_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_INSTRUMENT_REF_DATA", VALUEFUNC(_wrap_MDReportEvent_END_INSTRUMENT_REF_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_OFF_MARKET_TRADES", VALUEFUNC(_wrap_MDReportEvent_START_OFF_MARKET_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_OFF_MARKET_TRADES", VALUEFUNC(_wrap_MDReportEvent_END_OFF_MARKET_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_ORDER_BOOK_TRADES", VALUEFUNC(_wrap_MDReportEvent_START_ORDER_BOOK_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_ORDER_BOOK_TRADES", VALUEFUNC(_wrap_MDReportEvent_END_ORDER_BOOK_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_OPEN_INTEREST", VALUEFUNC(_wrap_MDReportEvent_START_OPEN_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_OPEN_INTEREST", VALUEFUNC(_wrap_MDReportEvent_END_OPEN_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_SETTLEMENT_PRICES", VALUEFUNC(_wrap_MDReportEvent_START_SETTLEMENT_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_SETTLEMENT_PRICES", VALUEFUNC(_wrap_MDReportEvent_END_SETTLEMENT_PRICES_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_STATS_REF_DATA", VALUEFUNC(_wrap_MDReportEvent_START_STATS_REF_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_STATS_REF_DATA", VALUEFUNC(_wrap_MDReportEvent_END_STATS_REF_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_START_STATISTICS", VALUEFUNC(_wrap_MDReportEvent_START_STATISTICS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReportEvent_END_STATISTICS", VALUEFUNC(_wrap_MDReportEvent_END_STATISTICS_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentStatus_ACTIVE", VALUEFUNC(_wrap_MarketSegmentStatus_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentStatus_INACTIVE", VALUEFUNC(_wrap_MarketSegmentStatus_INACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentStatus_PUBLISHED", VALUEFUNC(_wrap_MarketSegmentStatus_PUBLISHED_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentType_POOL", VALUEFUNC(_wrap_MarketSegmentType_POOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentType_RETAIL", VALUEFUNC(_wrap_MarketSegmentType_RETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentType_WHOLESALE", VALUEFUNC(_wrap_MarketSegmentType_WHOLESALE_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentSubType_INTER_PRODUCT_SPREAD", VALUEFUNC(_wrap_MarketSegmentSubType_INTER_PRODUCT_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentRelationship_MARKET_SEGMENT_POOL_MEMBER", VALUEFUNC(_wrap_MarketSegmentRelationship_MARKET_SEGMENT_POOL_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentRelationship_RETAIL_SEGMENT", VALUEFUNC(_wrap_MarketSegmentRelationship_RETAIL_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketSegmentRelationship_WHOLESALE_SEGMENT", VALUEFUNC(_wrap_MarketSegmentRelationship_WHOLESALE_SEGMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteSideIndicator_NO", VALUEFUNC(_wrap_QuoteSideIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteSideIndicator_YES", VALUEFUNC(_wrap_QuoteSideIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerPriority_NO_PRIORITY", VALUEFUNC(_wrap_CustomerPriority_NO_PRIORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerPriority_UNCONDITIONAL_PRIORITY", VALUEFUNC(_wrap_CustomerPriority_UNCONDITIONAL_PRIORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_SHARES", VALUEFUNC(_wrap_SettlSubMethod_SHARES_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_DERIVATIVES", VALUEFUNC(_wrap_SettlSubMethod_DERIVATIVES_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_PAYMENT_VS_PAYMENT", VALUEFUNC(_wrap_SettlSubMethod_PAYMENT_VS_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_NOTIONAL", VALUEFUNC(_wrap_SettlSubMethod_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_CASCADE", VALUEFUNC(_wrap_SettlSubMethod_CASCADE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_REPURCHASE", VALUEFUNC(_wrap_SettlSubMethod_REPURCHASE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlSubMethod_OTHER", VALUEFUNC(_wrap_SettlSubMethod_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "CalculationMethod_AUTOMATIC", VALUEFUNC(_wrap_CalculationMethod_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "CalculationMethod_MANUAL", VALUEFUNC(_wrap_CalculationMethod_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_MARKET_VALUATION", VALUEFUNC(_wrap_CollateralAmountType_MARKET_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_PORTFOLIO_VALUE", VALUEFUNC(_wrap_CollateralAmountType_PORTFOLIO_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_VALUE_CONFIRMED", VALUEFUNC(_wrap_CollateralAmountType_VALUE_CONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_COLLATERAL_CREDIT_VALUE", VALUEFUNC(_wrap_CollateralAmountType_COLLATERAL_CREDIT_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_ADDITIONAL_COLLATERAL_VALUE", VALUEFUNC(_wrap_CollateralAmountType_ADDITIONAL_COLLATERAL_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralAmountType_ESTIMATED_MARKET_VALUATION", VALUEFUNC(_wrap_CollateralAmountType_ESTIMATED_MARKET_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_UNSPECIFIED", VALUEFUNC(_wrap_CommissionAmountType_UNSPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_ACCEPTANCE", VALUEFUNC(_wrap_CommissionAmountType_ACCEPTANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_BROKER", VALUEFUNC(_wrap_CommissionAmountType_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_CLEARING_BROKER", VALUEFUNC(_wrap_CommissionAmountType_CLEARING_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_RETAIL", VALUEFUNC(_wrap_CommissionAmountType_RETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_SALES_COMMISSION", VALUEFUNC(_wrap_CommissionAmountType_SALES_COMMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_LOCAL_COMMISSION", VALUEFUNC(_wrap_CommissionAmountType_LOCAL_COMMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountType_RESEARCH_PAYMENT", VALUEFUNC(_wrap_CommissionAmountType_RESEARCH_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlPriceDefault_CLOSE", VALUEFUNC(_wrap_CashSettlPriceDefault_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CashSettlPriceDefault_HEDGE", VALUEFUNC(_wrap_CashSettlPriceDefault_HEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPVFinalPriceElectionFallback_CLOSE", VALUEFUNC(_wrap_ComplexEventPVFinalPriceElectionFallback_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ComplexEventPVFinalPriceElectionFallback_HEDGE_ELECTION", VALUEFUNC(_wrap_ComplexEventPVFinalPriceElectionFallback_HEDGE_ELECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendEntitlementEvent_EX_DATE", VALUEFUNC(_wrap_DividendEntitlementEvent_EX_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendEntitlementEvent_RECORD_DATE", VALUEFUNC(_wrap_DividendEntitlementEvent_RECORD_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendAmountType_RECORD_AMOUNT", VALUEFUNC(_wrap_DividendAmountType_RECORD_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendAmountType_EX_AMOUNT", VALUEFUNC(_wrap_DividendAmountType_EX_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendAmountType_PAID_AMOUNT", VALUEFUNC(_wrap_DividendAmountType_PAID_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendAmountType_PER_MASTER_CONFIRM", VALUEFUNC(_wrap_DividendAmountType_PER_MASTER_CONFIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "NonCashDividendTreatment_POTENTIAL_ADJUSTMENT", VALUEFUNC(_wrap_NonCashDividendTreatment_POTENTIAL_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "NonCashDividendTreatment_CASH_EQUIVALENT", VALUEFUNC(_wrap_NonCashDividendTreatment_CASH_EQUIVALENT_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendComposition_EQUITY_AMOUNT_RECEIVER", VALUEFUNC(_wrap_DividendComposition_EQUITY_AMOUNT_RECEIVER_get), 0);
  rb_define_singleton_method(mQuickfix, "DividendComposition_CALCULATION_AGENT", VALUEFUNC(_wrap_DividendComposition_CALCULATION_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikeIndexQuote_BID", VALUEFUNC(_wrap_StrikeIndexQuote_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikeIndexQuote_MID", VALUEFUNC(_wrap_StrikeIndexQuote_MID_get), 0);
  rb_define_singleton_method(mQuickfix, "StrikeIndexQuote_OFFER", VALUEFUNC(_wrap_StrikeIndexQuote_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExtraordinaryEventAdjustmentMethod_CALCULATION_AGENT", VALUEFUNC(_wrap_ExtraordinaryEventAdjustmentMethod_CALCULATION_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExtraordinaryEventAdjustmentMethod_OPTIONS_EXCHANGE", VALUEFUNC(_wrap_ExtraordinaryEventAdjustmentMethod_OPTIONS_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInterpolationPeriod_INITIAL", VALUEFUNC(_wrap_PaymentStreamInterpolationPeriod_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInterpolationPeriod_INITIAL_AND_FINAL", VALUEFUNC(_wrap_PaymentStreamInterpolationPeriod_INITIAL_AND_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInterpolationPeriod_FINAL", VALUEFUNC(_wrap_PaymentStreamInterpolationPeriod_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamInterpolationPeriod_ANY_PERIOD", VALUEFUNC(_wrap_PaymentStreamInterpolationPeriod_ANY_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamLinkStrikePriceType_VOLATILITY", VALUEFUNC(_wrap_PaymentStreamLinkStrikePriceType_VOLATILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamLinkStrikePriceType_VARIANCE", VALUEFUNC(_wrap_PaymentStreamLinkStrikePriceType_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRealizedVarianceMethod_PREVIOUS", VALUEFUNC(_wrap_PaymentStreamRealizedVarianceMethod_PREVIOUS_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRealizedVarianceMethod_LAST", VALUEFUNC(_wrap_PaymentStreamRealizedVarianceMethod_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentStreamRealizedVarianceMethod_BOTH", VALUEFUNC(_wrap_PaymentStreamRealizedVarianceMethod_BOTH_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionBreakFeeElection_FLAT_FEE", VALUEFUNC(_wrap_ProvisionBreakFeeElection_FLAT_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionBreakFeeElection_AMORTIZED_FEE", VALUEFUNC(_wrap_ProvisionBreakFeeElection_AMORTIZED_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionBreakFeeElection_FUNDING_FEE", VALUEFUNC(_wrap_ProvisionBreakFeeElection_FUNDING_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionBreakFeeElection_FLAT_AND_FUNDING_FEE", VALUEFUNC(_wrap_ProvisionBreakFeeElection_FLAT_AND_FUNDING_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "ProvisionBreakFeeElection_AMORTIZED_AND_FUNDING_FEE", VALUEFUNC(_wrap_ProvisionBreakFeeElection_AMORTIZED_AND_FUNDING_FEE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateDateMode_PRICE_VALUATION", VALUEFUNC(_wrap_ReturnRateDateMode_PRICE_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateDateMode_DIVIDEND_VALUATION", VALUEFUNC(_wrap_ReturnRateDateMode_DIVIDEND_VALUATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceSequence_INITIAL", VALUEFUNC(_wrap_ReturnRatePriceSequence_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceSequence_INTERIM", VALUEFUNC(_wrap_ReturnRatePriceSequence_INTERIM_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceSequence_FINAL", VALUEFUNC(_wrap_ReturnRatePriceSequence_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_OPEN", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_OFFICIAL_SETTL_PX", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_OFFICIAL_SETTL_PX_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_XETRA", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_XETRA_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_CLOSE", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_DERIVATIVES_CLOSE", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_DERIVATIVES_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_HIGH", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_HIGH_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_LOW", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_LOW_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateQuoteTimeType_AS_SPECIFIED_IN_MASTER_CONFIRMATION", VALUEFUNC(_wrap_ReturnRateQuoteTimeType_AS_SPECIFIED_IN_MASTER_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateValuationPriceOption_NONE", VALUEFUNC(_wrap_ReturnRateValuationPriceOption_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateValuationPriceOption_FUTURES_PRICE", VALUEFUNC(_wrap_ReturnRateValuationPriceOption_FUTURES_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRateValuationPriceOption_OPTIONS_PRICE", VALUEFUNC(_wrap_ReturnRateValuationPriceOption_OPTIONS_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceBasis_GROSS", VALUEFUNC(_wrap_ReturnRatePriceBasis_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceBasis_NET", VALUEFUNC(_wrap_ReturnRatePriceBasis_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceBasis_ACCRUED", VALUEFUNC(_wrap_ReturnRatePriceBasis_ACCRUED_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceBasis_CLEAN_NET", VALUEFUNC(_wrap_ReturnRatePriceBasis_CLEAN_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceType_ABSOLUTE_TERMS", VALUEFUNC(_wrap_ReturnRatePriceType_ABSOLUTE_TERMS_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnRatePriceType_PERCENTAGE_OF_NOTIONAL", VALUEFUNC(_wrap_ReturnRatePriceType_PERCENTAGE_OF_NOTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalAdjustments_EXECUTION", VALUEFUNC(_wrap_StreamNotionalAdjustments_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalAdjustments_PORTFOLIO_REBALANCING", VALUEFUNC(_wrap_StreamNotionalAdjustments_PORTFOLIO_REBALANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "StreamNotionalAdjustments_STANDARD", VALUEFUNC(_wrap_StreamNotionalAdjustments_STANDARD_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingNotionalAdjustments_EXECUTION", VALUEFUNC(_wrap_UnderlyingNotionalAdjustments_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingNotionalAdjustments_PORTFOLIO_REBALANCING", VALUEFUNC(_wrap_UnderlyingNotionalAdjustments_PORTFOLIO_REBALANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "UnderlyingNotionalAdjustments_STANDARD", VALUEFUNC(_wrap_UnderlyingNotionalAdjustments_STANDARD_get), 0);
  rb_define_singleton_method(mQuickfix, "RemunerationIndicator_NO_REMUNERATION_PAID", VALUEFUNC(_wrap_RemunerationIndicator_NO_REMUNERATION_PAID_get), 0);
  rb_define_singleton_method(mQuickfix, "RemunerationIndicator_REMUNERATION_PAID", VALUEFUNC(_wrap_RemunerationIndicator_REMUNERATION_PAID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRiskLimitStatus_DISABLED", VALUEFUNC(_wrap_PartyRiskLimitStatus_DISABLED_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRiskLimitStatus_ENABLED", VALUEFUNC(_wrap_PartyRiskLimitStatus_ENABLED_get), 0);
  rb_define_singleton_method(mQuickfix, "AlgorithmicTradeIndicator_NON_ALGORITHMIC_TRADE", VALUEFUNC(_wrap_AlgorithmicTradeIndicator_NON_ALGORITHMIC_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AlgorithmicTradeIndicator_ALGORITHMIC_TRADE", VALUEFUNC(_wrap_AlgorithmicTradeIndicator_ALGORITHMIC_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_PRE_TRADE_TRANSPARENCY_WAIVER", VALUEFUNC(_wrap_TrdRegPublicationType_PRE_TRADE_TRANSPARENCY_WAIVER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_POST_TRADE_DEFERRAL", VALUEFUNC(_wrap_TrdRegPublicationType_POST_TRADE_DEFERRAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_EXEMPT_FROM_PUBLICATION", VALUEFUNC(_wrap_TrdRegPublicationType_EXEMPT_FROM_PUBLICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_SUBSCRIBERS", VALUEFUNC(_wrap_TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_SUBSCRIBERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_PRICE_LEVEL_PUBLICATION_TO_SUBSCRIBERS", VALUEFUNC(_wrap_TrdRegPublicationType_PRICE_LEVEL_PUBLICATION_TO_SUBSCRIBERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_THE_PUBLIC", VALUEFUNC(_wrap_TrdRegPublicationType_ORDER_LEVEL_PUBLICATION_TO_THE_PUBLIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationType_PUBLICATION_INTERNAL_TO_EXECUTION_VENUE", VALUEFUNC(_wrap_TrdRegPublicationType_PUBLICATION_INTERNAL_TO_EXECUTION_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_AVERAGE_SPREAD_PRICE", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_AVERAGE_SPREAD_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_REF_PRICE", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_REF_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_OTHER_CONDITIONS", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_BOOK_ORDER_DUE_TO_OTHER_CONDITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_REF_PRICE", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_REF_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ILLIQUID", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ILLIQUID_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ORDER_SIZE", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_ORDER_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_DEFERRAL_DUE_TO_LARGE_IN_SCALE", VALUEFUNC(_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_DEFERRAL_DUE_TO_ILLIQUID", VALUEFUNC(_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_ILLIQUID_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_DEFERRAL_DUE_TO_SIZE_SPECIFIC", VALUEFUNC(_wrap_TrdRegPublicationReason_DEFERRAL_DUE_TO_SIZE_SPECIFIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_LARGE_IN_SCALE", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_DUE_TO_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_NO_PUBLIC_PRICE_SIZE_DUE_TO_ORDER_HIDDEN", VALUEFUNC(_wrap_TrdRegPublicationReason_NO_PUBLIC_PRICE_SIZE_DUE_TO_ORDER_HIDDEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_EXEMPTED_DUE_TO_SECURITIES_FINANCING_TRANSACTION", VALUEFUNC(_wrap_TrdRegPublicationReason_EXEMPTED_DUE_TO_SECURITIES_FINANCING_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_EXEMPTED_DUE_TO_ESCB_POLICY_TRANSACTION", VALUEFUNC(_wrap_TrdRegPublicationReason_EXEMPTED_DUE_TO_ESCB_POLICY_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_EXCEPTION_DUE_TO_REPORT_BY_PAPER", VALUEFUNC(_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_REPORT_BY_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_EXCEPTION_DUE_TO_TRADE_EXECUTED_WITH_NON_REPORTING_PARTY", VALUEFUNC(_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_TRADE_EXECUTED_WITH_NON_REPORTING_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_EXCEPTION_DUE_TO_INTRA_FIRM_ORDER", VALUEFUNC(_wrap_TrdRegPublicationReason_EXCEPTION_DUE_TO_INTRA_FIRM_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegPublicationReason_REPORTED_OUTSIDE_REPORTING_HOURS", VALUEFUNC(_wrap_TrdRegPublicationReason_REPORTED_OUTSIDE_REPORTING_HOURS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossedIndicator_NO_CROSS", VALUEFUNC(_wrap_CrossedIndicator_NO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossedIndicator_CROSS_REJECTED", VALUEFUNC(_wrap_CrossedIndicator_CROSS_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossedIndicator_CROSS_ACCEPTED", VALUEFUNC(_wrap_CrossedIndicator_CROSS_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_AGGREGATED_ORDER", VALUEFUNC(_wrap_OrderAttributeType_AGGREGATED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_PENDING_ALLOCATION", VALUEFUNC(_wrap_OrderAttributeType_PENDING_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_LIQUIDITY_PROVISION_ACTIVITY_ORDER", VALUEFUNC(_wrap_OrderAttributeType_LIQUIDITY_PROVISION_ACTIVITY_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_RISK_REDUCTION_ORDER", VALUEFUNC(_wrap_OrderAttributeType_RISK_REDUCTION_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_ALGORITHMIC_ORDER", VALUEFUNC(_wrap_OrderAttributeType_ALGORITHMIC_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_SYSTEMATIC_INTERNALISER_ORDER", VALUEFUNC(_wrap_OrderAttributeType_SYSTEMATIC_INTERNALISER_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_ALL_EXECUTIONS_SUBMITTED_TO_APA", VALUEFUNC(_wrap_OrderAttributeType_ALL_EXECUTIONS_SUBMITTED_TO_APA_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_ORDER_EXECUTION_INSTRUCTED_BY_CLIENT", VALUEFUNC(_wrap_OrderAttributeType_ORDER_EXECUTION_INSTRUCTED_BY_CLIENT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_LARGE_IN_SCALE", VALUEFUNC(_wrap_OrderAttributeType_LARGE_IN_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_HIDDEN", VALUEFUNC(_wrap_OrderAttributeType_HIDDEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_SUBJECT_TO_EUSTO", VALUEFUNC(_wrap_OrderAttributeType_SUBJECT_TO_EUSTO_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_SUBJECT_TO_UKSTO", VALUEFUNC(_wrap_OrderAttributeType_SUBJECT_TO_UKSTO_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_REPRESENTATIVE_ORDER", VALUEFUNC(_wrap_OrderAttributeType_REPRESENTATIVE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_LINKAGE_TYPE", VALUEFUNC(_wrap_OrderAttributeType_LINKAGE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderAttributeType_EXEMPT_FROM_STO", VALUEFUNC(_wrap_OrderAttributeType_EXEMPT_FROM_STO_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_NOT_REPORTED", VALUEFUNC(_wrap_TradeReportingIndicator_NOT_REPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_ON_BOOK", VALUEFUNC(_wrap_TradeReportingIndicator_ON_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_SI_SELLER", VALUEFUNC(_wrap_TradeReportingIndicator_SI_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_SI_BUYER", VALUEFUNC(_wrap_TradeReportingIndicator_SI_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_NON_SI_SELLER", VALUEFUNC(_wrap_TradeReportingIndicator_NON_SI_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_SUB_DELEGATION_BY_FIRM", VALUEFUNC(_wrap_TradeReportingIndicator_SUB_DELEGATION_BY_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_REPORTABLE", VALUEFUNC(_wrap_TradeReportingIndicator_REPORTABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_NON_SI_BUYER", VALUEFUNC(_wrap_TradeReportingIndicator_NON_SI_BUYER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_OFF_BOOK", VALUEFUNC(_wrap_TradeReportingIndicator_OFF_BOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportingIndicator_NOT_REPORTABLE", VALUEFUNC(_wrap_TradeReportingIndicator_NOT_REPORTABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_NONE", VALUEFUNC(_wrap_MassActionReason_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_TRADING_RISK_CONTROL", VALUEFUNC(_wrap_MassActionReason_TRADING_RISK_CONTROL_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_CLEARING_RISK_CONTROL", VALUEFUNC(_wrap_MassActionReason_CLEARING_RISK_CONTROL_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_MARKET_MAKER_PROTECTION", VALUEFUNC(_wrap_MassActionReason_MARKET_MAKER_PROTECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_STOP_TRADING", VALUEFUNC(_wrap_MassActionReason_STOP_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_EMERGENCY_ACTION", VALUEFUNC(_wrap_MassActionReason_EMERGENCY_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_SESSION_LOSS_LOGOUT", VALUEFUNC(_wrap_MassActionReason_SESSION_LOSS_LOGOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_DUPLICATE_LOGIN", VALUEFUNC(_wrap_MassActionReason_DUPLICATE_LOGIN_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_PRODUCT_NOT_TRADED", VALUEFUNC(_wrap_MassActionReason_PRODUCT_NOT_TRADED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_INSTRUMENT_NOT_TRADED", VALUEFUNC(_wrap_MassActionReason_INSTRUMENT_NOT_TRADED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_COMPLE_INSTRUMENT_DELETED", VALUEFUNC(_wrap_MassActionReason_COMPLE_INSTRUMENT_DELETED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_CIRCUIT_BREAKER_ACTIVATED", VALUEFUNC(_wrap_MassActionReason_CIRCUIT_BREAKER_ACTIVATED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassActionReason_OTHER", VALUEFUNC(_wrap_MassActionReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "NotAffectedReason_ORDER_SUSPENDED", VALUEFUNC(_wrap_NotAffectedReason_ORDER_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "NotAffectedReason_INSTRUMENT_SUSPENDED", VALUEFUNC(_wrap_NotAffectedReason_INSTRUMENT_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOwnershipIndicator_NO_CHANGE", VALUEFUNC(_wrap_OrderOwnershipIndicator_NO_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOwnershipIndicator_EXECUTING_PARTY_CHANGE", VALUEFUNC(_wrap_OrderOwnershipIndicator_EXECUTING_PARTY_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOwnershipIndicator_ENTERING_PARTY_CHANGE", VALUEFUNC(_wrap_OrderOwnershipIndicator_ENTERING_PARTY_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderOwnershipIndicator_SPECIFIED_PARTY_CHANGE", VALUEFUNC(_wrap_OrderOwnershipIndicator_SPECIFIED_PARTY_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "InTheMoneyCondition_STANDARD_ITM", VALUEFUNC(_wrap_InTheMoneyCondition_STANDARD_ITM_get), 0);
  rb_define_singleton_method(mQuickfix, "InTheMoneyCondition_ATMITM", VALUEFUNC(_wrap_InTheMoneyCondition_ATMITM_get), 0);
  rb_define_singleton_method(mQuickfix, "InTheMoneyCondition_ATM_CALL_ITM", VALUEFUNC(_wrap_InTheMoneyCondition_ATM_CALL_ITM_get), 0);
  rb_define_singleton_method(mQuickfix, "InTheMoneyCondition_ATM_PUT_ITM", VALUEFUNC(_wrap_InTheMoneyCondition_ATM_PUT_ITM_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationType_NO_RESTRICTION", VALUEFUNC(_wrap_ExDestinationType_NO_RESTRICTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationType_TRADED_ONLY_ON_TRADING_VENUE", VALUEFUNC(_wrap_ExDestinationType_TRADED_ONLY_ON_TRADING_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationType_TRADED_ONLY_ON_SI", VALUEFUNC(_wrap_ExDestinationType_TRADED_ONLY_ON_SI_get), 0);
  rb_define_singleton_method(mQuickfix, "ExDestinationType_TRADED_ON_TRADING_VENUE_OR_SI", VALUEFUNC(_wrap_ExDestinationType_TRADED_ON_TRADING_VENUE_OR_SI_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketCondition_NORMAL", VALUEFUNC(_wrap_MarketCondition_NORMAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketCondition_STRESSED", VALUEFUNC(_wrap_MarketCondition_STRESSED_get), 0);
  rb_define_singleton_method(mQuickfix, "MarketCondition_EXCEPTIONAL", VALUEFUNC(_wrap_MarketCondition_EXCEPTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAttributeType_QUOTE_ABOVE_STANDARD_MARKET_SIZE", VALUEFUNC(_wrap_QuoteAttributeType_QUOTE_ABOVE_STANDARD_MARKET_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAttributeType_QUOTE_ABOVE_SPECIFIC_INSTRUMENT_SIZE", VALUEFUNC(_wrap_QuoteAttributeType_QUOTE_ABOVE_SPECIFIC_INSTRUMENT_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAttributeType_QUOTE_APPLICABLE_FOR_LIQUIDTY_PROVISION_ACTIVITY", VALUEFUNC(_wrap_QuoteAttributeType_QUOTE_APPLICABLE_FOR_LIQUIDTY_PROVISION_ACTIVITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAttributeType_QUOTE_ISSUER_STATUS", VALUEFUNC(_wrap_QuoteAttributeType_QUOTE_ISSUER_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteAttributeType_BID_OR_ASK_REQUEST", VALUEFUNC(_wrap_QuoteAttributeType_BID_OR_ASK_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQualifier_ACCRUED_INTEREST_IS_FACTORED", VALUEFUNC(_wrap_PriceQualifier_ACCRUED_INTEREST_IS_FACTORED_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQualifier_TAX_IS_FACTORED", VALUEFUNC(_wrap_PriceQualifier_TAX_IS_FACTORED_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceQualifier_BOND_AMORTIZATION_IS_FACTORED", VALUEFUNC(_wrap_PriceQualifier_BOND_AMORTIZATION_IS_FACTORED_get), 0);
  rb_define_singleton_method(mQuickfix, "MDValueTier_RANGE1", VALUEFUNC(_wrap_MDValueTier_RANGE1_get), 0);
  rb_define_singleton_method(mQuickfix, "MDValueTier_RANGE2", VALUEFUNC(_wrap_MDValueTier_RANGE2_get), 0);
  rb_define_singleton_method(mQuickfix, "MDValueTier_RANGE3", VALUEFUNC(_wrap_MDValueTier_RANGE3_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeQualifier_CONTRIBUTES", VALUEFUNC(_wrap_MiscFeeQualifier_CONTRIBUTES_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeQualifier_DOES_NOT_CONTRIBUTE", VALUEFUNC(_wrap_MiscFeeQualifier_DOES_NOT_CONTRIBUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountSubType_RESEARCH_PAYMENT_ACCOUNT", VALUEFUNC(_wrap_CommissionAmountSubType_RESEARCH_PAYMENT_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountSubType_COMMISSION_SHARING_AGREEMENT", VALUEFUNC(_wrap_CommissionAmountSubType_COMMISSION_SHARING_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommissionAmountSubType_OTHER_TYPE_RESEARCH_PAYMENT", VALUEFUNC(_wrap_CommissionAmountSubType_OTHER_TYPE_RESEARCH_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_ARGUS_MC_CLOSKEY", VALUEFUNC(_wrap_CommodityFinalPriceType_ARGUS_MC_CLOSKEY_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_BALTIC", VALUEFUNC(_wrap_CommodityFinalPriceType_BALTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_EXCHANGE", VALUEFUNC(_wrap_CommodityFinalPriceType_EXCHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_GLOBAL_COAL", VALUEFUNC(_wrap_CommodityFinalPriceType_GLOBAL_COAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_IHS_MC_CLOSKEY", VALUEFUNC(_wrap_CommodityFinalPriceType_IHS_MC_CLOSKEY_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_PLATTS", VALUEFUNC(_wrap_CommodityFinalPriceType_PLATTS_get), 0);
  rb_define_singleton_method(mQuickfix, "CommodityFinalPriceType_OTHER", VALUEFUNC(_wrap_CommodityFinalPriceType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceDataDateType_ADMIT_TO_TRADE_REQUEST_DATE", VALUEFUNC(_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_REQUEST_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceDataDateType_ADMIT_TO_TRADE_APPROVAL_DATE", VALUEFUNC(_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_APPROVAL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceDataDateType_ADMIT_TO_TRADE_OR_FIRST_TRADE_DATE", VALUEFUNC(_wrap_ReferenceDataDateType_ADMIT_TO_TRADE_OR_FIRST_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReferenceDataDateType_TERMINATION_DATE", VALUEFUNC(_wrap_ReferenceDataDateType_TERMINATION_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_DIVIDEND", VALUEFUNC(_wrap_ReturnTrigger_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_VARIANCE", VALUEFUNC(_wrap_ReturnTrigger_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_VOLATILITY", VALUEFUNC(_wrap_ReturnTrigger_VOLATILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_TOTAL_RETURN", VALUEFUNC(_wrap_ReturnTrigger_TOTAL_RETURN_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_CONTRACT_FOR_DIFFERENCE", VALUEFUNC(_wrap_ReturnTrigger_CONTRACT_FOR_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_CREDIT_DEFAULT", VALUEFUNC(_wrap_ReturnTrigger_CREDIT_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_SPREAD_BET", VALUEFUNC(_wrap_ReturnTrigger_SPREAD_BET_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_PRICE", VALUEFUNC(_wrap_ReturnTrigger_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_FORWARD_PRICE_UNDERLYING_INSTRUMENT", VALUEFUNC(_wrap_ReturnTrigger_FORWARD_PRICE_UNDERLYING_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ReturnTrigger_OTHER", VALUEFUNC(_wrap_ReturnTrigger_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AveragePriceType_TIME_WEIGHTED_AVERAGE_PRICE", VALUEFUNC(_wrap_AveragePriceType_TIME_WEIGHTED_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AveragePriceType_VOLUME_WEIGHTED_AVERAGE_PRICE", VALUEFUNC(_wrap_AveragePriceType_VOLUME_WEIGHTED_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AveragePriceType_PERCENT_OF_VOLUME_AVERAGE_PRICE", VALUEFUNC(_wrap_AveragePriceType_PERCENT_OF_VOLUME_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AveragePriceType_LIMIT_ORDER_AVERAGE_PRICE", VALUEFUNC(_wrap_AveragePriceType_LIMIT_ORDER_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocGroupStatus_ADDED", VALUEFUNC(_wrap_AllocGroupStatus_ADDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocGroupStatus_CANCELED", VALUEFUNC(_wrap_AllocGroupStatus_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocGroupStatus_REPLACED", VALUEFUNC(_wrap_AllocGroupStatus_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocGroupStatus_CHANGED", VALUEFUNC(_wrap_AllocGroupStatus_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocGroupStatus_PENDING", VALUEFUNC(_wrap_AllocGroupStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRequestStatus_ACCEPTED", VALUEFUNC(_wrap_AllocRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRequestStatus_REJECTED", VALUEFUNC(_wrap_AllocRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_NO_MATCHING_CONFIRMATION", VALUEFUNC(_wrap_MatchExceptionType_NO_MATCHING_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_NO_MATCHING_ALLOCATION", VALUEFUNC(_wrap_MatchExceptionType_NO_MATCHING_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_ALLOCATION_DATA_ELEMENT_MISSING", VALUEFUNC(_wrap_MatchExceptionType_ALLOCATION_DATA_ELEMENT_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_CONFIRMATION_DATA_ELEMENT_MISSING", VALUEFUNC(_wrap_MatchExceptionType_CONFIRMATION_DATA_ELEMENT_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_DATA_DIFFERENCE_NOT_WITHIN_TOLERANCE", VALUEFUNC(_wrap_MatchExceptionType_DATA_DIFFERENCE_NOT_WITHIN_TOLERANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_MATCH_WITHIN_TOLERANCE", VALUEFUNC(_wrap_MatchExceptionType_MATCH_WITHIN_TOLERANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionType_OTHER", VALUEFUNC(_wrap_MatchExceptionType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_ACCRUED_INTEREST", VALUEFUNC(_wrap_MatchExceptionElementType_ACCRUED_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_DEAL_PRICE", VALUEFUNC(_wrap_MatchExceptionElementType_DEAL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_TRADE_DATE", VALUEFUNC(_wrap_MatchExceptionElementType_TRADE_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_SETTLEMENT_DATE", VALUEFUNC(_wrap_MatchExceptionElementType_SETTLEMENT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_SIDE_INDICATOR", VALUEFUNC(_wrap_MatchExceptionElementType_SIDE_INDICATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_TRADED_CURRENCY", VALUEFUNC(_wrap_MatchExceptionElementType_TRADED_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_ACCOUNT_ID", VALUEFUNC(_wrap_MatchExceptionElementType_ACCOUNT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_EXECUTING_BROKER_ID", VALUEFUNC(_wrap_MatchExceptionElementType_EXECUTING_BROKER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_SETTLEMENT_CURRENCY_AND_AMOUNT", VALUEFUNC(_wrap_MatchExceptionElementType_SETTLEMENT_CURRENCY_AND_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_INVESTMENT_MANAGER_ID", VALUEFUNC(_wrap_MatchExceptionElementType_INVESTMENT_MANAGER_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_NET_AMOUNT", VALUEFUNC(_wrap_MatchExceptionElementType_NET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_PLACE_OF_SETTLEMENT", VALUEFUNC(_wrap_MatchExceptionElementType_PLACE_OF_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_COMMISSIONS", VALUEFUNC(_wrap_MatchExceptionElementType_COMMISSIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_SECURITY_IDENTIFIER", VALUEFUNC(_wrap_MatchExceptionElementType_SECURITY_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_QUALITY_ALLOCATED", VALUEFUNC(_wrap_MatchExceptionElementType_QUALITY_ALLOCATED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_PRINCIPAL", VALUEFUNC(_wrap_MatchExceptionElementType_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_FEES", VALUEFUNC(_wrap_MatchExceptionElementType_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionElementType_TAX", VALUEFUNC(_wrap_MatchExceptionElementType_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionToleranceValueType_FIXED_AMOUNT", VALUEFUNC(_wrap_MatchExceptionToleranceValueType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchExceptionToleranceValueType_PERCENTAGE", VALUEFUNC(_wrap_MatchExceptionToleranceValueType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchingDataPointIndicator_MANDATORY", VALUEFUNC(_wrap_MatchingDataPointIndicator_MANDATORY_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchingDataPointIndicator_OPTIONAL", VALUEFUNC(_wrap_MatchingDataPointIndicator_OPTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationTransType_NEW", VALUEFUNC(_wrap_TradeAggregationTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationTransType_CANCEL", VALUEFUNC(_wrap_TradeAggregationTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationTransType_REPLACE", VALUEFUNC(_wrap_TradeAggregationTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationRequestStatus_ACCEPTED", VALUEFUNC(_wrap_TradeAggregationRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationRequestStatus_REJECTED", VALUEFUNC(_wrap_TradeAggregationRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationRejectReason_UNKNOWN_ORDERS", VALUEFUNC(_wrap_TradeAggregationRejectReason_UNKNOWN_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationRejectReason_UNKNOWN_EXECUTION_FILLS", VALUEFUNC(_wrap_TradeAggregationRejectReason_UNKNOWN_EXECUTION_FILLS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAggregationRejectReason_OTHER", VALUEFUNC(_wrap_TradeAggregationRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "OffshoreIndicator_REGULAR", VALUEFUNC(_wrap_OffshoreIndicator_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "OffshoreIndicator_OFFSHORE", VALUEFUNC(_wrap_OffshoreIndicator_OFFSHORE_get), 0);
  rb_define_singleton_method(mQuickfix, "OffshoreIndicator_ONSHORE", VALUEFUNC(_wrap_OffshoreIndicator_ONSHORE_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportTransType_NEW", VALUEFUNC(_wrap_PayReportTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportTransType_REPLACE", VALUEFUNC(_wrap_PayReportTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportTransType_STATUS", VALUEFUNC(_wrap_PayReportTransType_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportStatus_RECEIVED", VALUEFUNC(_wrap_PayReportStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportStatus_ACCEPTED", VALUEFUNC(_wrap_PayReportStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportStatus_REJECTED", VALUEFUNC(_wrap_PayReportStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayReportStatus_DISPUTED", VALUEFUNC(_wrap_PayReportStatus_DISPUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestTransType_NEW", VALUEFUNC(_wrap_PayRequestTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestTransType_CANCEL", VALUEFUNC(_wrap_PayRequestTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestStatus_RECEIVED", VALUEFUNC(_wrap_PayRequestStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestStatus_ACCEPTED", VALUEFUNC(_wrap_PayRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestStatus_REJECTED", VALUEFUNC(_wrap_PayRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PayRequestStatus_DISPUTED", VALUEFUNC(_wrap_PayRequestStatus_DISPUTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentDebitOrCredit_DEBIT_PAY", VALUEFUNC(_wrap_PostTradePaymentDebitOrCredit_DEBIT_PAY_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentDebitOrCredit_CREDIT_RECEIVE", VALUEFUNC(_wrap_PostTradePaymentDebitOrCredit_CREDIT_RECEIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentStatus_NEW", VALUEFUNC(_wrap_PostTradePaymentStatus_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentStatus_INITIATED", VALUEFUNC(_wrap_PostTradePaymentStatus_INITIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentStatus_PENDING", VALUEFUNC(_wrap_PostTradePaymentStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentStatus_CONFIRMED", VALUEFUNC(_wrap_PostTradePaymentStatus_CONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "PostTradePaymentStatus_REJECTED", VALUEFUNC(_wrap_PostTradePaymentStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "DuplicateClOrdIDIndicator_NO", VALUEFUNC(_wrap_DuplicateClOrdIDIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "DuplicateClOrdIDIndicator_YES", VALUEFUNC(_wrap_DuplicateClOrdIDIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "EventInitiatorType_CUSTOMER_OR_CLIENT", VALUEFUNC(_wrap_EventInitiatorType_CUSTOMER_OR_CLIENT_get), 0);
  rb_define_singleton_method(mQuickfix, "EventInitiatorType_EXCHANGE_OR_EXECUTION_VENUE", VALUEFUNC(_wrap_EventInitiatorType_EXCHANGE_OR_EXECUTION_VENUE_get), 0);
  rb_define_singleton_method(mQuickfix, "EventInitiatorType_FIRM_OR_BROKER", VALUEFUNC(_wrap_EventInitiatorType_FIRM_OR_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOEntryType_BID", VALUEFUNC(_wrap_NBBOEntryType_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOEntryType_OFFER", VALUEFUNC(_wrap_NBBOEntryType_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOEntryType_MID_PRICE", VALUEFUNC(_wrap_NBBOEntryType_MID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOSource_NOT_APPLICABLE", VALUEFUNC(_wrap_NBBOSource_NOT_APPLICABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOSource_DIRECT", VALUEFUNC(_wrap_NBBOSource_DIRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOSource_SIP", VALUEFUNC(_wrap_NBBOSource_SIP_get), 0);
  rb_define_singleton_method(mQuickfix, "NBBOSource_HYBRID", VALUEFUNC(_wrap_NBBOSource_HYBRID_get), 0);
  rb_define_singleton_method(mQuickfix, "SingleQuoteIndicator_NO", VALUEFUNC(_wrap_SingleQuoteIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "SingleQuoteIndicator_YES", VALUEFUNC(_wrap_SingleQuoteIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampManualIndicator_NO", VALUEFUNC(_wrap_TrdRegTimestampManualIndicator_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampManualIndicator_YES", VALUEFUNC(_wrap_TrdRegTimestampManualIndicator_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralReinvestmentType_MONEY_MARKET_FUND", VALUEFUNC(_wrap_CollateralReinvestmentType_MONEY_MARKET_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralReinvestmentType_OTHER_COMINGLED_POOL", VALUEFUNC(_wrap_CollateralReinvestmentType_OTHER_COMINGLED_POOL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralReinvestmentType_REPO_MARKET", VALUEFUNC(_wrap_CollateralReinvestmentType_REPO_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralReinvestmentType_DIRECT_PURCHASE_OF_SECURITIES", VALUEFUNC(_wrap_CollateralReinvestmentType_DIRECT_PURCHASE_OF_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollateralReinvestmentType_OTHER_INVESTMENTS", VALUEFUNC(_wrap_CollateralReinvestmentType_OTHER_INVESTMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_REPO", VALUEFUNC(_wrap_FundingSource_REPO_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_CASH", VALUEFUNC(_wrap_FundingSource_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_FREE_CEDITS", VALUEFUNC(_wrap_FundingSource_FREE_CEDITS_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_CUSTOMER_SHORT_SALES", VALUEFUNC(_wrap_FundingSource_CUSTOMER_SHORT_SALES_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_BROKER_SHORT_SALES", VALUEFUNC(_wrap_FundingSource_BROKER_SHORT_SALES_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_UNSECURED_BORROWING", VALUEFUNC(_wrap_FundingSource_UNSECURED_BORROWING_get), 0);
  rb_define_singleton_method(mQuickfix, "FundingSource_OTHER", VALUEFUNC(_wrap_FundingSource_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginDirection_POSTED", VALUEFUNC(_wrap_MarginDirection_POSTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MarginDirection_RECEIVED", VALUEFUNC(_wrap_MarginDirection_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "TransactionAttributeType_EXCLUSIVE_ARRANGEMENT", VALUEFUNC(_wrap_TransactionAttributeType_EXCLUSIVE_ARRANGEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TransactionAttributeType_COLLATERAL_REUSE", VALUEFUNC(_wrap_TransactionAttributeType_COLLATERAL_REUSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TransactionAttributeType_COLLATERAL_ARRANGMENT_TYPE", VALUEFUNC(_wrap_TransactionAttributeType_COLLATERAL_ARRANGMENT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingArrangmentIndicator_NO_ROUTING_ARRANGMENT_IN_PLACE", VALUEFUNC(_wrap_RoutingArrangmentIndicator_NO_ROUTING_ARRANGMENT_IN_PLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingArrangmentIndicator_ROUTING_ARRANGEMENT_IN_PLACE", VALUEFUNC(_wrap_RoutingArrangmentIndicator_ROUTING_ARRANGEMENT_IN_PLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedOrderIDSource_NON_FIX_SOURCE", VALUEFUNC(_wrap_RelatedOrderIDSource_NON_FIX_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedOrderIDSource_SYSTEM_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RelatedOrderIDSource_SYSTEM_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedOrderIDSource_CLIENT_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RelatedOrderIDSource_CLIENT_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedOrderIDSource_SECONDARY_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RelatedOrderIDSource_SECONDARY_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "RelatedOrderIDSource_SECONDARY_CLIENT_ORDER_IDENTIFIER", VALUEFUNC(_wrap_RelatedOrderIDSource_SECONDARY_CLIENT_ORDER_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRelationship_NOT_SPECIFIED", VALUEFUNC(_wrap_OrderRelationship_NOT_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRelationship_ORDER_AGGREGATION", VALUEFUNC(_wrap_OrderRelationship_ORDER_AGGREGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRelationship_ORDER_SPLIT", VALUEFUNC(_wrap_OrderRelationship_ORDER_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_CUSIP", VALUEFUNC(_wrap_CurrencyCodeSource_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_SEDOL", VALUEFUNC(_wrap_CurrencyCodeSource_SEDOL_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_ISIN_NUMBER", VALUEFUNC(_wrap_CurrencyCodeSource_ISIN_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_CurrencyCodeSource_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER", VALUEFUNC(_wrap_CurrencyCodeSource_FINANCIAL_INSTRUMENT_GLOBAL_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "CurrencyCodeSource_DIGITAL_TOKEN_IDENTIFIER", VALUEFUNC(_wrap_CurrencyCodeSource_DIGITAL_TOKEN_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiJurisdictionReportingIndicator_NOT_MULTI_JRSDCTN_ELIGIBLE", VALUEFUNC(_wrap_MultiJurisdictionReportingIndicator_NOT_MULTI_JRSDCTN_ELIGIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiJurisdictionReportingIndicator_MULTI_JRSDCTN_ELIGIBLE", VALUEFUNC(_wrap_MultiJurisdictionReportingIndicator_MULTI_JRSDCTN_ELIGIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE", VALUEFUNC(_wrap_SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SelfMatchPreventionInstruction_CANCEL_PASSIVE", VALUEFUNC(_wrap_SelfMatchPreventionInstruction_CANCEL_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_PASSIVE", VALUEFUNC(_wrap_SelfMatchPreventionInstruction_CANCEL_AGGRESSIVE_PASSIVE_get), 0);
  
  SwigClassSessionID.klass = rb_define_class_under(mQuickfix, "SessionID", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionID, (void *) &SwigClassSessionID);
  rb_define_alloc_func(SwigClassSessionID.klass, _wrap_SessionID_allocate);
  rb_define_method(SwigClassSessionID.klass, "initialize", VALUEFUNC(_wrap_new_SessionID), -1);
  rb_define_method(SwigClassSessionID.klass, "getBeginString", VALUEFUNC(_wrap_SessionID_getBeginString), -1);
  rb_define_method(SwigClassSessionID.klass, "getSenderCompID", VALUEFUNC(_wrap_SessionID_getSenderCompID), -1);
  rb_define_method(SwigClassSessionID.klass, "getTargetCompID", VALUEFUNC(_wrap_SessionID_getTargetCompID), -1);
  rb_define_method(SwigClassSessionID.klass, "getSessionQualifier", VALUEFUNC(_wrap_SessionID_getSessionQualifier), -1);
  rb_define_method(SwigClassSessionID.klass, "isFIXT", VALUEFUNC(_wrap_SessionID_isFIXT), -1);
  rb_define_method(SwigClassSessionID.klass, "toStringFrozen", VALUEFUNC(_wrap_SessionID_toStringFrozen), -1);
  rb_define_method(SwigClassSessionID.klass, "fromString", VALUEFUNC(_wrap_SessionID_fromString), -1);
  rb_define_method(SwigClassSessionID.klass, "toString", VALUEFUNC(_wrap_SessionID_toString), -1);
  rb_define_method(SwigClassSessionID.klass, "~", VALUEFUNC(_wrap_SessionID___invert__), -1);
  rb_define_method(SwigClassSessionID.klass, "to_s", VALUEFUNC(_wrap_SessionID___str__), -1);
  SwigClassSessionID.mark = 0;
  SwigClassSessionID.destroy = (void (*)(void *)) free_FIX_SessionID;
  SwigClassSessionID.trackObjects = 0;
  
  SwigClassDictionary.klass = rb_define_class_under(mQuickfix, "Dictionary", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Dictionary, (void *) &SwigClassDictionary);
  rb_define_alloc_func(SwigClassDictionary.klass, _wrap_Dictionary_allocate);
  rb_define_method(SwigClassDictionary.klass, "initialize", VALUEFUNC(_wrap_new_Dictionary), -1);
  rb_define_method(SwigClassDictionary.klass, "getName", VALUEFUNC(_wrap_Dictionary_getName), -1);
  rb_define_method(SwigClassDictionary.klass, "size", VALUEFUNC(_wrap_Dictionary_size), -1);
  rb_define_method(SwigClassDictionary.klass, "getString", VALUEFUNC(_wrap_Dictionary_getString), -1);
  rb_define_method(SwigClassDictionary.klass, "getInt", VALUEFUNC(_wrap_Dictionary_getInt), -1);
  rb_define_method(SwigClassDictionary.klass, "getDouble", VALUEFUNC(_wrap_Dictionary_getDouble), -1);
  rb_define_method(SwigClassDictionary.klass, "getBool", VALUEFUNC(_wrap_Dictionary_getBool), -1);
  rb_define_method(SwigClassDictionary.klass, "getDay", VALUEFUNC(_wrap_Dictionary_getDay), -1);
  rb_define_method(SwigClassDictionary.klass, "setString", VALUEFUNC(_wrap_Dictionary_setString), -1);
  rb_define_method(SwigClassDictionary.klass, "setInt", VALUEFUNC(_wrap_Dictionary_setInt), -1);
  rb_define_method(SwigClassDictionary.klass, "setDouble", VALUEFUNC(_wrap_Dictionary_setDouble), -1);
  rb_define_method(SwigClassDictionary.klass, "setBool", VALUEFUNC(_wrap_Dictionary_setBool), -1);
  rb_define_method(SwigClassDictionary.klass, "setDay", VALUEFUNC(_wrap_Dictionary_setDay), -1);
  rb_define_method(SwigClassDictionary.klass, "has", VALUEFUNC(_wrap_Dictionary_has), -1);
  rb_define_method(SwigClassDictionary.klass, "merge", VALUEFUNC(_wrap_Dictionary_merge), -1);
  rb_define_method(SwigClassDictionary.klass, "begin", VALUEFUNC(_wrap_Dictionary_begin), -1);
  rb_define_method(SwigClassDictionary.klass, "end", VALUEFUNC(_wrap_Dictionary_end), -1);
  SwigClassDictionary.mark = 0;
  SwigClassDictionary.destroy = (void (*)(void *)) free_FIX_Dictionary;
  SwigClassDictionary.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "BEGINSTRING", VALUEFUNC(_wrap_BEGINSTRING_get), 0);
  rb_define_singleton_method(mQuickfix, "SENDERCOMPID", VALUEFUNC(_wrap_SENDERCOMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "TARGETCOMPID", VALUEFUNC(_wrap_TARGETCOMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "SESSION_QUALIFIER", VALUEFUNC(_wrap_SESSION_QUALIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "DEFAULT_APPLVERID", VALUEFUNC(_wrap_DEFAULT_APPLVERID_get), 0);
  rb_define_singleton_method(mQuickfix, "CONNECTION_TYPE", VALUEFUNC(_wrap_CONNECTION_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "USE_DATA_DICTIONARY", VALUEFUNC(_wrap_USE_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "SEND_RESETSEQNUMFLAG", VALUEFUNC(_wrap_SEND_RESETSEQNUMFLAG_get), 0);
  rb_define_singleton_method(mQuickfix, "SEND_REDUNDANT_RESENDREQUESTS", VALUEFUNC(_wrap_SEND_REDUNDANT_RESENDREQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "DATA_DICTIONARY", VALUEFUNC(_wrap_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "TRANSPORT_DATA_DICTIONARY", VALUEFUNC(_wrap_TRANSPORT_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "APP_DATA_DICTIONARY", VALUEFUNC(_wrap_APP_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "USE_LOCAL_TIME", VALUEFUNC(_wrap_USE_LOCAL_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "START_TIME", VALUEFUNC(_wrap_START_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "END_TIME", VALUEFUNC(_wrap_END_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "START_DAY", VALUEFUNC(_wrap_START_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "END_DAY", VALUEFUNC(_wrap_END_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGON_TIME", VALUEFUNC(_wrap_LOGON_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGOUT_TIME", VALUEFUNC(_wrap_LOGOUT_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGON_DAY", VALUEFUNC(_wrap_LOGON_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGOUT_DAY", VALUEFUNC(_wrap_LOGOUT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "CHECK_COMPID", VALUEFUNC(_wrap_CHECK_COMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "CHECK_LATENCY", VALUEFUNC(_wrap_CHECK_LATENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "MAX_LATENCY", VALUEFUNC(_wrap_MAX_LATENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "HEARTBTINT", VALUEFUNC(_wrap_HEARTBTINT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_ACCEPT_PORT", VALUEFUNC(_wrap_SOCKET_ACCEPT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_REUSE_ADDRESS", VALUEFUNC(_wrap_SOCKET_REUSE_ADDRESS_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_HOST", VALUEFUNC(_wrap_SOCKET_CONNECT_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_PORT", VALUEFUNC(_wrap_SOCKET_CONNECT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_SOURCE_HOST", VALUEFUNC(_wrap_SOCKET_CONNECT_SOURCE_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_SOURCE_PORT", VALUEFUNC(_wrap_SOCKET_CONNECT_SOURCE_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_NODELAY", VALUEFUNC(_wrap_SOCKET_NODELAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_SEND_BUFFER_SIZE", VALUEFUNC(_wrap_SOCKET_SEND_BUFFER_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_RECEIVE_BUFFER_SIZE", VALUEFUNC(_wrap_SOCKET_RECEIVE_BUFFER_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "RECONNECT_INTERVAL", VALUEFUNC(_wrap_RECONNECT_INTERVAL_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_LENGTH_AND_CHECKSUM", VALUEFUNC(_wrap_VALIDATE_LENGTH_AND_CHECKSUM_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_FIELDS_OUT_OF_ORDER", VALUEFUNC(_wrap_VALIDATE_FIELDS_OUT_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_FIELDS_HAVE_VALUES", VALUEFUNC(_wrap_VALIDATE_FIELDS_HAVE_VALUES_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_USER_DEFINED_FIELDS", VALUEFUNC(_wrap_VALIDATE_USER_DEFINED_FIELDS_get), 0);
  rb_define_singleton_method(mQuickfix, "ALLOW_UNKNOWN_MSG_FIELDS", VALUEFUNC(_wrap_ALLOW_UNKNOWN_MSG_FIELDS_get), 0);
  rb_define_singleton_method(mQuickfix, "PRESERVE_MESSAGE_FIELDS_ORDER", VALUEFUNC(_wrap_PRESERVE_MESSAGE_FIELDS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGON_TIMEOUT", VALUEFUNC(_wrap_LOGON_TIMEOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGOUT_TIMEOUT", VALUEFUNC(_wrap_LOGOUT_TIMEOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "FILE_STORE_PATH", VALUEFUNC(_wrap_FILE_STORE_PATH_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_USECONNECTIONPOOL", VALUEFUNC(_wrap_MYSQL_STORE_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_DATABASE", VALUEFUNC(_wrap_MYSQL_STORE_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_USER", VALUEFUNC(_wrap_MYSQL_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_PASSWORD", VALUEFUNC(_wrap_MYSQL_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_HOST", VALUEFUNC(_wrap_MYSQL_STORE_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_PORT", VALUEFUNC(_wrap_MYSQL_STORE_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_USECONNECTIONPOOL", VALUEFUNC(_wrap_POSTGRESQL_STORE_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_DATABASE", VALUEFUNC(_wrap_POSTGRESQL_STORE_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_USER", VALUEFUNC(_wrap_POSTGRESQL_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_PASSWORD", VALUEFUNC(_wrap_POSTGRESQL_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_HOST", VALUEFUNC(_wrap_POSTGRESQL_STORE_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_PORT", VALUEFUNC(_wrap_POSTGRESQL_STORE_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_USER", VALUEFUNC(_wrap_ODBC_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_PASSWORD", VALUEFUNC(_wrap_ODBC_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_CONNECTION_STRING", VALUEFUNC(_wrap_ODBC_STORE_CONNECTION_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "FILE_LOG_PATH", VALUEFUNC(_wrap_FILE_LOG_PATH_get), 0);
  rb_define_singleton_method(mQuickfix, "FILE_LOG_BACKUP_PATH", VALUEFUNC(_wrap_FILE_LOG_BACKUP_PATH_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_INCOMING", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_INCOMING_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_OUTGOING", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_OUTGOING_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_EVENTS", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_EVENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_USECONNECTIONPOOL", VALUEFUNC(_wrap_MYSQL_LOG_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_DATABASE", VALUEFUNC(_wrap_MYSQL_LOG_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_USER", VALUEFUNC(_wrap_MYSQL_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_PASSWORD", VALUEFUNC(_wrap_MYSQL_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_HOST", VALUEFUNC(_wrap_MYSQL_LOG_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_PORT", VALUEFUNC(_wrap_MYSQL_LOG_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_INCOMING_TABLE", VALUEFUNC(_wrap_MYSQL_LOG_INCOMING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_OUTGOING_TABLE", VALUEFUNC(_wrap_MYSQL_LOG_OUTGOING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_EVENT_TABLE", VALUEFUNC(_wrap_MYSQL_LOG_EVENT_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_USECONNECTIONPOOL", VALUEFUNC(_wrap_POSTGRESQL_LOG_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_DATABASE", VALUEFUNC(_wrap_POSTGRESQL_LOG_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_USER", VALUEFUNC(_wrap_POSTGRESQL_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_PASSWORD", VALUEFUNC(_wrap_POSTGRESQL_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_HOST", VALUEFUNC(_wrap_POSTGRESQL_LOG_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_PORT", VALUEFUNC(_wrap_POSTGRESQL_LOG_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_INCOMING_TABLE", VALUEFUNC(_wrap_POSTGRESQL_LOG_INCOMING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_OUTGOING_TABLE", VALUEFUNC(_wrap_POSTGRESQL_LOG_OUTGOING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_EVENT_TABLE", VALUEFUNC(_wrap_POSTGRESQL_LOG_EVENT_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_USER", VALUEFUNC(_wrap_ODBC_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_PASSWORD", VALUEFUNC(_wrap_ODBC_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_CONNECTION_STRING", VALUEFUNC(_wrap_ODBC_LOG_CONNECTION_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_INCOMING_TABLE", VALUEFUNC(_wrap_ODBC_LOG_INCOMING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_OUTGOING_TABLE", VALUEFUNC(_wrap_ODBC_LOG_OUTGOING_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_EVENT_TABLE", VALUEFUNC(_wrap_ODBC_LOG_EVENT_TABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_LOGON", VALUEFUNC(_wrap_RESET_ON_LOGON_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_LOGOUT", VALUEFUNC(_wrap_RESET_ON_LOGOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_DISCONNECT", VALUEFUNC(_wrap_RESET_ON_DISCONNECT_get), 0);
  rb_define_singleton_method(mQuickfix, "REFRESH_ON_LOGON", VALUEFUNC(_wrap_REFRESH_ON_LOGON_get), 0);
  rb_define_singleton_method(mQuickfix, "MILLISECONDS_IN_TIMESTAMP", VALUEFUNC(_wrap_MILLISECONDS_IN_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "TIMESTAMP_PRECISION", VALUEFUNC(_wrap_TIMESTAMP_PRECISION_get), 0);
  rb_define_singleton_method(mQuickfix, "HTTP_ACCEPT_PORT", VALUEFUNC(_wrap_HTTP_ACCEPT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "PERSIST_MESSAGES", VALUEFUNC(_wrap_PERSIST_MESSAGES_get), 0);
  rb_define_singleton_method(mQuickfix, "SERVER_CERTIFICATE_FILE", VALUEFUNC(_wrap_SERVER_CERTIFICATE_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "SERVER_CERTIFICATE_KEY_FILE", VALUEFUNC(_wrap_SERVER_CERTIFICATE_KEY_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "CLIENT_CERTIFICATE_FILE", VALUEFUNC(_wrap_CLIENT_CERTIFICATE_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "CLIENT_CERTIFICATE_KEY_FILE", VALUEFUNC(_wrap_CLIENT_CERTIFICATE_KEY_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "CERTIFICATE_AUTHORITIES_FILE", VALUEFUNC(_wrap_CERTIFICATE_AUTHORITIES_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "CERTIFICATE_AUTHORITIES_DIRECTORY", VALUEFUNC(_wrap_CERTIFICATE_AUTHORITIES_DIRECTORY_get), 0);
  rb_define_singleton_method(mQuickfix, "CERTIFICATE_REVOCATION_LIST_FILE", VALUEFUNC(_wrap_CERTIFICATE_REVOCATION_LIST_FILE_get), 0);
  rb_define_singleton_method(mQuickfix, "CERTIFICATE_REVOCATION_LIST_DIRECTORY", VALUEFUNC(_wrap_CERTIFICATE_REVOCATION_LIST_DIRECTORY_get), 0);
  rb_define_singleton_method(mQuickfix, "CERTIFICATE_VERIFY_LEVEL", VALUEFUNC(_wrap_CERTIFICATE_VERIFY_LEVEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SSL_PROTOCOL", VALUEFUNC(_wrap_SSL_PROTOCOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SSL_CIPHER_SUITE", VALUEFUNC(_wrap_SSL_CIPHER_SUITE_get), 0);
  
  SwigClassSessionSettings.klass = rb_define_class_under(mQuickfix, "SessionSettings", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionSettings, (void *) &SwigClassSessionSettings);
  rb_define_alloc_func(SwigClassSessionSettings.klass, _wrap_SessionSettings_allocate);
  rb_define_method(SwigClassSessionSettings.klass, "initialize", VALUEFUNC(_wrap_new_SessionSettings), -1);
  rb_define_method(SwigClassSessionSettings.klass, "has", VALUEFUNC(_wrap_SessionSettings_has), -1);
  rb_define_method(SwigClassSessionSettings.klass, "get", VALUEFUNC(_wrap_SessionSettings_get), -1);
  rb_define_method(SwigClassSessionSettings.klass, "set", VALUEFUNC(_wrap_SessionSettings_set), -1);
  rb_define_method(SwigClassSessionSettings.klass, "size", VALUEFUNC(_wrap_SessionSettings_size), -1);
  rb_define_method(SwigClassSessionSettings.klass, "getSessions", VALUEFUNC(_wrap_SessionSettings_getSessions), -1);
  rb_define_method(SwigClassSessionSettings.klass, "setFromString", VALUEFUNC(_wrap_SessionSettings_setFromString), -1);
  SwigClassSessionSettings.mark = 0;
  SwigClassSessionSettings.destroy = (void (*)(void *)) free_FIX_SessionSettings;
  SwigClassSessionSettings.trackObjects = 0;
  rb_define_module_function(mQuickfix, ">>", VALUEFUNC(_wrap___rshift__), -1);
  rb_define_module_function(mQuickfix, "<<", VALUEFUNC(_wrap___lshift__), -1);
  
  SwigClassSession.klass = rb_define_class_under(mQuickfix, "Session", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Session, (void *) &SwigClassSession);
  rb_define_alloc_func(SwigClassSession.klass, _wrap_Session_allocate);
  rb_define_method(SwigClassSession.klass, "initialize", VALUEFUNC(_wrap_new_Session), -1);
  rb_define_method(SwigClassSession.klass, "logon", VALUEFUNC(_wrap_Session_logon), -1);
  rb_define_method(SwigClassSession.klass, "logout", VALUEFUNC(_wrap_Session_logout), -1);
  rb_define_method(SwigClassSession.klass, "isEnabled", VALUEFUNC(_wrap_Session_isEnabled), -1);
  rb_define_method(SwigClassSession.klass, "sentLogon", VALUEFUNC(_wrap_Session_sentLogon), -1);
  rb_define_method(SwigClassSession.klass, "sentLogout", VALUEFUNC(_wrap_Session_sentLogout), -1);
  rb_define_method(SwigClassSession.klass, "receivedLogon", VALUEFUNC(_wrap_Session_receivedLogon), -1);
  rb_define_method(SwigClassSession.klass, "isLoggedOn", VALUEFUNC(_wrap_Session_isLoggedOn), -1);
  rb_define_method(SwigClassSession.klass, "reset", VALUEFUNC(_wrap_Session_reset), -1);
  rb_define_method(SwigClassSession.klass, "refresh", VALUEFUNC(_wrap_Session_refresh), -1);
  rb_define_method(SwigClassSession.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_Session_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassSession.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_Session_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassSession.klass, "getSessionID", VALUEFUNC(_wrap_Session_getSessionID), -1);
  rb_define_method(SwigClassSession.klass, "setDataDictionaryProvider", VALUEFUNC(_wrap_Session_setDataDictionaryProvider), -1);
  rb_define_method(SwigClassSession.klass, "getDataDictionaryProvider", VALUEFUNC(_wrap_Session_getDataDictionaryProvider), -1);
  rb_define_singleton_method(SwigClassSession.klass, "sendToTarget", VALUEFUNC(_wrap_Session_sendToTarget), -1);
  rb_define_singleton_method(SwigClassSession.klass, "getSessions", VALUEFUNC(_wrap_Session_getSessions), -1);
  rb_define_singleton_method(SwigClassSession.klass, "doesSessionExist", VALUEFUNC(_wrap_Session_doesSessionExist), -1);
  rb_define_singleton_method(SwigClassSession.klass, "lookupSession", VALUEFUNC(_wrap_Session_lookupSession), -1);
  rb_define_singleton_method(SwigClassSession.klass, "isSessionRegistered", VALUEFUNC(_wrap_Session_isSessionRegistered), -1);
  rb_define_singleton_method(SwigClassSession.klass, "registerSession", VALUEFUNC(_wrap_Session_registerSession), -1);
  rb_define_singleton_method(SwigClassSession.klass, "unregisterSession", VALUEFUNC(_wrap_Session_unregisterSession), -1);
  rb_define_singleton_method(SwigClassSession.klass, "numSessions", VALUEFUNC(_wrap_Session_numSessions), -1);
  rb_define_method(SwigClassSession.klass, "isSessionTime", VALUEFUNC(_wrap_Session_isSessionTime), -1);
  rb_define_method(SwigClassSession.klass, "isLogonTime", VALUEFUNC(_wrap_Session_isLogonTime), -1);
  rb_define_method(SwigClassSession.klass, "isInitiator", VALUEFUNC(_wrap_Session_isInitiator), -1);
  rb_define_method(SwigClassSession.klass, "isAcceptor", VALUEFUNC(_wrap_Session_isAcceptor), -1);
  rb_define_method(SwigClassSession.klass, "getLogonTime", VALUEFUNC(_wrap_Session_getLogonTime), -1);
  rb_define_method(SwigClassSession.klass, "setLogonTime", VALUEFUNC(_wrap_Session_setLogonTime), -1);
  rb_define_method(SwigClassSession.klass, "getSenderDefaultApplVerID", VALUEFUNC(_wrap_Session_getSenderDefaultApplVerID), -1);
  rb_define_method(SwigClassSession.klass, "setSenderDefaultApplVerID", VALUEFUNC(_wrap_Session_setSenderDefaultApplVerID), -1);
  rb_define_method(SwigClassSession.klass, "getTargetDefaultApplVerID", VALUEFUNC(_wrap_Session_getTargetDefaultApplVerID), -1);
  rb_define_method(SwigClassSession.klass, "setTargetDefaultApplVerID", VALUEFUNC(_wrap_Session_setTargetDefaultApplVerID), -1);
  rb_define_method(SwigClassSession.klass, "getSendRedundantResendRequests", VALUEFUNC(_wrap_Session_getSendRedundantResendRequests), -1);
  rb_define_method(SwigClassSession.klass, "setSendRedundantResendRequests", VALUEFUNC(_wrap_Session_setSendRedundantResendRequests), -1);
  rb_define_method(SwigClassSession.klass, "getCheckCompId", VALUEFUNC(_wrap_Session_getCheckCompId), -1);
  rb_define_method(SwigClassSession.klass, "setCheckCompId", VALUEFUNC(_wrap_Session_setCheckCompId), -1);
  rb_define_method(SwigClassSession.klass, "getCheckLatency", VALUEFUNC(_wrap_Session_getCheckLatency), -1);
  rb_define_method(SwigClassSession.klass, "setCheckLatency", VALUEFUNC(_wrap_Session_setCheckLatency), -1);
  rb_define_method(SwigClassSession.klass, "getMaxLatency", VALUEFUNC(_wrap_Session_getMaxLatency), -1);
  rb_define_method(SwigClassSession.klass, "setMaxLatency", VALUEFUNC(_wrap_Session_setMaxLatency), -1);
  rb_define_method(SwigClassSession.klass, "getLogonTimeout", VALUEFUNC(_wrap_Session_getLogonTimeout), -1);
  rb_define_method(SwigClassSession.klass, "setLogonTimeout", VALUEFUNC(_wrap_Session_setLogonTimeout), -1);
  rb_define_method(SwigClassSession.klass, "getLogoutTimeout", VALUEFUNC(_wrap_Session_getLogoutTimeout), -1);
  rb_define_method(SwigClassSession.klass, "setLogoutTimeout", VALUEFUNC(_wrap_Session_setLogoutTimeout), -1);
  rb_define_method(SwigClassSession.klass, "getResetOnLogon", VALUEFUNC(_wrap_Session_getResetOnLogon), -1);
  rb_define_method(SwigClassSession.klass, "setResetOnLogon", VALUEFUNC(_wrap_Session_setResetOnLogon), -1);
  rb_define_method(SwigClassSession.klass, "getResetOnLogout", VALUEFUNC(_wrap_Session_getResetOnLogout), -1);
  rb_define_method(SwigClassSession.klass, "setResetOnLogout", VALUEFUNC(_wrap_Session_setResetOnLogout), -1);
  rb_define_method(SwigClassSession.klass, "getResetOnDisconnect", VALUEFUNC(_wrap_Session_getResetOnDisconnect), -1);
  rb_define_method(SwigClassSession.klass, "setResetOnDisconnect", VALUEFUNC(_wrap_Session_setResetOnDisconnect), -1);
  rb_define_method(SwigClassSession.klass, "getRefreshOnLogon", VALUEFUNC(_wrap_Session_getRefreshOnLogon), -1);
  rb_define_method(SwigClassSession.klass, "setRefreshOnLogon", VALUEFUNC(_wrap_Session_setRefreshOnLogon), -1);
  rb_define_method(SwigClassSession.klass, "getMillisecondsInTimeStamp", VALUEFUNC(_wrap_Session_getMillisecondsInTimeStamp), -1);
  rb_define_method(SwigClassSession.klass, "setMillisecondsInTimeStamp", VALUEFUNC(_wrap_Session_setMillisecondsInTimeStamp), -1);
  rb_define_method(SwigClassSession.klass, "getTimestampPrecision", VALUEFUNC(_wrap_Session_getTimestampPrecision), -1);
  rb_define_method(SwigClassSession.klass, "setTimestampPrecision", VALUEFUNC(_wrap_Session_setTimestampPrecision), -1);
  rb_define_method(SwigClassSession.klass, "getSupportedTimestampPrecision", VALUEFUNC(_wrap_Session_getSupportedTimestampPrecision), -1);
  rb_define_singleton_method(SwigClassSession.klass, "supportsSubSecondTimestamps", VALUEFUNC(_wrap_Session_supportsSubSecondTimestamps), -1);
  rb_define_method(SwigClassSession.klass, "getPersistMessages", VALUEFUNC(_wrap_Session_getPersistMessages), -1);
  rb_define_method(SwigClassSession.klass, "setPersistMessages", VALUEFUNC(_wrap_Session_setPersistMessages), -1);
  rb_define_method(SwigClassSession.klass, "getValidateLengthAndChecksum", VALUEFUNC(_wrap_Session_getValidateLengthAndChecksum), -1);
  rb_define_method(SwigClassSession.klass, "setValidateLengthAndChecksum", VALUEFUNC(_wrap_Session_setValidateLengthAndChecksum), -1);
  rb_define_method(SwigClassSession.klass, "setResponder", VALUEFUNC(_wrap_Session_setResponder), -1);
  rb_define_method(SwigClassSession.klass, "send", VALUEFUNC(_wrap_Session_send), -1);
  rb_define_method(SwigClassSession.klass, "next", VALUEFUNC(_wrap_Session_next), -1);
  rb_define_method(SwigClassSession.klass, "disconnect", VALUEFUNC(_wrap_Session_disconnect), -1);
  rb_define_method(SwigClassSession.klass, "getExpectedSenderNum", VALUEFUNC(_wrap_Session_getExpectedSenderNum), -1);
  rb_define_method(SwigClassSession.klass, "getExpectedTargetNum", VALUEFUNC(_wrap_Session_getExpectedTargetNum), -1);
  rb_define_method(SwigClassSession.klass, "getLog", VALUEFUNC(_wrap_Session_getLog), -1);
  rb_define_method(SwigClassSession.klass, "getStore", VALUEFUNC(_wrap_Session_getStore), -1);
  SwigClassSession.mark = 0;
  SwigClassSession.destroy = (void (*)(void *)) free_FIX_Session;
  SwigClassSession.trackObjects = 0;
  
  SwigClassLogFactory.klass = rb_define_class_under(mQuickfix, "LogFactory", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LogFactory, (void *) &SwigClassLogFactory);
  rb_undef_alloc_func(SwigClassLogFactory.klass);
  rb_define_method(SwigClassLogFactory.klass, "create", VALUEFUNC(_wrap_LogFactory_create), -1);
  rb_define_method(SwigClassLogFactory.klass, "destroy", VALUEFUNC(_wrap_LogFactory_destroy), -1);
  SwigClassLogFactory.mark = 0;
  SwigClassLogFactory.destroy = (void (*)(void *)) free_FIX_LogFactory;
  SwigClassLogFactory.trackObjects = 0;
  
  SwigClassScreenLogFactory.klass = rb_define_class_under(mQuickfix, "ScreenLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ScreenLogFactory, (void *) &SwigClassScreenLogFactory);
  rb_define_alloc_func(SwigClassScreenLogFactory.klass, _wrap_ScreenLogFactory_allocate);
  rb_define_method(SwigClassScreenLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_ScreenLogFactory), -1);
  rb_define_method(SwigClassScreenLogFactory.klass, "create", VALUEFUNC(_wrap_ScreenLogFactory_create), -1);
  rb_define_method(SwigClassScreenLogFactory.klass, "destroy", VALUEFUNC(_wrap_ScreenLogFactory_destroy), -1);
  SwigClassScreenLogFactory.mark = 0;
  SwigClassScreenLogFactory.destroy = (void (*)(void *)) free_FIX_ScreenLogFactory;
  SwigClassScreenLogFactory.trackObjects = 0;
  
  SwigClassLog.klass = rb_define_class_under(mQuickfix, "Log", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Log, (void *) &SwigClassLog);
  rb_undef_alloc_func(SwigClassLog.klass);
  rb_define_method(SwigClassLog.klass, "clear", VALUEFUNC(_wrap_Log_clear), -1);
  rb_define_method(SwigClassLog.klass, "backup", VALUEFUNC(_wrap_Log_backup), -1);
  rb_define_method(SwigClassLog.klass, "onIncoming", VALUEFUNC(_wrap_Log_onIncoming), -1);
  rb_define_method(SwigClassLog.klass, "onOutgoing", VALUEFUNC(_wrap_Log_onOutgoing), -1);
  rb_define_method(SwigClassLog.klass, "onEvent", VALUEFUNC(_wrap_Log_onEvent), -1);
  SwigClassLog.mark = 0;
  SwigClassLog.destroy = (void (*)(void *)) free_FIX_Log;
  SwigClassLog.trackObjects = 0;
  
  SwigClassNullLog.klass = rb_define_class_under(mQuickfix, "NullLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__NullLog, (void *) &SwigClassNullLog);
  rb_define_alloc_func(SwigClassNullLog.klass, _wrap_NullLog_allocate);
  rb_define_method(SwigClassNullLog.klass, "initialize", VALUEFUNC(_wrap_new_NullLog), -1);
  rb_define_method(SwigClassNullLog.klass, "clear", VALUEFUNC(_wrap_NullLog_clear), -1);
  rb_define_method(SwigClassNullLog.klass, "backup", VALUEFUNC(_wrap_NullLog_backup), -1);
  rb_define_method(SwigClassNullLog.klass, "onIncoming", VALUEFUNC(_wrap_NullLog_onIncoming), -1);
  rb_define_method(SwigClassNullLog.klass, "onOutgoing", VALUEFUNC(_wrap_NullLog_onOutgoing), -1);
  rb_define_method(SwigClassNullLog.klass, "onEvent", VALUEFUNC(_wrap_NullLog_onEvent), -1);
  SwigClassNullLog.mark = 0;
  SwigClassNullLog.destroy = (void (*)(void *)) free_FIX_NullLog;
  SwigClassNullLog.trackObjects = 0;
  
  SwigClassScreenLog.klass = rb_define_class_under(mQuickfix, "ScreenLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ScreenLog, (void *) &SwigClassScreenLog);
  rb_define_alloc_func(SwigClassScreenLog.klass, _wrap_ScreenLog_allocate);
  rb_define_method(SwigClassScreenLog.klass, "initialize", VALUEFUNC(_wrap_new_ScreenLog), -1);
  rb_define_method(SwigClassScreenLog.klass, "clear", VALUEFUNC(_wrap_ScreenLog_clear), -1);
  rb_define_method(SwigClassScreenLog.klass, "backup", VALUEFUNC(_wrap_ScreenLog_backup), -1);
  rb_define_method(SwigClassScreenLog.klass, "onIncoming", VALUEFUNC(_wrap_ScreenLog_onIncoming), -1);
  rb_define_method(SwigClassScreenLog.klass, "onOutgoing", VALUEFUNC(_wrap_ScreenLog_onOutgoing), -1);
  rb_define_method(SwigClassScreenLog.klass, "onEvent", VALUEFUNC(_wrap_ScreenLog_onEvent), -1);
  SwigClassScreenLog.mark = 0;
  SwigClassScreenLog.destroy = (void (*)(void *)) free_FIX_ScreenLog;
  SwigClassScreenLog.trackObjects = 0;
  
  SwigClassFileLogFactory.klass = rb_define_class_under(mQuickfix, "FileLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileLogFactory, (void *) &SwigClassFileLogFactory);
  rb_define_alloc_func(SwigClassFileLogFactory.klass, _wrap_FileLogFactory_allocate);
  rb_define_method(SwigClassFileLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_FileLogFactory), -1);
  rb_define_method(SwigClassFileLogFactory.klass, "create", VALUEFUNC(_wrap_FileLogFactory_create), -1);
  rb_define_method(SwigClassFileLogFactory.klass, "destroy", VALUEFUNC(_wrap_FileLogFactory_destroy), -1);
  SwigClassFileLogFactory.mark = 0;
  SwigClassFileLogFactory.destroy = (void (*)(void *)) free_FIX_FileLogFactory;
  SwigClassFileLogFactory.trackObjects = 0;
  
  SwigClassFileLog.klass = rb_define_class_under(mQuickfix, "FileLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileLog, (void *) &SwigClassFileLog);
  rb_define_alloc_func(SwigClassFileLog.klass, _wrap_FileLog_allocate);
  rb_define_method(SwigClassFileLog.klass, "initialize", VALUEFUNC(_wrap_new_FileLog), -1);
  rb_define_method(SwigClassFileLog.klass, "clear", VALUEFUNC(_wrap_FileLog_clear), -1);
  rb_define_method(SwigClassFileLog.klass, "backup", VALUEFUNC(_wrap_FileLog_backup), -1);
  rb_define_method(SwigClassFileLog.klass, "onIncoming", VALUEFUNC(_wrap_FileLog_onIncoming), -1);
  rb_define_method(SwigClassFileLog.klass, "onOutgoing", VALUEFUNC(_wrap_FileLog_onOutgoing), -1);
  rb_define_method(SwigClassFileLog.klass, "onEvent", VALUEFUNC(_wrap_FileLog_onEvent), -1);
  SwigClassFileLog.mark = 0;
  SwigClassFileLog.destroy = (void (*)(void *)) free_FIX_FileLog;
  SwigClassFileLog.trackObjects = 0;
  
  SwigClassMessageStoreFactory.klass = rb_define_class_under(mQuickfix, "MessageStoreFactory", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreFactory, (void *) &SwigClassMessageStoreFactory);
  rb_undef_alloc_func(SwigClassMessageStoreFactory.klass);
  rb_define_method(SwigClassMessageStoreFactory.klass, "create", VALUEFUNC(_wrap_MessageStoreFactory_create), -1);
  rb_define_method(SwigClassMessageStoreFactory.klass, "destroy", VALUEFUNC(_wrap_MessageStoreFactory_destroy), -1);
  SwigClassMessageStoreFactory.mark = 0;
  SwigClassMessageStoreFactory.destroy = (void (*)(void *)) free_FIX_MessageStoreFactory;
  SwigClassMessageStoreFactory.trackObjects = 0;
  
  SwigClassMemoryStoreFactory.klass = rb_define_class_under(mQuickfix, "MemoryStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MemoryStoreFactory, (void *) &SwigClassMemoryStoreFactory);
  rb_define_alloc_func(SwigClassMemoryStoreFactory.klass, _wrap_MemoryStoreFactory_allocate);
  rb_define_method(SwigClassMemoryStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_MemoryStoreFactory), -1);
  rb_define_method(SwigClassMemoryStoreFactory.klass, "create", VALUEFUNC(_wrap_MemoryStoreFactory_create), -1);
  rb_define_method(SwigClassMemoryStoreFactory.klass, "destroy", VALUEFUNC(_wrap_MemoryStoreFactory_destroy), -1);
  SwigClassMemoryStoreFactory.mark = 0;
  SwigClassMemoryStoreFactory.destroy = (void (*)(void *)) free_FIX_MemoryStoreFactory;
  SwigClassMemoryStoreFactory.trackObjects = 0;
  
  SwigClassMessageStore.klass = rb_define_class_under(mQuickfix, "MessageStore", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStore, (void *) &SwigClassMessageStore);
  rb_undef_alloc_func(SwigClassMessageStore.klass);
  rb_define_method(SwigClassMessageStore.klass, "set", VALUEFUNC(_wrap_MessageStore_set), -1);
  rb_define_method(SwigClassMessageStore.klass, "get", VALUEFUNC(_wrap_MessageStore_get), -1);
  rb_define_method(SwigClassMessageStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStore.klass, "getCreationTime", VALUEFUNC(_wrap_MessageStore_getCreationTime), -1);
  rb_define_method(SwigClassMessageStore.klass, "reset", VALUEFUNC(_wrap_MessageStore_reset), -1);
  rb_define_method(SwigClassMessageStore.klass, "refresh", VALUEFUNC(_wrap_MessageStore_refresh), -1);
  SwigClassMessageStore.mark = 0;
  SwigClassMessageStore.destroy = (void (*)(void *)) free_FIX_MessageStore;
  SwigClassMessageStore.trackObjects = 0;
  
  SwigClassMemoryStore.klass = rb_define_class_under(mQuickfix, "MemoryStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MemoryStore, (void *) &SwigClassMemoryStore);
  rb_define_alloc_func(SwigClassMemoryStore.klass, _wrap_MemoryStore_allocate);
  rb_define_method(SwigClassMemoryStore.klass, "initialize", VALUEFUNC(_wrap_new_MemoryStore), -1);
  rb_define_method(SwigClassMemoryStore.klass, "set", VALUEFUNC(_wrap_MemoryStore_set), -1);
  rb_define_method(SwigClassMemoryStore.klass, "get", VALUEFUNC(_wrap_MemoryStore_get), -1);
  rb_define_method(SwigClassMemoryStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMemoryStore.klass, "setCreationTime", VALUEFUNC(_wrap_MemoryStore_setCreationTime), -1);
  rb_define_method(SwigClassMemoryStore.klass, "getCreationTime", VALUEFUNC(_wrap_MemoryStore_getCreationTime), -1);
  rb_define_method(SwigClassMemoryStore.klass, "reset", VALUEFUNC(_wrap_MemoryStore_reset), -1);
  rb_define_method(SwigClassMemoryStore.klass, "refresh", VALUEFUNC(_wrap_MemoryStore_refresh), -1);
  SwigClassMemoryStore.mark = 0;
  SwigClassMemoryStore.destroy = (void (*)(void *)) free_FIX_MemoryStore;
  SwigClassMemoryStore.trackObjects = 0;
  
  SwigClassMessageStoreFactoryExceptionWrapper.klass = rb_define_class_under(mQuickfix, "MessageStoreFactoryExceptionWrapper", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, (void *) &SwigClassMessageStoreFactoryExceptionWrapper);
  rb_define_alloc_func(SwigClassMessageStoreFactoryExceptionWrapper.klass, _wrap_MessageStoreFactoryExceptionWrapper_allocate);
  rb_define_method(SwigClassMessageStoreFactoryExceptionWrapper.klass, "initialize", VALUEFUNC(_wrap_new_MessageStoreFactoryExceptionWrapper), -1);
  rb_define_method(SwigClassMessageStoreFactoryExceptionWrapper.klass, "create", VALUEFUNC(_wrap_MessageStoreFactoryExceptionWrapper_create), -1);
  rb_define_method(SwigClassMessageStoreFactoryExceptionWrapper.klass, "destroy", VALUEFUNC(_wrap_MessageStoreFactoryExceptionWrapper_destroy), -1);
  SwigClassMessageStoreFactoryExceptionWrapper.mark = 0;
  SwigClassMessageStoreFactoryExceptionWrapper.destroy = (void (*)(void *)) free_FIX_MessageStoreFactoryExceptionWrapper;
  SwigClassMessageStoreFactoryExceptionWrapper.trackObjects = 0;
  
  SwigClassMessageStoreExceptionWrapper.klass = rb_define_class_under(mQuickfix, "MessageStoreExceptionWrapper", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, (void *) &SwigClassMessageStoreExceptionWrapper);
  rb_define_alloc_func(SwigClassMessageStoreExceptionWrapper.klass, _wrap_MessageStoreExceptionWrapper_allocate);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "initialize", VALUEFUNC(_wrap_new_MessageStoreExceptionWrapper), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "set", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_set), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "get", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_get), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "getCreationTime", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getCreationTime), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "reset", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_reset), -1);
  rb_define_method(SwigClassMessageStoreExceptionWrapper.klass, "refresh", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_refresh), -1);
  SwigClassMessageStoreExceptionWrapper.mark = 0;
  SwigClassMessageStoreExceptionWrapper.destroy = (void (*)(void *)) free_FIX_MessageStoreExceptionWrapper;
  SwigClassMessageStoreExceptionWrapper.trackObjects = 0;
  
  SwigClassFileStoreFactory.klass = rb_define_class_under(mQuickfix, "FileStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileStoreFactory, (void *) &SwigClassFileStoreFactory);
  rb_define_alloc_func(SwigClassFileStoreFactory.klass, _wrap_FileStoreFactory_allocate);
  rb_define_method(SwigClassFileStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_FileStoreFactory), -1);
  rb_define_method(SwigClassFileStoreFactory.klass, "create", VALUEFUNC(_wrap_FileStoreFactory_create), -1);
  rb_define_method(SwigClassFileStoreFactory.klass, "destroy", VALUEFUNC(_wrap_FileStoreFactory_destroy), -1);
  SwigClassFileStoreFactory.mark = 0;
  SwigClassFileStoreFactory.destroy = (void (*)(void *)) free_FIX_FileStoreFactory;
  SwigClassFileStoreFactory.trackObjects = 0;
  
  SwigClassFileStore.klass = rb_define_class_under(mQuickfix, "FileStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileStore, (void *) &SwigClassFileStore);
  rb_define_alloc_func(SwigClassFileStore.klass, _wrap_FileStore_allocate);
  rb_define_method(SwigClassFileStore.klass, "initialize", VALUEFUNC(_wrap_new_FileStore), -1);
  rb_define_method(SwigClassFileStore.klass, "set", VALUEFUNC(_wrap_FileStore_set), -1);
  rb_define_method(SwigClassFileStore.klass, "get", VALUEFUNC(_wrap_FileStore_get), -1);
  rb_define_method(SwigClassFileStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassFileStore.klass, "getCreationTime", VALUEFUNC(_wrap_FileStore_getCreationTime), -1);
  rb_define_method(SwigClassFileStore.klass, "reset", VALUEFUNC(_wrap_FileStore_reset), -1);
  rb_define_method(SwigClassFileStore.klass, "refresh", VALUEFUNC(_wrap_FileStore_refresh), -1);
  SwigClassFileStore.mark = 0;
  SwigClassFileStore.destroy = (void (*)(void *)) free_FIX_FileStore;
  SwigClassFileStore.trackObjects = 0;
  rb_define_module_function(mQuickfix, "disown_Application", VALUEFUNC(_wrap_disown_Application), -1);
  
  SwigClassApplication.klass = rb_define_class_under(mQuickfix, "Application", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Application, (void *) &SwigClassApplication);
  rb_define_alloc_func(SwigClassApplication.klass, _wrap_Application_allocate);
  rb_define_method(SwigClassApplication.klass, "initialize", VALUEFUNC(_wrap_new_Application), -1);
  rb_define_method(SwigClassApplication.klass, "onCreate", VALUEFUNC(_wrap_Application_onCreate), -1);
  rb_define_method(SwigClassApplication.klass, "onLogon", VALUEFUNC(_wrap_Application_onLogon), -1);
  rb_define_method(SwigClassApplication.klass, "onLogout", VALUEFUNC(_wrap_Application_onLogout), -1);
  rb_define_method(SwigClassApplication.klass, "toAdmin", VALUEFUNC(_wrap_Application_toAdmin), -1);
  rb_define_method(SwigClassApplication.klass, "toApp", VALUEFUNC(_wrap_Application_toApp), -1);
  rb_define_method(SwigClassApplication.klass, "fromAdmin", VALUEFUNC(_wrap_Application_fromAdmin), -1);
  rb_define_method(SwigClassApplication.klass, "fromApp", VALUEFUNC(_wrap_Application_fromApp), -1);
  SwigClassApplication.mark = 0;
  SwigClassApplication.destroy = (void (*)(void *)) free_FIX_Application;
  SwigClassApplication.trackObjects = 0;
  
  SwigClassSynchronizedApplication.klass = rb_define_class_under(mQuickfix, "SynchronizedApplication", ((swig_class *) SWIGTYPE_p_FIX__Application->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SynchronizedApplication, (void *) &SwigClassSynchronizedApplication);
  rb_define_alloc_func(SwigClassSynchronizedApplication.klass, _wrap_SynchronizedApplication_allocate);
  rb_define_method(SwigClassSynchronizedApplication.klass, "initialize", VALUEFUNC(_wrap_new_SynchronizedApplication), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "onCreate", VALUEFUNC(_wrap_SynchronizedApplication_onCreate), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "onLogon", VALUEFUNC(_wrap_SynchronizedApplication_onLogon), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "onLogout", VALUEFUNC(_wrap_SynchronizedApplication_onLogout), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "toAdmin", VALUEFUNC(_wrap_SynchronizedApplication_toAdmin), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "toApp", VALUEFUNC(_wrap_SynchronizedApplication_toApp), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "fromAdmin", VALUEFUNC(_wrap_SynchronizedApplication_fromAdmin), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "fromApp", VALUEFUNC(_wrap_SynchronizedApplication_fromApp), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "m_mutex=", VALUEFUNC(_wrap_SynchronizedApplication_m_mutex_set), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "m_mutex", VALUEFUNC(_wrap_SynchronizedApplication_m_mutex_get), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "app", VALUEFUNC(_wrap_SynchronizedApplication_app), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "m_app=", VALUEFUNC(_wrap_SynchronizedApplication_m_app_set), -1);
  rb_define_method(SwigClassSynchronizedApplication.klass, "m_app", VALUEFUNC(_wrap_SynchronizedApplication_m_app_get), -1);
  SwigClassSynchronizedApplication.mark = 0;
  SwigClassSynchronizedApplication.destroy = (void (*)(void *)) free_FIX_SynchronizedApplication;
  SwigClassSynchronizedApplication.trackObjects = 0;
  
  SwigClassNullApplication.klass = rb_define_class_under(mQuickfix, "NullApplication", ((swig_class *) SWIGTYPE_p_FIX__Application->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__NullApplication, (void *) &SwigClassNullApplication);
  rb_define_alloc_func(SwigClassNullApplication.klass, _wrap_NullApplication_allocate);
  rb_define_method(SwigClassNullApplication.klass, "initialize", VALUEFUNC(_wrap_new_NullApplication), -1);
  SwigClassNullApplication.mark = 0;
  SwigClassNullApplication.destroy = (void (*)(void *)) free_FIX_NullApplication;
  SwigClassNullApplication.trackObjects = 0;
  
  SwigClassInitiator.klass = rb_define_class_under(mQuickfix, "Initiator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Initiator, (void *) &SwigClassInitiator);
  rb_undef_alloc_func(SwigClassInitiator.klass);
  rb_define_method(SwigClassInitiator.klass, "start", VALUEFUNC(_wrap_Initiator_start), -1);
  rb_define_method(SwigClassInitiator.klass, "block", VALUEFUNC(_wrap_Initiator_block), -1);
  rb_define_method(SwigClassInitiator.klass, "poll", VALUEFUNC(_wrap_Initiator_poll), -1);
  rb_define_method(SwigClassInitiator.klass, "stop", VALUEFUNC(_wrap_Initiator_stop), -1);
  rb_define_method(SwigClassInitiator.klass, "isLoggedOn", VALUEFUNC(_wrap_Initiator_isLoggedOn), -1);
  rb_define_method(SwigClassInitiator.klass, "getSessions", VALUEFUNC(_wrap_Initiator_getSessions), -1);
  rb_define_method(SwigClassInitiator.klass, "getSession", VALUEFUNC(_wrap_Initiator_getSession), -1);
  rb_define_method(SwigClassInitiator.klass, "getSessionSettings", VALUEFUNC(_wrap_Initiator_getSessionSettings), -1);
  rb_define_method(SwigClassInitiator.klass, "has", VALUEFUNC(_wrap_Initiator_has), -1);
  rb_define_method(SwigClassInitiator.klass, "isStopped", VALUEFUNC(_wrap_Initiator_isStopped), -1);
  rb_define_method(SwigClassInitiator.klass, "getApplication", VALUEFUNC(_wrap_Initiator_getApplication), -1);
  rb_define_method(SwigClassInitiator.klass, "getMessageStoreFactory", VALUEFUNC(_wrap_Initiator_getMessageStoreFactory), -1);
  rb_define_method(SwigClassInitiator.klass, "getLog", VALUEFUNC(_wrap_Initiator_getLog), -1);
  SwigClassInitiator.mark = 0;
  SwigClassInitiator.destroy = (void (*)(void *)) free_FIX_Initiator;
  SwigClassInitiator.trackObjects = 0;
  
  SwigClassSocketInitiatorBase.klass = rb_define_class_under(mQuickfix, "SocketInitiatorBase", ((swig_class *) SWIGTYPE_p_FIX__Initiator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketInitiator, (void *) &SwigClassSocketInitiatorBase);
  rb_define_alloc_func(SwigClassSocketInitiatorBase.klass, _wrap_SocketInitiatorBase_allocate);
  rb_define_method(SwigClassSocketInitiatorBase.klass, "initialize", VALUEFUNC(_wrap_new_SocketInitiatorBase), -1);
  SwigClassSocketInitiatorBase.mark = 0;
  SwigClassSocketInitiatorBase.destroy = (void (*)(void *)) free_FIX_SocketInitiator;
  SwigClassSocketInitiatorBase.trackObjects = 0;
  
  SwigClassAcceptor.klass = rb_define_class_under(mQuickfix, "Acceptor", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Acceptor, (void *) &SwigClassAcceptor);
  rb_undef_alloc_func(SwigClassAcceptor.klass);
  rb_define_method(SwigClassAcceptor.klass, "getLog", VALUEFUNC(_wrap_Acceptor_getLog), -1);
  rb_define_method(SwigClassAcceptor.klass, "start", VALUEFUNC(_wrap_Acceptor_start), -1);
  rb_define_method(SwigClassAcceptor.klass, "block", VALUEFUNC(_wrap_Acceptor_block), -1);
  rb_define_method(SwigClassAcceptor.klass, "poll", VALUEFUNC(_wrap_Acceptor_poll), -1);
  rb_define_method(SwigClassAcceptor.klass, "stop", VALUEFUNC(_wrap_Acceptor_stop), -1);
  rb_define_method(SwigClassAcceptor.klass, "isLoggedOn", VALUEFUNC(_wrap_Acceptor_isLoggedOn), -1);
  rb_define_method(SwigClassAcceptor.klass, "getSessions", VALUEFUNC(_wrap_Acceptor_getSessions), -1);
  rb_define_method(SwigClassAcceptor.klass, "getSession", VALUEFUNC(_wrap_Acceptor_getSession), -1);
  rb_define_method(SwigClassAcceptor.klass, "getSessionSettings", VALUEFUNC(_wrap_Acceptor_getSessionSettings), -1);
  rb_define_method(SwigClassAcceptor.klass, "has", VALUEFUNC(_wrap_Acceptor_has), -1);
  rb_define_method(SwigClassAcceptor.klass, "isStopped", VALUEFUNC(_wrap_Acceptor_isStopped), -1);
  rb_define_method(SwigClassAcceptor.klass, "getApplication", VALUEFUNC(_wrap_Acceptor_getApplication), -1);
  rb_define_method(SwigClassAcceptor.klass, "getMessageStoreFactory", VALUEFUNC(_wrap_Acceptor_getMessageStoreFactory), -1);
  SwigClassAcceptor.mark = 0;
  SwigClassAcceptor.destroy = (void (*)(void *)) free_FIX_Acceptor;
  SwigClassAcceptor.trackObjects = 0;
  
  SwigClassSocketAcceptorBase.klass = rb_define_class_under(mQuickfix, "SocketAcceptorBase", ((swig_class *) SWIGTYPE_p_FIX__Acceptor->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketAcceptor, (void *) &SwigClassSocketAcceptorBase);
  rb_define_alloc_func(SwigClassSocketAcceptorBase.klass, _wrap_SocketAcceptorBase_allocate);
  rb_define_method(SwigClassSocketAcceptorBase.klass, "initialize", VALUEFUNC(_wrap_new_SocketAcceptorBase), -1);
  rb_define_method(SwigClassSocketAcceptorBase.klass, "sessionToPort", VALUEFUNC(_wrap_SocketAcceptorBase_sessionToPort), -1);
  SwigClassSocketAcceptorBase.mark = 0;
  SwigClassSocketAcceptorBase.destroy = (void (*)(void *)) free_FIX_SocketAcceptor;
  SwigClassSocketAcceptorBase.trackObjects = 0;
  
  SwigClassDataDictionary.klass = rb_define_class_under(mQuickfix, "DataDictionary", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DataDictionary, (void *) &SwigClassDataDictionary);
  rb_define_alloc_func(SwigClassDataDictionary.klass, _wrap_DataDictionary_allocate);
  rb_define_method(SwigClassDataDictionary.klass, "initialize", VALUEFUNC(_wrap_new_DataDictionary), -1);
  rb_define_method(SwigClassDataDictionary.klass, "readFromURL", VALUEFUNC(_wrap_DataDictionary_readFromURL), -1);
  rb_define_method(SwigClassDataDictionary.klass, "readFromDocument", VALUEFUNC(_wrap_DataDictionary_readFromDocument), -1);
  rb_define_method(SwigClassDataDictionary.klass, "readFromStream", VALUEFUNC(_wrap_DataDictionary_readFromStream), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getOrderedFields", VALUEFUNC(_wrap_DataDictionary_getOrderedFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getHeaderOrderedFields", VALUEFUNC(_wrap_DataDictionary_getHeaderOrderedFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getTrailerOrderedFields", VALUEFUNC(_wrap_DataDictionary_getTrailerOrderedFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getMessageOrderedFields", VALUEFUNC(_wrap_DataDictionary_getMessageOrderedFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "setVersion", VALUEFUNC(_wrap_DataDictionary_setVersion), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getVersion", VALUEFUNC(_wrap_DataDictionary_getVersion), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addField", VALUEFUNC(_wrap_DataDictionary_addField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addFieldName", VALUEFUNC(_wrap_DataDictionary_addFieldName), -1);
  rb_define_method(SwigClassDataDictionary.klass, "_getFieldName", VALUEFUNC(_wrap_DataDictionary__getFieldName), -1);
  rb_define_method(SwigClassDataDictionary.klass, "_getFieldTag", VALUEFUNC(_wrap_DataDictionary__getFieldTag), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addValueName", VALUEFUNC(_wrap_DataDictionary_addValueName), -1);
  rb_define_method(SwigClassDataDictionary.klass, "_getValueName", VALUEFUNC(_wrap_DataDictionary__getValueName), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getNameValue", VALUEFUNC(_wrap_DataDictionary_getNameValue), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isField", VALUEFUNC(_wrap_DataDictionary_isField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addMsgType", VALUEFUNC(_wrap_DataDictionary_addMsgType), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isMsgType", VALUEFUNC(_wrap_DataDictionary_isMsgType), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addMsgField", VALUEFUNC(_wrap_DataDictionary_addMsgField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isMsgField", VALUEFUNC(_wrap_DataDictionary_isMsgField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addHeaderField", VALUEFUNC(_wrap_DataDictionary_addHeaderField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isHeaderField", VALUEFUNC(_wrap_DataDictionary_isHeaderField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addTrailerField", VALUEFUNC(_wrap_DataDictionary_addTrailerField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isTrailerField", VALUEFUNC(_wrap_DataDictionary_isTrailerField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addFieldType", VALUEFUNC(_wrap_DataDictionary_addFieldType), -1);
  rb_define_method(SwigClassDataDictionary.klass, "getFieldType", VALUEFUNC(_wrap_DataDictionary_getFieldType), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addRequiredField", VALUEFUNC(_wrap_DataDictionary_addRequiredField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isRequiredField", VALUEFUNC(_wrap_DataDictionary_isRequiredField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addFieldValue", VALUEFUNC(_wrap_DataDictionary_addFieldValue), -1);
  rb_define_method(SwigClassDataDictionary.klass, "hasFieldValue", VALUEFUNC(_wrap_DataDictionary_hasFieldValue), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isFieldValue", VALUEFUNC(_wrap_DataDictionary_isFieldValue), -1);
  rb_define_method(SwigClassDataDictionary.klass, "addGroup", VALUEFUNC(_wrap_DataDictionary_addGroup), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isGroup", VALUEFUNC(_wrap_DataDictionary_isGroup), -1);
  rb_define_method(SwigClassDataDictionary.klass, "_getGroup", VALUEFUNC(_wrap_DataDictionary__getGroup), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isDataField", VALUEFUNC(_wrap_DataDictionary_isDataField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isMultipleValueField", VALUEFUNC(_wrap_DataDictionary_isMultipleValueField), -1);
  rb_define_method(SwigClassDataDictionary.klass, "checkFieldsOutOfOrder", VALUEFUNC(_wrap_DataDictionary_checkFieldsOutOfOrder), -1);
  rb_define_method(SwigClassDataDictionary.klass, "checkFieldsHaveValues", VALUEFUNC(_wrap_DataDictionary_checkFieldsHaveValues), -1);
  rb_define_method(SwigClassDataDictionary.klass, "checkUserDefinedFields", VALUEFUNC(_wrap_DataDictionary_checkUserDefinedFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "allowUnknownMsgFields", VALUEFUNC(_wrap_DataDictionary_allowUnknownMsgFields), -1);
  rb_define_method(SwigClassDataDictionary.klass, "preserveMessageFieldsOrder", VALUEFUNC(_wrap_DataDictionary_preserveMessageFieldsOrder), -1);
  rb_define_method(SwigClassDataDictionary.klass, "isMessageFieldsOrderPreserved", VALUEFUNC(_wrap_DataDictionary_isMessageFieldsOrderPreserved), -1);
  rb_define_method(SwigClassDataDictionary.klass, "validate", VALUEFUNC(_wrap_DataDictionary_validate), -1);
  SwigClassDataDictionary.mark = 0;
  SwigClassDataDictionary.destroy = (void (*)(void *)) free_FIX_DataDictionary;
  SwigClassDataDictionary.trackObjects = 0;
  
  SwigClassSSLSocketAcceptorBase.klass = rb_define_class_under(mQuickfix, "SSLSocketAcceptorBase", ((swig_class *) SWIGTYPE_p_FIX__Acceptor->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SSLSocketAcceptor, (void *) &SwigClassSSLSocketAcceptorBase);
  rb_define_alloc_func(SwigClassSSLSocketAcceptorBase.klass, _wrap_SSLSocketAcceptorBase_allocate);
  rb_define_method(SwigClassSSLSocketAcceptorBase.klass, "initialize", VALUEFUNC(_wrap_new_SSLSocketAcceptorBase), -1);
  rb_define_method(SwigClassSSLSocketAcceptorBase.klass, "setPassword", VALUEFUNC(_wrap_SSLSocketAcceptorBase_setPassword), -1);
  rb_define_method(SwigClassSSLSocketAcceptorBase.klass, "passwordHandleCallback", VALUEFUNC(_wrap_SSLSocketAcceptorBase_passwordHandleCallback), -1);
  rb_define_singleton_method(SwigClassSSLSocketAcceptorBase.klass, "passPhraseHandleCB", VALUEFUNC(_wrap_SSLSocketAcceptorBase_passPhraseHandleCB), -1);
  SwigClassSSLSocketAcceptorBase.mark = 0;
  SwigClassSSLSocketAcceptorBase.destroy = (void (*)(void *)) free_FIX_SSLSocketAcceptor;
  SwigClassSSLSocketAcceptorBase.trackObjects = 0;
  rb_define_const(mQuickfix, "SSL_HANDSHAKE_FAILED", SWIG_From_int(static_cast< int >(FIX::SSL_HANDSHAKE_FAILED)));
  rb_define_const(mQuickfix, "SSL_HANDSHAKE_SUCCEDED", SWIG_From_int(static_cast< int >(FIX::SSL_HANDSHAKE_SUCCEDED)));
  rb_define_const(mQuickfix, "SSL_HANDSHAKE_IN_PROGRESS", SWIG_From_int(static_cast< int >(FIX::SSL_HANDSHAKE_IN_PROGRESS)));
  
  SwigClassSSLSocketInitiatorBase.klass = rb_define_class_under(mQuickfix, "SSLSocketInitiatorBase", ((swig_class *) SWIGTYPE_p_FIX__Initiator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SSLSocketInitiator, (void *) &SwigClassSSLSocketInitiatorBase);
  rb_define_alloc_func(SwigClassSSLSocketInitiatorBase.klass, _wrap_SSLSocketInitiatorBase_allocate);
  rb_define_method(SwigClassSSLSocketInitiatorBase.klass, "initialize", VALUEFUNC(_wrap_new_SSLSocketInitiatorBase), -1);
  rb_define_method(SwigClassSSLSocketInitiatorBase.klass, "setPassword", VALUEFUNC(_wrap_SSLSocketInitiatorBase_setPassword), -1);
  rb_define_method(SwigClassSSLSocketInitiatorBase.klass, "setCertAndKey", VALUEFUNC(_wrap_SSLSocketInitiatorBase_setCertAndKey), -1);
  rb_define_method(SwigClassSSLSocketInitiatorBase.klass, "passwordHandleCallback", VALUEFUNC(_wrap_SSLSocketInitiatorBase_passwordHandleCallback), -1);
  rb_define_singleton_method(SwigClassSSLSocketInitiatorBase.klass, "passwordHandleCB", VALUEFUNC(_wrap_SSLSocketInitiatorBase_passwordHandleCB), -1);
  SwigClassSSLSocketInitiatorBase.mark = 0;
  SwigClassSSLSocketInitiatorBase.destroy = (void (*)(void *)) free_FIX_SSLSocketInitiator;
  SwigClassSSLSocketInitiatorBase.trackObjects = 0;
  
  SwigClassDatabaseConnectionID.klass = rb_define_class_under(mQuickfix, "DatabaseConnectionID", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DatabaseConnectionID, (void *) &SwigClassDatabaseConnectionID);
  rb_define_alloc_func(SwigClassDatabaseConnectionID.klass, _wrap_DatabaseConnectionID_allocate);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "initialize", VALUEFUNC(_wrap_new_DatabaseConnectionID), -1);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "getDatabase", VALUEFUNC(_wrap_DatabaseConnectionID_getDatabase), -1);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "getUser", VALUEFUNC(_wrap_DatabaseConnectionID_getUser), -1);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "getPassword", VALUEFUNC(_wrap_DatabaseConnectionID_getPassword), -1);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "getHost", VALUEFUNC(_wrap_DatabaseConnectionID_getHost), -1);
  rb_define_method(SwigClassDatabaseConnectionID.klass, "getPort", VALUEFUNC(_wrap_DatabaseConnectionID_getPort), -1);
  SwigClassDatabaseConnectionID.mark = 0;
  SwigClassDatabaseConnectionID.destroy = (void (*)(void *)) free_FIX_DatabaseConnectionID;
  SwigClassDatabaseConnectionID.trackObjects = 0;
  rb_define_module_function(mQuickfix, "<", VALUEFUNC(_wrap___lt__), -1);
  rb_define_module_function(mQuickfix, "==", VALUEFUNC(_wrap___eq__), -1);
  
  SwigClassMySQLQuery.klass = rb_define_class_under(mQuickfix, "MySQLQuery", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLQuery, (void *) &SwigClassMySQLQuery);
  rb_define_alloc_func(SwigClassMySQLQuery.klass, _wrap_MySQLQuery_allocate);
  rb_define_method(SwigClassMySQLQuery.klass, "initialize", VALUEFUNC(_wrap_new_MySQLQuery), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "execute", VALUEFUNC(_wrap_MySQLQuery_execute), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "success", VALUEFUNC(_wrap_MySQLQuery_success), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "rows", VALUEFUNC(_wrap_MySQLQuery_rows), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "reason", VALUEFUNC(_wrap_MySQLQuery_reason), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "getValue", VALUEFUNC(_wrap_MySQLQuery_getValue), -1);
  rb_define_method(SwigClassMySQLQuery.klass, "throwException", VALUEFUNC(_wrap_MySQLQuery_throwException), -1);
  SwigClassMySQLQuery.mark = 0;
  SwigClassMySQLQuery.destroy = (void (*)(void *)) free_FIX_MySQLQuery;
  SwigClassMySQLQuery.trackObjects = 0;
  
  SwigClassMySQLConnection.klass = rb_define_class_under(mQuickfix, "MySQLConnection", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLConnection, (void *) &SwigClassMySQLConnection);
  rb_define_alloc_func(SwigClassMySQLConnection.klass, _wrap_MySQLConnection_allocate);
  rb_define_method(SwigClassMySQLConnection.klass, "initialize", VALUEFUNC(_wrap_new_MySQLConnection), -1);
  rb_define_method(SwigClassMySQLConnection.klass, "connectionID", VALUEFUNC(_wrap_MySQLConnection_connectionID), -1);
  rb_define_method(SwigClassMySQLConnection.klass, "connected", VALUEFUNC(_wrap_MySQLConnection_connected), -1);
  rb_define_method(SwigClassMySQLConnection.klass, "reconnect", VALUEFUNC(_wrap_MySQLConnection_reconnect), -1);
  rb_define_method(SwigClassMySQLConnection.klass, "execute", VALUEFUNC(_wrap_MySQLConnection_execute), -1);
  SwigClassMySQLConnection.mark = 0;
  SwigClassMySQLConnection.destroy = (void (*)(void *)) free_FIX_MySQLConnection;
  SwigClassMySQLConnection.trackObjects = 0;
  
  SwigClassMySQLStoreFactory.klass = rb_define_class_under(mQuickfix, "MySQLStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLStoreFactory, (void *) &SwigClassMySQLStoreFactory);
  rb_define_alloc_func(SwigClassMySQLStoreFactory.klass, _wrap_MySQLStoreFactory_allocate);
  rb_define_method(SwigClassMySQLStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_MySQLStoreFactory), -1);
  rb_define_singleton_method(SwigClassMySQLStoreFactory.klass, "DEFAULT_DATABASE", VALUEFUNC(_wrap_MySQLStoreFactory_DEFAULT_DATABASE_get), 0);
  rb_define_singleton_method(SwigClassMySQLStoreFactory.klass, "DEFAULT_USER", VALUEFUNC(_wrap_MySQLStoreFactory_DEFAULT_USER_get), 0);
  rb_define_singleton_method(SwigClassMySQLStoreFactory.klass, "DEFAULT_PASSWORD", VALUEFUNC(_wrap_MySQLStoreFactory_DEFAULT_PASSWORD_get), 0);
  rb_define_singleton_method(SwigClassMySQLStoreFactory.klass, "DEFAULT_HOST", VALUEFUNC(_wrap_MySQLStoreFactory_DEFAULT_HOST_get), 0);
  rb_define_singleton_method(SwigClassMySQLStoreFactory.klass, "DEFAULT_PORT", VALUEFUNC(_wrap_MySQLStoreFactory_DEFAULT_PORT_get), 0);
  rb_define_method(SwigClassMySQLStoreFactory.klass, "create", VALUEFUNC(_wrap_MySQLStoreFactory_create), -1);
  rb_define_method(SwigClassMySQLStoreFactory.klass, "destroy", VALUEFUNC(_wrap_MySQLStoreFactory_destroy), -1);
  SwigClassMySQLStoreFactory.mark = 0;
  SwigClassMySQLStoreFactory.destroy = (void (*)(void *)) free_FIX_MySQLStoreFactory;
  SwigClassMySQLStoreFactory.trackObjects = 0;
  
  SwigClassMySQLStore.klass = rb_define_class_under(mQuickfix, "MySQLStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLStore, (void *) &SwigClassMySQLStore);
  rb_define_alloc_func(SwigClassMySQLStore.klass, _wrap_MySQLStore_allocate);
  rb_define_method(SwigClassMySQLStore.klass, "initialize", VALUEFUNC(_wrap_new_MySQLStore), -1);
  rb_define_method(SwigClassMySQLStore.klass, "set", VALUEFUNC(_wrap_MySQLStore_set), -1);
  rb_define_method(SwigClassMySQLStore.klass, "get", VALUEFUNC(_wrap_MySQLStore_get), -1);
  rb_define_method(SwigClassMySQLStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MySQLStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassMySQLStore.klass, "getCreationTime", VALUEFUNC(_wrap_MySQLStore_getCreationTime), -1);
  rb_define_method(SwigClassMySQLStore.klass, "reset", VALUEFUNC(_wrap_MySQLStore_reset), -1);
  rb_define_method(SwigClassMySQLStore.klass, "refresh", VALUEFUNC(_wrap_MySQLStore_refresh), -1);
  SwigClassMySQLStore.mark = 0;
  SwigClassMySQLStore.destroy = (void (*)(void *)) free_FIX_MySQLStore;
  SwigClassMySQLStore.trackObjects = 0;
  
  SwigClassMySQLLog.klass = rb_define_class_under(mQuickfix, "MySQLLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLLog, (void *) &SwigClassMySQLLog);
  rb_define_alloc_func(SwigClassMySQLLog.klass, _wrap_MySQLLog_allocate);
  rb_define_method(SwigClassMySQLLog.klass, "initialize", VALUEFUNC(_wrap_new_MySQLLog), -1);
  rb_define_method(SwigClassMySQLLog.klass, "clear", VALUEFUNC(_wrap_MySQLLog_clear), -1);
  rb_define_method(SwigClassMySQLLog.klass, "backup", VALUEFUNC(_wrap_MySQLLog_backup), -1);
  rb_define_method(SwigClassMySQLLog.klass, "setIncomingTable", VALUEFUNC(_wrap_MySQLLog_setIncomingTable), -1);
  rb_define_method(SwigClassMySQLLog.klass, "setOutgoingTable", VALUEFUNC(_wrap_MySQLLog_setOutgoingTable), -1);
  rb_define_method(SwigClassMySQLLog.klass, "setEventTable", VALUEFUNC(_wrap_MySQLLog_setEventTable), -1);
  rb_define_method(SwigClassMySQLLog.klass, "onIncoming", VALUEFUNC(_wrap_MySQLLog_onIncoming), -1);
  rb_define_method(SwigClassMySQLLog.klass, "onOutgoing", VALUEFUNC(_wrap_MySQLLog_onOutgoing), -1);
  rb_define_method(SwigClassMySQLLog.klass, "onEvent", VALUEFUNC(_wrap_MySQLLog_onEvent), -1);
  SwigClassMySQLLog.mark = 0;
  SwigClassMySQLLog.destroy = (void (*)(void *)) free_FIX_MySQLLog;
  SwigClassMySQLLog.trackObjects = 0;
  
  SwigClassMySQLLogFactory.klass = rb_define_class_under(mQuickfix, "MySQLLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MySQLLogFactory, (void *) &SwigClassMySQLLogFactory);
  rb_define_alloc_func(SwigClassMySQLLogFactory.klass, _wrap_MySQLLogFactory_allocate);
  rb_define_method(SwigClassMySQLLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_MySQLLogFactory), -1);
  rb_define_singleton_method(SwigClassMySQLLogFactory.klass, "DEFAULT_DATABASE", VALUEFUNC(_wrap_MySQLLogFactory_DEFAULT_DATABASE_get), 0);
  rb_define_singleton_method(SwigClassMySQLLogFactory.klass, "DEFAULT_USER", VALUEFUNC(_wrap_MySQLLogFactory_DEFAULT_USER_get), 0);
  rb_define_singleton_method(SwigClassMySQLLogFactory.klass, "DEFAULT_PASSWORD", VALUEFUNC(_wrap_MySQLLogFactory_DEFAULT_PASSWORD_get), 0);
  rb_define_singleton_method(SwigClassMySQLLogFactory.klass, "DEFAULT_HOST", VALUEFUNC(_wrap_MySQLLogFactory_DEFAULT_HOST_get), 0);
  rb_define_singleton_method(SwigClassMySQLLogFactory.klass, "DEFAULT_PORT", VALUEFUNC(_wrap_MySQLLogFactory_DEFAULT_PORT_get), 0);
  rb_define_method(SwigClassMySQLLogFactory.klass, "create", VALUEFUNC(_wrap_MySQLLogFactory_create), -1);
  rb_define_method(SwigClassMySQLLogFactory.klass, "destroy", VALUEFUNC(_wrap_MySQLLogFactory_destroy), -1);
  SwigClassMySQLLogFactory.mark = 0;
  SwigClassMySQLLogFactory.destroy = (void (*)(void *)) free_FIX_MySQLLogFactory;
  SwigClassMySQLLogFactory.trackObjects = 0;
  
  SwigClassPostgreSQLQuery.klass = rb_define_class_under(mQuickfix, "PostgreSQLQuery", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLQuery, (void *) &SwigClassPostgreSQLQuery);
  rb_define_alloc_func(SwigClassPostgreSQLQuery.klass, _wrap_PostgreSQLQuery_allocate);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLQuery), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "execute", VALUEFUNC(_wrap_PostgreSQLQuery_execute), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "success", VALUEFUNC(_wrap_PostgreSQLQuery_success), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "rows", VALUEFUNC(_wrap_PostgreSQLQuery_rows), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "reason", VALUEFUNC(_wrap_PostgreSQLQuery_reason), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "getValue", VALUEFUNC(_wrap_PostgreSQLQuery_getValue), -1);
  rb_define_method(SwigClassPostgreSQLQuery.klass, "throwException", VALUEFUNC(_wrap_PostgreSQLQuery_throwException), -1);
  SwigClassPostgreSQLQuery.mark = 0;
  SwigClassPostgreSQLQuery.destroy = (void (*)(void *)) free_FIX_PostgreSQLQuery;
  SwigClassPostgreSQLQuery.trackObjects = 0;
  
  SwigClassPostgreSQLConnection.klass = rb_define_class_under(mQuickfix, "PostgreSQLConnection", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLConnection, (void *) &SwigClassPostgreSQLConnection);
  rb_define_alloc_func(SwigClassPostgreSQLConnection.klass, _wrap_PostgreSQLConnection_allocate);
  rb_define_method(SwigClassPostgreSQLConnection.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLConnection), -1);
  rb_define_method(SwigClassPostgreSQLConnection.klass, "connectionID", VALUEFUNC(_wrap_PostgreSQLConnection_connectionID), -1);
  rb_define_method(SwigClassPostgreSQLConnection.klass, "connected", VALUEFUNC(_wrap_PostgreSQLConnection_connected), -1);
  rb_define_method(SwigClassPostgreSQLConnection.klass, "reconnect", VALUEFUNC(_wrap_PostgreSQLConnection_reconnect), -1);
  rb_define_method(SwigClassPostgreSQLConnection.klass, "execute", VALUEFUNC(_wrap_PostgreSQLConnection_execute), -1);
  SwigClassPostgreSQLConnection.mark = 0;
  SwigClassPostgreSQLConnection.destroy = (void (*)(void *)) free_FIX_PostgreSQLConnection;
  SwigClassPostgreSQLConnection.trackObjects = 0;
  
  SwigClassPostgreSQLStoreFactory.klass = rb_define_class_under(mQuickfix, "PostgreSQLStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLStoreFactory, (void *) &SwigClassPostgreSQLStoreFactory);
  rb_define_alloc_func(SwigClassPostgreSQLStoreFactory.klass, _wrap_PostgreSQLStoreFactory_allocate);
  rb_define_method(SwigClassPostgreSQLStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLStoreFactory), -1);
  rb_define_singleton_method(SwigClassPostgreSQLStoreFactory.klass, "DEFAULT_DATABASE", VALUEFUNC(_wrap_PostgreSQLStoreFactory_DEFAULT_DATABASE_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLStoreFactory.klass, "DEFAULT_USER", VALUEFUNC(_wrap_PostgreSQLStoreFactory_DEFAULT_USER_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLStoreFactory.klass, "DEFAULT_PASSWORD", VALUEFUNC(_wrap_PostgreSQLStoreFactory_DEFAULT_PASSWORD_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLStoreFactory.klass, "DEFAULT_HOST", VALUEFUNC(_wrap_PostgreSQLStoreFactory_DEFAULT_HOST_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLStoreFactory.klass, "DEFAULT_PORT", VALUEFUNC(_wrap_PostgreSQLStoreFactory_DEFAULT_PORT_get), 0);
  rb_define_method(SwigClassPostgreSQLStoreFactory.klass, "create", VALUEFUNC(_wrap_PostgreSQLStoreFactory_create), -1);
  rb_define_method(SwigClassPostgreSQLStoreFactory.klass, "destroy", VALUEFUNC(_wrap_PostgreSQLStoreFactory_destroy), -1);
  SwigClassPostgreSQLStoreFactory.mark = 0;
  SwigClassPostgreSQLStoreFactory.destroy = (void (*)(void *)) free_FIX_PostgreSQLStoreFactory;
  SwigClassPostgreSQLStoreFactory.trackObjects = 0;
  
  SwigClassPostgreSQLStore.klass = rb_define_class_under(mQuickfix, "PostgreSQLStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLStore, (void *) &SwigClassPostgreSQLStore);
  rb_define_alloc_func(SwigClassPostgreSQLStore.klass, _wrap_PostgreSQLStore_allocate);
  rb_define_method(SwigClassPostgreSQLStore.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLStore), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "set", VALUEFUNC(_wrap_PostgreSQLStore_set), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "get", VALUEFUNC(_wrap_PostgreSQLStore_get), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_PostgreSQLStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "getCreationTime", VALUEFUNC(_wrap_PostgreSQLStore_getCreationTime), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "reset", VALUEFUNC(_wrap_PostgreSQLStore_reset), -1);
  rb_define_method(SwigClassPostgreSQLStore.klass, "refresh", VALUEFUNC(_wrap_PostgreSQLStore_refresh), -1);
  SwigClassPostgreSQLStore.mark = 0;
  SwigClassPostgreSQLStore.destroy = (void (*)(void *)) free_FIX_PostgreSQLStore;
  SwigClassPostgreSQLStore.trackObjects = 0;
  
  SwigClassPostgreSQLLog.klass = rb_define_class_under(mQuickfix, "PostgreSQLLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLLog, (void *) &SwigClassPostgreSQLLog);
  rb_define_alloc_func(SwigClassPostgreSQLLog.klass, _wrap_PostgreSQLLog_allocate);
  rb_define_method(SwigClassPostgreSQLLog.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLLog), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "clear", VALUEFUNC(_wrap_PostgreSQLLog_clear), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "backup", VALUEFUNC(_wrap_PostgreSQLLog_backup), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "setIncomingTable", VALUEFUNC(_wrap_PostgreSQLLog_setIncomingTable), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "setOutgoingTable", VALUEFUNC(_wrap_PostgreSQLLog_setOutgoingTable), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "setEventTable", VALUEFUNC(_wrap_PostgreSQLLog_setEventTable), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "onIncoming", VALUEFUNC(_wrap_PostgreSQLLog_onIncoming), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "onOutgoing", VALUEFUNC(_wrap_PostgreSQLLog_onOutgoing), -1);
  rb_define_method(SwigClassPostgreSQLLog.klass, "onEvent", VALUEFUNC(_wrap_PostgreSQLLog_onEvent), -1);
  SwigClassPostgreSQLLog.mark = 0;
  SwigClassPostgreSQLLog.destroy = (void (*)(void *)) free_FIX_PostgreSQLLog;
  SwigClassPostgreSQLLog.trackObjects = 0;
  
  SwigClassPostgreSQLLogFactory.klass = rb_define_class_under(mQuickfix, "PostgreSQLLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PostgreSQLLogFactory, (void *) &SwigClassPostgreSQLLogFactory);
  rb_define_alloc_func(SwigClassPostgreSQLLogFactory.klass, _wrap_PostgreSQLLogFactory_allocate);
  rb_define_method(SwigClassPostgreSQLLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_PostgreSQLLogFactory), -1);
  rb_define_singleton_method(SwigClassPostgreSQLLogFactory.klass, "DEFAULT_DATABASE", VALUEFUNC(_wrap_PostgreSQLLogFactory_DEFAULT_DATABASE_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLLogFactory.klass, "DEFAULT_USER", VALUEFUNC(_wrap_PostgreSQLLogFactory_DEFAULT_USER_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLLogFactory.klass, "DEFAULT_PASSWORD", VALUEFUNC(_wrap_PostgreSQLLogFactory_DEFAULT_PASSWORD_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLLogFactory.klass, "DEFAULT_HOST", VALUEFUNC(_wrap_PostgreSQLLogFactory_DEFAULT_HOST_get), 0);
  rb_define_singleton_method(SwigClassPostgreSQLLogFactory.klass, "DEFAULT_PORT", VALUEFUNC(_wrap_PostgreSQLLogFactory_DEFAULT_PORT_get), 0);
  rb_define_method(SwigClassPostgreSQLLogFactory.klass, "create", VALUEFUNC(_wrap_PostgreSQLLogFactory_create), -1);
  rb_define_method(SwigClassPostgreSQLLogFactory.klass, "destroy", VALUEFUNC(_wrap_PostgreSQLLogFactory_destroy), -1);
  SwigClassPostgreSQLLogFactory.mark = 0;
  SwigClassPostgreSQLLogFactory.destroy = (void (*)(void *)) free_FIX_PostgreSQLLogFactory;
  SwigClassPostgreSQLLogFactory.trackObjects = 0;
  
#ifndef _MSC_VER
  struct sigaction new_action, old_action;
  new_action.sa_handler = SIG_DFL;
  sigemptyset( &new_action.sa_mask );
  new_action.sa_flags = 0;
  sigaction( SIGINT, &new_action, &old_action );
#endif
  
}

